#include "EmersonUtil.h"
#include "Util.h"
#include <antlr3.h>
#include <iostream>
#include <fstream>
#include <string>
#include "EmersonLexer.h"
#include "EmersonParser.h"
#include "EmersonTree.h"


using namespace std;


extern pANTLR3_UINT8  EmersonParserTokenNames[];

pANTLR3_STRING emerson_printAST(pANTLR3_BASE_TREE tree)
{
    emerson_printAST(tree,EmersonParserTokenNames);
}


char* emerson_compile(const char* em_script_str)
{
// printf("Trying to compile \n %s\n", em_script_str);

    pANTLR3_UINT8 str = (pANTLR3_UINT8)em_script_str;
    pANTLR3_INPUT_STREAM input = antlr3NewAsciiStringCopyStream(str, strlen(em_script_str), NULL);
    char* js_str;

    pEmersonLexer lxr;
    pEmersonParser psr;
    pANTLR3_COMMON_TOKEN_STREAM tstream;
    EmersonParser_program_return emersonAST;
    pANTLR3_COMMON_TREE_NODE_STREAM	nodes;
    pEmersonTree treePsr;

    
    if (input == NULL)
    {
        fprintf(stderr, "Unable to create input stream");
        exit(ANTLR3_ERR_NOMEM);
    }

    lxr= EmersonLexerNew(input);
    if ( lxr == NULL )
    {
        fprintf(stderr, "Unable to create the lexer due to malloc() failure1\n");
        exit(ANTLR3_ERR_NOMEM);
    }
    tstream = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, TOKENSOURCE(lxr));
    
    if (tstream == NULL)
    {
        fprintf(stderr, "Out of memory trying to allocate token stream\n");
        exit(ANTLR3_ERR_NOMEM);
    }


    psr= EmersonParserNew(tstream);  // CParserNew is generated by ANTLR3
    if (psr == NULL)
    {
        fprintf(stderr, "Out of memory trying to allocate parser\n");
        exit(ANTLR3_ERR_NOMEM);
    }

    emersonAST = psr->program(psr);
    if (psr->pParser->rec->state->errorCount > 0)
    {
        fprintf(stderr, "The parser returned %d errors, tree walking aborted.\n", psr->pParser->rec->state->errorCount);
        
    }
    else
    {
        //printf("Emerson Tree after parsing \n%s\n", emerson_printAST(emersonAST.tree)->chars);
        nodes = antlr3CommonTreeNodeStreamNewTree(emersonAST.tree, ANTLR3_SIZE_HINT); // sIZE
                                                                                      // HINT
                                                                                      // WILL
                                                                                      // SOON
                                                                                      // BE
                                                                                      // DEPRECATED!!

        treePsr= EmersonTreeNew(nodes);
        js_str = (char*)treePsr->program(treePsr)->chars;
        nodes   ->free  (nodes);	    nodes	= NULL;
        treePsr ->free  (treePsr);	    treePsr	= NULL;
    }
    
    psr->free(psr);
    psr= NULL;
    
    tstream->free  (tstream);
    tstream= NULL;

    lxr->free(lxr);
    lxr= NULL;

    input->close (input);
    input= NULL;

    return js_str;
}

char* emerson_compile_diag(const char* em_script_str, FILE* dbg)
{
    fprintf(dbg, "Trying to compile \n %s\n", em_script_str);

    pANTLR3_UINT8 str = (pANTLR3_UINT8)em_script_str;
    pANTLR3_INPUT_STREAM input = antlr3NewAsciiStringCopyStream(str, strlen(em_script_str), NULL);
    char* js_str;

    pEmersonLexer lxr;
    pEmersonParser psr;
    pANTLR3_COMMON_TOKEN_STREAM tstream;
    EmersonParser_program_return emersonAST;
    pANTLR3_COMMON_TREE_NODE_STREAM	nodes;
    pEmersonTree treePsr;
    
    if (input == NULL)
    {
        fprintf(stderr, "Unable to create input stream");
        fprintf(dbg, "Unable to create input stream");
        exit(ANTLR3_ERR_NOMEM);
    }

    lxr = EmersonLexerNew(input);
    if ( lxr == NULL )
    {
        fprintf(stderr, "Unable to create the lexer due to malloc() failure1\n");
        fprintf(dbg, "Unable to create the lexer due to malloc() failure1\n");
        exit(ANTLR3_ERR_NOMEM);
    }
    tstream = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, TOKENSOURCE(lxr));

    if (tstream == NULL)
    {
        fprintf(stderr, "Out of memory trying to allocate token stream\n");
        fprintf(dbg, "Out of memory trying to allocate token stream\n");
        exit(ANTLR3_ERR_NOMEM);
    }
    
    psr = EmersonParserNew(tstream);  // CParserNew is generated by ANTLR3
    if (psr == NULL)
    {
        fprintf(stderr, "Out of memory trying to allocate parser\n");
        fprintf(dbg, "Out of memory trying to allocate parser\n");
        exit(ANTLR3_ERR_NOMEM);
    }

    emersonAST = psr->program(psr);
    if (psr->pParser->rec->state->errorCount > 0)
    {
        fprintf(stderr, "The parser returned %d errors, tree walking aborted.\n", psr->pParser->rec->state->errorCount);
        fprintf(stderr, "The parser returned %d errors, tree walking aborted.\n", psr->pParser->rec->state->errorCount);

    }
    else
    {

        fprintf(dbg, "Emerson Tree after parsing \n%s\n", emerson_printAST(emersonAST.tree)->chars);
        nodes = antlr3CommonTreeNodeStreamNewTree(emersonAST.tree, ANTLR3_SIZE_HINT); // sIZE
                                                                                      // HINT
                                                                                      // WILL
                                                                                      // SOON
                                                                                      // BE
                                                                                      // DEPRECATED!!

        treePsr= EmersonTreeNew(nodes);
        js_str = (char*)treePsr->program(treePsr)->chars;

        fprintf(dbg, "The generated code is \n %s \n", js_str);


        nodes->free(nodes);
        nodes = NULL;
        treePsr->free(treePsr);
        treePsr	= NULL;
    }
    psr->free(psr);
    psr= NULL;
    
    tstream->free(tstream);
    tstream= NULL;

    lxr->free(lxr);
    lxr= NULL;

    input->close(input);
    input= NULL;

    return js_str;
}
