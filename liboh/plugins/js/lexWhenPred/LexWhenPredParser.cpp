/** \file
 *  This C source file was generated by $ANTLR version 3.1.3 Mar 17, 2009 19:23:44
 *
 *     -  From the grammar source file : .//LexWhenPred.g
 *     -                            On : 2011-02-24 12:27:27
 *     -                for the parser : LexWhenPredParserParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

  #include <stdlib.h>;
  #include <stdio.h>;
  #include "../emerson/Util.h";

/* End of Header action.
 * =============================================================================
 */
/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "LexWhenPredParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pLexWhenPredParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pLexWhenPredParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pLexWhenPredParser_##scope##Top
#define	SCOPE_SIZE(scope)			(ctx->SCOPE_STACK(scope)->size(ctx->SCOPE_STACK(scope)))
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER		    
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO		    
#undef		DBG

#define	    PARSER							ctx->pParser  
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		MEMOIZE(ri,si)					RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT							PARSER->tstream
#define	    STRSTREAM						INPUT
#define		ISTREAM							INPUT->istream
#define		INDEX()							ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger

#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   LexWhenPredParserTokenNames[48+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "LTERM",
        (pANTLR3_UINT8) "PROG",
        (pANTLR3_UINT8) "WHEN_PRED_BLOCK",
        (pANTLR3_UINT8) "Identifier",
        (pANTLR3_UINT8) "StringLiteral",
        (pANTLR3_UINT8) "NumericLiteral",
        (pANTLR3_UINT8) "DoubleStringCharacter",
        (pANTLR3_UINT8) "SingleStringCharacter",
        (pANTLR3_UINT8) "EscapeSequence",
        (pANTLR3_UINT8) "CharacterEscapeSequence",
        (pANTLR3_UINT8) "HexEscapeSequence",
        (pANTLR3_UINT8) "UnicodeEscapeSequence",
        (pANTLR3_UINT8) "SingleEscapeCharacter",
        (pANTLR3_UINT8) "NonEscapeCharacter",
        (pANTLR3_UINT8) "EscapeCharacter",
        (pANTLR3_UINT8) "DecimalDigit",
        (pANTLR3_UINT8) "HexDigit",
        (pANTLR3_UINT8) "DecimalLiteral",
        (pANTLR3_UINT8) "HexIntegerLiteral",
        (pANTLR3_UINT8) "ExponentPart",
        (pANTLR3_UINT8) "IdentifierStart",
        (pANTLR3_UINT8) "IdentifierPart",
        (pANTLR3_UINT8) "UnicodeLetter",
        (pANTLR3_UINT8) "UnicodeDigit",
        (pANTLR3_UINT8) "UnicodeConnectorPunctuation",
        (pANTLR3_UINT8) "UnicodeCombiningMark",
        (pANTLR3_UINT8) "Comment",
        (pANTLR3_UINT8) "LineComment",
        (pANTLR3_UINT8) "WhiteSpace",
        (pANTLR3_UINT8) "'+'",
        (pANTLR3_UINT8) "'-'",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "'['",
        (pANTLR3_UINT8) "']'",
        (pANTLR3_UINT8) "'!'",
        (pANTLR3_UINT8) "'='",
        (pANTLR3_UINT8) "'*'",
        (pANTLR3_UINT8) "'/'",
        (pANTLR3_UINT8) "'>'",
        (pANTLR3_UINT8) "'<'",
        (pANTLR3_UINT8) "'%'",
        (pANTLR3_UINT8) "'&'",
        (pANTLR3_UINT8) "'|'",
        (pANTLR3_UINT8) "'^'",
        (pANTLR3_UINT8) "'{'",
        (pANTLR3_UINT8) "'}'",
        (pANTLR3_UINT8) "';'"
       };

        

// Forward declare the locally static matching functions we have generated.
//
static LexWhenPredParser_program_return	program    (pLexWhenPredParser ctx);
static LexWhenPredParser_sourceElements_return	sourceElements    (pLexWhenPredParser ctx);
static LexWhenPredParser_sourceElement_return	sourceElement    (pLexWhenPredParser ctx);
static LexWhenPredParser_whenPredStatement_return	whenPredStatement    (pLexWhenPredParser ctx);
static LexWhenPredParser_literal_return	literal    (pLexWhenPredParser ctx);
static LexWhenPredParser_separator_return	separator    (pLexWhenPredParser ctx);
static ANTLR3_BOOLEAN	synpred7_LexWhenPred    (pLexWhenPredParser ctx);
static ANTLR3_BOOLEAN	synpred8_LexWhenPred    (pLexWhenPredParser ctx);
static ANTLR3_BOOLEAN	synpred9_LexWhenPred    (pLexWhenPredParser ctx);
static ANTLR3_BOOLEAN	synpred10_LexWhenPred    (pLexWhenPredParser ctx);
static void	LexWhenPredParserFree(pLexWhenPredParser ctx);
/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = ".//LexWhenPred.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new LexWhenPredParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pLexWhenPredParser
LexWhenPredParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return LexWhenPredParserNewSSD(instream, NULL);
}

/** \brief Create a new LexWhenPredParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pLexWhenPredParser
LexWhenPredParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pLexWhenPredParser ctx;	    /* Context structure we will build and return   */
    
    ctx	= (pLexWhenPredParser) ANTLR3_CALLOC(1, sizeof(LexWhenPredParser));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in LexWhenPredParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our LexWhenPredParser interface
     */
    ctx->program	= program;
    ctx->sourceElements	= sourceElements;
    ctx->sourceElement	= sourceElement;
    ctx->whenPredStatement	= whenPredStatement;
    ctx->literal	= literal;
    ctx->separator	= separator;
    ctx->synpred7_LexWhenPred	= synpred7_LexWhenPred;
    ctx->synpred8_LexWhenPred	= synpred8_LexWhenPred;
    ctx->synpred9_LexWhenPred	= synpred9_LexWhenPred;
    ctx->synpred10_LexWhenPred	= synpred10_LexWhenPred;
    ctx->free			= LexWhenPredParserFree;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */
    ADAPTOR	= ANTLR3_TREE_ADAPTORNew(instream->tstream->tokenSource->strFactory);
    ctx->vectors	= antlr3VectorFactoryNew(0);
    

    /* Create a LIST for recording rule memos.
     */
     RULEMEMO    = antlr3IntTrieNew(15);	/* 16 bit depth is enough for 32768 rules! */
	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = LexWhenPredParserTokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 LexWhenPredParserFree(pLexWhenPredParser ctx)
 {
    /* Free any scope memory
     */
    
    ctx->vectors->close(ctx->vectors);
    /* We created the adaptor so we must free it
     */
    ADAPTOR->free(ADAPTOR);
	if	(RULEMEMO != NULL)
	{
		RULEMEMO->free(RULEMEMO);
		RULEMEMO = NULL;
	}	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return LexWhenPredParserTokenNames; 
}

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_LTERM_in_program99  */
static	ANTLR3_BITWORD FOLLOW_LTERM_in_program99_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000390) };
static  ANTLR3_BITSET_LIST FOLLOW_LTERM_in_program99	= { FOLLOW_LTERM_in_program99_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sourceElements_in_program102  */
static	ANTLR3_BITWORD FOLLOW_sourceElements_in_program102_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_sourceElements_in_program102	= { FOLLOW_sourceElements_in_program102_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LTERM_in_program104  */
static	ANTLR3_BITWORD FOLLOW_LTERM_in_program104_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LTERM_in_program104	= { FOLLOW_LTERM_in_program104_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_program107  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_program107_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_program107	= { FOLLOW_EOF_in_program107_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sourceElement_in_sourceElements127  */
static	ANTLR3_BITWORD FOLLOW_sourceElement_in_sourceElements127_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000392) };
static  ANTLR3_BITSET_LIST FOLLOW_sourceElement_in_sourceElements127	= { FOLLOW_sourceElement_in_sourceElements127_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LTERM_in_sourceElements130  */
static	ANTLR3_BITWORD FOLLOW_LTERM_in_sourceElements130_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000390) };
static  ANTLR3_BITSET_LIST FOLLOW_LTERM_in_sourceElements130	= { FOLLOW_LTERM_in_sourceElements130_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sourceElement_in_sourceElements133  */
static	ANTLR3_BITWORD FOLLOW_sourceElement_in_sourceElements133_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000392) };
static  ANTLR3_BITSET_LIST FOLLOW_sourceElement_in_sourceElements133	= { FOLLOW_sourceElement_in_sourceElements133_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_whenPredStatement_in_sourceElement161  */
static	ANTLR3_BITWORD FOLLOW_whenPredStatement_in_sourceElement161_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_whenPredStatement_in_sourceElement161	= { FOLLOW_whenPredStatement_in_sourceElement161_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_literal_in_whenPredStatement186  */
static	ANTLR3_BITWORD FOLLOW_literal_in_whenPredStatement186_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000380) };
static  ANTLR3_BITSET_LIST FOLLOW_literal_in_whenPredStatement186	= { FOLLOW_literal_in_whenPredStatement186_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_whenPredStatement191  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_whenPredStatement191_bits[]	= { ANTLR3_UINT64_LIT(0x000FFFFE00000312) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_whenPredStatement191	= { FOLLOW_Identifier_in_whenPredStatement191_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_separator_in_whenPredStatement195  */
static	ANTLR3_BITWORD FOLLOW_separator_in_whenPredStatement195_bits[]	= { ANTLR3_UINT64_LIT(0x000FFFFE00000090) };
static  ANTLR3_BITSET_LIST FOLLOW_separator_in_whenPredStatement195	= { FOLLOW_separator_in_whenPredStatement195_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_whenPredStatement201  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_whenPredStatement201_bits[]	= { ANTLR3_UINT64_LIT(0x000FFFFE00000312) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_whenPredStatement201	= { FOLLOW_Identifier_in_whenPredStatement201_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_separator_in_whenPredStatement205  */
static	ANTLR3_BITWORD FOLLOW_separator_in_whenPredStatement205_bits[]	= { ANTLR3_UINT64_LIT(0x000FFFFE00000312) };
static  ANTLR3_BITSET_LIST FOLLOW_separator_in_whenPredStatement205	= { FOLLOW_separator_in_whenPredStatement205_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_literal_in_whenPredStatement208  */
static	ANTLR3_BITWORD FOLLOW_literal_in_whenPredStatement208_bits[]	= { ANTLR3_UINT64_LIT(0x000FFFFE00000312) };
static  ANTLR3_BITSET_LIST FOLLOW_literal_in_whenPredStatement208	= { FOLLOW_literal_in_whenPredStatement208_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_separator_in_whenPredStatement211  */
static	ANTLR3_BITWORD FOLLOW_separator_in_whenPredStatement211_bits[]	= { ANTLR3_UINT64_LIT(0x000FFFFE00000012) };
static  ANTLR3_BITSET_LIST FOLLOW_separator_in_whenPredStatement211	= { FOLLOW_separator_in_whenPredStatement211_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_literal0  */
static	ANTLR3_BITWORD FOLLOW_set_in_literal0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_literal0	= { FOLLOW_set_in_literal0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_separator0  */
static	ANTLR3_BITWORD FOLLOW_set_in_separator0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_separator0	= { FOLLOW_set_in_separator0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_separator_in_synpred7_LexWhenPred195  */
static	ANTLR3_BITWORD FOLLOW_separator_in_synpred7_LexWhenPred195_bits[]	= { ANTLR3_UINT64_LIT(0x000FFFFE00000090) };
static  ANTLR3_BITSET_LIST FOLLOW_separator_in_synpred7_LexWhenPred195	= { FOLLOW_separator_in_synpred7_LexWhenPred195_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Identifier_in_synpred7_LexWhenPred201  */
static	ANTLR3_BITWORD FOLLOW_Identifier_in_synpred7_LexWhenPred201_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Identifier_in_synpred7_LexWhenPred201	= { FOLLOW_Identifier_in_synpred7_LexWhenPred201_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_separator_in_synpred8_LexWhenPred205  */
static	ANTLR3_BITWORD FOLLOW_separator_in_synpred8_LexWhenPred205_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_separator_in_synpred8_LexWhenPred205	= { FOLLOW_separator_in_synpred8_LexWhenPred205_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_literal_in_synpred9_LexWhenPred208  */
static	ANTLR3_BITWORD FOLLOW_literal_in_synpred9_LexWhenPred208_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_literal_in_synpred9_LexWhenPred208	= { FOLLOW_literal_in_synpred9_LexWhenPred208_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_separator_in_synpred10_LexWhenPred211  */
static	ANTLR3_BITWORD FOLLOW_separator_in_synpred10_LexWhenPred211_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_separator_in_synpred10_LexWhenPred211	= { FOLLOW_separator_in_synpred10_LexWhenPred211_bits, 1	};
     


/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    ()* loopback of 40:18: ( ( LTERM )* sourceElement )*
 */
static const ANTLR3_INT32 dfa4_eot[4] =
    {
	-1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa4_eof[4] =
    {
	2, 2, -1, -1
    };
static const ANTLR3_INT32 dfa4_min[4] =
    {
	4, 4, -1, -1
    };
static const ANTLR3_INT32 dfa4_max[4] =
    {
	9, 9, -1, -1
    };
static const ANTLR3_INT32 dfa4_accept[4] =
    {
	-1, -1, 2, 1
    };
static const ANTLR3_INT32 dfa4_special[4] =
    {	
	-1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa4_T_empty	    NULL

static const ANTLR3_INT32 dfa4_T0[] =
    {
	1, -1, -1, 3, 3, 3
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa4_transitions[] =
{
    dfa4_T0, dfa4_T0, dfa4_T_empty, dfa4_T_empty	
};


/* Declare tracking structure for Cyclic DFA 4
 */
static
ANTLR3_CYCLIC_DFA cdfa4
    =	{
	    4,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"()* loopback of 40:18: ( ( LTERM )* sourceElement )*",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa4_eot,	    /* EOT table			    */
	    dfa4_eof,	    /* EOF table			    */
	    dfa4_min,	    /* Minimum tokens for each state    */
	    dfa4_max,	    /* Maximum tokens for each state    */
	    dfa4_accept,	/* Accept table			    */
	    dfa4_special,	/* Special transition states	    */
	    dfa4_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 4
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()* loopback of 50:34: ( ( separator )+ s2= Identifier )*
 */
static const ANTLR3_INT32 dfa7_eot[6] =
    {
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa7_eof[6] =
    {
	2, 2, -1, 2, -1, -1
    };
static const ANTLR3_INT32 dfa7_min[6] =
    {
	4, 4, -1, 4, 0, -1
    };
static const ANTLR3_INT32 dfa7_max[6] =
    {
	51, 51, -1, 51, 0, -1
    };
static const ANTLR3_INT32 dfa7_accept[6] =
    {
	-1, -1, 2, -1, -1, 1
    };
static const ANTLR3_INT32 dfa7_special[6] =
    {	
	-1, -1, -1, -1, 0, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa7_T_empty	    NULL

static const ANTLR3_INT32 dfa7_T0[] =
    {
	1, -1, -1, 4, 2, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa7_T1[] =
    {
	1, -1, -1, 2, 2, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa7_T2[] =
    {
	-1
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa7_transitions[] =
{
    dfa7_T1, dfa7_T0, dfa7_T_empty, dfa7_T0, dfa7_T2, dfa7_T_empty	
};

static ANTLR3_INT32 dfa7_sst(pLexWhenPredParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;
    
    _s	    = s;
    switch  (s)
    {
        case 0:
        
    	{
    	    ANTLR3_UINT32 LA7_4;

    	    ANTLR3_MARKER index7_4;


    		LA7_4 = LA(1);

    	 
    	    index7_4 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred7_LexWhenPred(ctx)) )
    	    {
    	        s = 5;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 2;
    	    }

    	 
    		SEEK(index7_4);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }    
    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"()* loopback of 50:34: ( ( separator )+ s2= Identifier )*";
    EXCEPTION->decisionNum  = 7;
    EXCEPTION->state        = _s;
    return -1;
}

/* Declare tracking structure for Cyclic DFA 7
 */
static
ANTLR3_CYCLIC_DFA cdfa7
    =	{
	    7,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"()* loopback of 50:34: ( ( separator )+ s2= Identifier )*",	
	    (CDFA_SPECIAL_FUNC) dfa7_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa7_eot,	    /* EOT table			    */
	    dfa7_eof,	    /* EOF table			    */
	    dfa7_min,	    /* Minimum tokens for each state    */
	    dfa7_max,	    /* Maximum tokens for each state    */
	    dfa7_accept,	/* Accept table			    */
	    dfa7_special,	/* Special transition states	    */
	    dfa7_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 7
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the parser
 */ 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start program
 * .//LexWhenPred.g:35:1: program : (a= LTERM )* sourceElements ( LTERM )* EOF -> ^( PROG sourceElements ) ;
 */
static LexWhenPredParser_program_return
program(pLexWhenPredParser ctx)
{   
    LexWhenPredParser_program_return retval;
    ANTLR3_UINT32 program_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    a;
    pANTLR3_COMMON_TOKEN    LTERM2;
    pANTLR3_COMMON_TOKEN    EOF3;
    LexWhenPredParser_sourceElements_return sourceElements1;
    #undef	RETURN_TYPE_sourceElements1
    #define	RETURN_TYPE_sourceElements1 LexWhenPredParser_sourceElements_return

    pANTLR3_BASE_TREE a_tree;
    pANTLR3_BASE_TREE LTERM2_tree;
    pANTLR3_BASE_TREE EOF3_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_LTERM;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_EOF;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_sourceElements;
    /* Initialize rule variables
     */
    program_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(1)) )
    {
    	retval.start = 0;

        return retval; 
    }
    a       = NULL;
    LTERM2       = NULL;
    EOF3       = NULL;
    sourceElements1.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    a_tree   = NULL;
    LTERM2_tree   = NULL;
    EOF3_tree   = NULL;

    stream_LTERM   = NULL;
    #define CREATE_stream_LTERM  if (stream_LTERM == NULL) {stream_LTERM = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token LTERM"); } 
    stream_EOF   = NULL;
    #define CREATE_stream_EOF  if (stream_EOF == NULL) {stream_EOF = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token EOF"); } 
    stream_sourceElements   = NULL;
    #define CREATE_stream_sourceElements  if (stream_sourceElements == NULL) {stream_sourceElements = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule sourceElements"); }

    retval.tree  = NULL;
    {
        // .//LexWhenPred.g:36:2: ( (a= LTERM )* sourceElements ( LTERM )* EOF -> ^( PROG sourceElements ) )
        // .//LexWhenPred.g:36:4: (a= LTERM )* sourceElements ( LTERM )* EOF
        {

            // .//LexWhenPred.g:36:5: (a= LTERM )*

            for (;;)
            {
                int alt1=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA1_0 = LA(1);
                    if ( (LA1_0 == LTERM) ) 
                    {
                        alt1=1;
                    }

                }
                switch (alt1) 
                {
            	case 1:
            	    // .//LexWhenPred.g:0:0: a= LTERM
            	    {
            	        a = (pANTLR3_COMMON_TOKEN) MATCHT(LTERM, &FOLLOW_LTERM_in_program99); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprogramEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_LTERM; stream_LTERM->add(stream_LTERM, a, NULL); }


            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */

            FOLLOWPUSH(FOLLOW_sourceElements_in_program102);
            sourceElements1=sourceElements(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprogramEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) { CREATE_stream_sourceElements; stream_sourceElements->add(stream_sourceElements, sourceElements1.tree, NULL); }

            // .//LexWhenPred.g:36:28: ( LTERM )*

            for (;;)
            {
                int alt2=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA2_0 = LA(1);
                    if ( (LA2_0 == LTERM) ) 
                    {
                        alt2=1;
                    }

                }
                switch (alt2) 
                {
            	case 1:
            	    // .//LexWhenPred.g:0:0: LTERM
            	    {
            	        LTERM2 = (pANTLR3_COMMON_TOKEN) MATCHT(LTERM, &FOLLOW_LTERM_in_program104); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprogramEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_LTERM; stream_LTERM->add(stream_LTERM, LTERM2, NULL); }


            	    }
            	    break;

            	default:
            	    goto loop2;	/* break out of the loop */
            	    break;
                }
            }
            loop2: ; /* Jump out to here if this rule does not match */

            EOF3 = (pANTLR3_COMMON_TOKEN) MATCHT(EOF, &FOLLOW_EOF_in_program107); 
            if  (HASEXCEPTION())
            {
                goto ruleprogramEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_EOF; stream_EOF->add(stream_EOF, EOF3, NULL); }


             
            /* AST REWRITE
             * elements          : sourceElements
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 36:39: -> ^( PROG sourceElements )
            	{
            	    // .//LexWhenPred.g:36:42: ^( PROG sourceElements )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PROG, (pANTLR3_UINT8)"PROG"), root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_sourceElements == NULL ? NULL : stream_sourceElements->nextTree(stream_sourceElements));

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleprogramEx; /* Prevent compiler warnings */
    ruleprogramEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_LTERM != NULL) stream_LTERM->free(stream_LTERM);
        if (stream_EOF != NULL) stream_EOF->free(stream_EOF);
        if (stream_sourceElements != NULL) stream_sourceElements->free(stream_sourceElements);
    }

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
    }

    if ( BACKTRACKING>0 ) { MEMOIZE(1, program_StartIndex); }
    return retval;
}
/* $ANTLR end program */

/** 
 * $ANTLR start sourceElements
 * .//LexWhenPred.g:39:1: sourceElements : sourceElement ( ( LTERM )* sourceElement )* -> ( sourceElement )+ ;
 */
static LexWhenPredParser_sourceElements_return
sourceElements(pLexWhenPredParser ctx)
{   
    LexWhenPredParser_sourceElements_return retval;
    ANTLR3_UINT32 sourceElements_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    LTERM5;
    LexWhenPredParser_sourceElement_return sourceElement4;
    #undef	RETURN_TYPE_sourceElement4
    #define	RETURN_TYPE_sourceElement4 LexWhenPredParser_sourceElement_return

    LexWhenPredParser_sourceElement_return sourceElement6;
    #undef	RETURN_TYPE_sourceElement6
    #define	RETURN_TYPE_sourceElement6 LexWhenPredParser_sourceElement_return

    pANTLR3_BASE_TREE LTERM5_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_LTERM;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_sourceElement;
    /* Initialize rule variables
     */
    sourceElements_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(2)) )
    {
    	retval.start = 0;

        return retval; 
    }
    LTERM5       = NULL;
    sourceElement4.tree = NULL;

    sourceElement6.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    LTERM5_tree   = NULL;

    stream_LTERM   = NULL;
    #define CREATE_stream_LTERM  if (stream_LTERM == NULL) {stream_LTERM = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token LTERM"); } 
    stream_sourceElement   = NULL;
    #define CREATE_stream_sourceElement  if (stream_sourceElement == NULL) {stream_sourceElement = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule sourceElement"); }

    retval.tree  = NULL;
    {
        // .//LexWhenPred.g:40:2: ( sourceElement ( ( LTERM )* sourceElement )* -> ( sourceElement )+ )
        // .//LexWhenPred.g:40:4: sourceElement ( ( LTERM )* sourceElement )*
        {
            FOLLOWPUSH(FOLLOW_sourceElement_in_sourceElements127);
            sourceElement4=sourceElement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesourceElementsEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) { CREATE_stream_sourceElement; stream_sourceElement->add(stream_sourceElement, sourceElement4.tree, NULL); }

            // .//LexWhenPred.g:40:18: ( ( LTERM )* sourceElement )*

            for (;;)
            {
                int alt4=2;
                alt4 = cdfa4.predict(ctx, RECOGNIZER, ISTREAM, &cdfa4);
                if  (HASEXCEPTION())
                {
                    goto rulesourceElementsEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                switch (alt4) 
                {
            	case 1:
            	    // .//LexWhenPred.g:40:19: ( LTERM )* sourceElement
            	    {

            	        // .//LexWhenPred.g:40:19: ( LTERM )*

            	        for (;;)
            	        {
            	            int alt3=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA3_0 = LA(1);
            	                if ( (LA3_0 == LTERM) ) 
            	                {
            	                    alt3=1;
            	                }

            	            }
            	            switch (alt3) 
            	            {
            	        	case 1:
            	        	    // .//LexWhenPred.g:0:0: LTERM
            	        	    {
            	        	        LTERM5 = (pANTLR3_COMMON_TOKEN) MATCHT(LTERM, &FOLLOW_LTERM_in_sourceElements130); 
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesourceElementsEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        } 
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_LTERM; stream_LTERM->add(stream_LTERM, LTERM5, NULL); }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop3;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop3: ; /* Jump out to here if this rule does not match */

            	        FOLLOWPUSH(FOLLOW_sourceElement_in_sourceElements133);
            	        sourceElement6=sourceElement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesourceElementsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_sourceElement; stream_sourceElement->add(stream_sourceElement, sourceElement6.tree, NULL); }

            	    }
            	    break;

            	default:
            	    goto loop4;	/* break out of the loop */
            	    break;
                }
            }
            loop4: ; /* Jump out to here if this rule does not match */


             
            /* AST REWRITE
             * elements          : sourceElement
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 40:42: -> ( sourceElement )+
            	{
            	    if ((stream_sourceElement == NULL || !stream_sourceElement->hasNext(stream_sourceElement))  )
            	    {
            	        CONSTRUCTEX();
            	        EXCEPTION->type         = ANTLR3_REWRITE_EARLY_EXCEPTION;
            	        EXCEPTION->name         = (void *)ANTLR3_REWRITE_EARLY_EXCEPTION_NAME;
            	    }
            	    else
            	    {
            	    	while ( (stream_sourceElement->hasNext(stream_sourceElement))  ) {
            	    		ADAPTOR->addChild(ADAPTOR, root_0, stream_sourceElement == NULL ? NULL : stream_sourceElement->nextTree(stream_sourceElement));

            	    	}
            	    	stream_sourceElement->reset(stream_sourceElement);

            	    }
            	}

            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesourceElementsEx; /* Prevent compiler warnings */
    rulesourceElementsEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_LTERM != NULL) stream_LTERM->free(stream_LTERM);
        if (stream_sourceElement != NULL) stream_sourceElement->free(stream_sourceElement);
    }

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
    }

    if ( BACKTRACKING>0 ) { MEMOIZE(2, sourceElements_StartIndex); }
    return retval;
}
/* $ANTLR end sourceElements */

/** 
 * $ANTLR start sourceElement
 * .//LexWhenPred.g:43:1: sourceElement : whenPredStatement -> whenPredStatement ;
 */
static LexWhenPredParser_sourceElement_return
sourceElement(pLexWhenPredParser ctx)
{   
    LexWhenPredParser_sourceElement_return retval;
    ANTLR3_UINT32 sourceElement_StartIndex;
    pANTLR3_BASE_TREE root_0;

    LexWhenPredParser_whenPredStatement_return whenPredStatement7;
    #undef	RETURN_TYPE_whenPredStatement7
    #define	RETURN_TYPE_whenPredStatement7 LexWhenPredParser_whenPredStatement_return

    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_whenPredStatement;
    /* Initialize rule variables
     */
    sourceElement_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(3)) )
    {
    	retval.start = 0;

        return retval; 
    }
    whenPredStatement7.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;


    stream_whenPredStatement   = NULL;
    #define CREATE_stream_whenPredStatement  if (stream_whenPredStatement == NULL) {stream_whenPredStatement = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule whenPredStatement"); }

    retval.tree  = NULL;
    {
        // .//LexWhenPred.g:44:9: ( whenPredStatement -> whenPredStatement )
        // .//LexWhenPred.g:44:11: whenPredStatement
        {
            FOLLOWPUSH(FOLLOW_whenPredStatement_in_sourceElement161);
            whenPredStatement7=whenPredStatement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesourceElementEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) { CREATE_stream_whenPredStatement; stream_whenPredStatement->add(stream_whenPredStatement, whenPredStatement7.tree, NULL); }

             
            /* AST REWRITE
             * elements          : whenPredStatement
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 44:29: -> whenPredStatement
            	{
            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_whenPredStatement == NULL ? NULL : stream_whenPredStatement->nextTree(stream_whenPredStatement));

            	}

            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesourceElementEx; /* Prevent compiler warnings */
    rulesourceElementEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_whenPredStatement != NULL) stream_whenPredStatement->free(stream_whenPredStatement);
    }

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
    }

    if ( BACKTRACKING>0 ) { MEMOIZE(3, sourceElement_StartIndex); }
    return retval;
}
/* $ANTLR end sourceElement */

/** 
 * $ANTLR start whenPredStatement
 * .//LexWhenPred.g:49:1: whenPredStatement : ( literal )* s1= Identifier ( ( separator )+ s2= Identifier )* ( separator )* ( literal )* ( separator )* -> ^( WHEN_PRED_BLOCK $s1 ( $s2)* ) ;
 */
static LexWhenPredParser_whenPredStatement_return
whenPredStatement(pLexWhenPredParser ctx)
{   
    LexWhenPredParser_whenPredStatement_return retval;
    ANTLR3_UINT32 whenPredStatement_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    s1;
    pANTLR3_COMMON_TOKEN    s2;
    LexWhenPredParser_literal_return literal8;
    #undef	RETURN_TYPE_literal8
    #define	RETURN_TYPE_literal8 LexWhenPredParser_literal_return

    LexWhenPredParser_separator_return separator9;
    #undef	RETURN_TYPE_separator9
    #define	RETURN_TYPE_separator9 LexWhenPredParser_separator_return

    LexWhenPredParser_separator_return separator10;
    #undef	RETURN_TYPE_separator10
    #define	RETURN_TYPE_separator10 LexWhenPredParser_separator_return

    LexWhenPredParser_literal_return literal11;
    #undef	RETURN_TYPE_literal11
    #define	RETURN_TYPE_literal11 LexWhenPredParser_literal_return

    LexWhenPredParser_separator_return separator12;
    #undef	RETURN_TYPE_separator12
    #define	RETURN_TYPE_separator12 LexWhenPredParser_separator_return

    pANTLR3_BASE_TREE s1_tree;
    pANTLR3_BASE_TREE s2_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_Identifier;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_separator;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_literal;
    /* Initialize rule variables
     */
    whenPredStatement_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(4)) )
    {
    	retval.start = 0;

        return retval; 
    }
    s1       = NULL;
    s2       = NULL;
    literal8.tree = NULL;

    separator9.tree = NULL;

    separator10.tree = NULL;

    literal11.tree = NULL;

    separator12.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    s1_tree   = NULL;
    s2_tree   = NULL;

    stream_Identifier   = NULL;
    #define CREATE_stream_Identifier  if (stream_Identifier == NULL) {stream_Identifier = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token Identifier"); } 
    stream_separator   = NULL;
    #define CREATE_stream_separator  if (stream_separator == NULL) {stream_separator = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule separator"); }
    stream_literal   = NULL;
    #define CREATE_stream_literal  if (stream_literal == NULL) {stream_literal = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule literal"); }

    retval.tree  = NULL;
    {
        // .//LexWhenPred.g:50:9: ( ( literal )* s1= Identifier ( ( separator )+ s2= Identifier )* ( separator )* ( literal )* ( separator )* -> ^( WHEN_PRED_BLOCK $s1 ( $s2)* ) )
        // .//LexWhenPred.g:50:11: ( literal )* s1= Identifier ( ( separator )+ s2= Identifier )* ( separator )* ( literal )* ( separator )*
        {

            // .//LexWhenPred.g:50:11: ( literal )*

            for (;;)
            {
                int alt5=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA5_0 = LA(1);
                    if ( (((LA5_0 >= StringLiteral) && (LA5_0 <= NumericLiteral))) ) 
                    {
                        alt5=1;
                    }

                }
                switch (alt5) 
                {
            	case 1:
            	    // .//LexWhenPred.g:0:0: literal
            	    {
            	        FOLLOWPUSH(FOLLOW_literal_in_whenPredStatement186);
            	        literal8=literal(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulewhenPredStatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_literal; stream_literal->add(stream_literal, literal8.tree, NULL); }

            	    }
            	    break;

            	default:
            	    goto loop5;	/* break out of the loop */
            	    break;
                }
            }
            loop5: ; /* Jump out to here if this rule does not match */

            s1 = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_whenPredStatement191); 
            if  (HASEXCEPTION())
            {
                goto rulewhenPredStatementEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, s1, NULL); }


            // .//LexWhenPred.g:50:34: ( ( separator )+ s2= Identifier )*

            for (;;)
            {
                int alt7=2;
                alt7 = cdfa7.predict(ctx, RECOGNIZER, ISTREAM, &cdfa7);
                if  (HASEXCEPTION())
                {
                    goto rulewhenPredStatementEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                switch (alt7) 
                {
            	case 1:
            	    // .//LexWhenPred.g:50:36: ( separator )+ s2= Identifier
            	    {
            	        // .//LexWhenPred.g:50:36: ( separator )+
            	        {
            	            int cnt6=0;

            	            for (;;)
            	            {
            	                int alt6=2;
            	        	{
            	        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	        	    */
            	        	    int LA6_0 = LA(1);
            	        	    if ( (LA6_0 == LTERM || ((LA6_0 >= 33) && (LA6_0 <= 51))) ) 
            	        	    {
            	        	        alt6=1;
            	        	    }

            	        	}
            	        	switch (alt6) 
            	        	{
            	        	    case 1:
            	        	        // .//LexWhenPred.g:0:0: separator
            	        	        {
            	        	            FOLLOWPUSH(FOLLOW_separator_in_whenPredStatement195);
            	        	            separator9=separator(ctx);

            	        	            FOLLOWPOP();
            	        	            if  (HASEXCEPTION())
            	        	            {
            	        	                goto rulewhenPredStatementEx;
            	        	            }
            	        	            if (HASFAILED())
            	        	            {
            	        	                return retval;
            	        	            }
            	        	            if ( BACKTRACKING==0 ) { CREATE_stream_separator; stream_separator->add(stream_separator, separator9.tree, NULL); }

            	        	        }
            	        	        break;

            	        	    default:
            	        	    
            	        		if ( cnt6 >= 1 )
            	        		{
            	        		    goto loop6;
            	        		}
            	        		if (BACKTRACKING>0)
            	        		{
            	        		    FAILEDFLAG = ANTLR3_TRUE; 
            	        		    return retval;
            	        		}
            	        		/* mismatchedSetEx()
            	        		 */
            	        		CONSTRUCTEX();
            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	        		goto rulewhenPredStatementEx;
            	        	}
            	        	cnt6++;
            	            }
            	            loop6: ;	/* Jump to here if this rule does not match */
            	        }
            	        s2 = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_whenPredStatement201); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulewhenPredStatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_Identifier; stream_Identifier->add(stream_Identifier, s2, NULL); }


            	    }
            	    break;

            	default:
            	    goto loop7;	/* break out of the loop */
            	    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */


            // .//LexWhenPred.g:50:64: ( separator )*

            for (;;)
            {
                int alt8=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA8_0 = LA(1);
                    if ( (LA8_0 == LTERM) ) 
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA8_2 = LA(2);
                            if ( (synpred8_LexWhenPred(ctx)) ) 
                            {
                                alt8=1;
                            }

                        }
                    }
                    else if ( (((LA8_0 >= 33) && (LA8_0 <= 51))) ) 
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA8_3 = LA(2);
                            if ( (synpred8_LexWhenPred(ctx)) ) 
                            {
                                alt8=1;
                            }

                        }
                    }

                }
                switch (alt8) 
                {
            	case 1:
            	    // .//LexWhenPred.g:0:0: separator
            	    {
            	        FOLLOWPUSH(FOLLOW_separator_in_whenPredStatement205);
            	        separator10=separator(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulewhenPredStatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_separator; stream_separator->add(stream_separator, separator10.tree, NULL); }

            	    }
            	    break;

            	default:
            	    goto loop8;	/* break out of the loop */
            	    break;
                }
            }
            loop8: ; /* Jump out to here if this rule does not match */


            // .//LexWhenPred.g:50:75: ( literal )*

            for (;;)
            {
                int alt9=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA9_0 = LA(1);
                    if ( (((LA9_0 >= StringLiteral) && (LA9_0 <= NumericLiteral))) ) 
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA9_2 = LA(2);
                            if ( (synpred9_LexWhenPred(ctx)) ) 
                            {
                                alt9=1;
                            }

                        }
                    }

                }
                switch (alt9) 
                {
            	case 1:
            	    // .//LexWhenPred.g:0:0: literal
            	    {
            	        FOLLOWPUSH(FOLLOW_literal_in_whenPredStatement208);
            	        literal11=literal(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulewhenPredStatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_literal; stream_literal->add(stream_literal, literal11.tree, NULL); }

            	    }
            	    break;

            	default:
            	    goto loop9;	/* break out of the loop */
            	    break;
                }
            }
            loop9: ; /* Jump out to here if this rule does not match */


            // .//LexWhenPred.g:50:84: ( separator )*

            for (;;)
            {
                int alt10=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA10_0 = LA(1);
                    if ( (LA10_0 == LTERM) ) 
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA10_1 = LA(2);
                            if ( (synpred10_LexWhenPred(ctx)) ) 
                            {
                                alt10=1;
                            }

                        }
                    }
                    else if ( (((LA10_0 >= 33) && (LA10_0 <= 51))) ) 
                    {
                        alt10=1;
                    }

                }
                switch (alt10) 
                {
            	case 1:
            	    // .//LexWhenPred.g:0:0: separator
            	    {
            	        FOLLOWPUSH(FOLLOW_separator_in_whenPredStatement211);
            	        separator12=separator(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulewhenPredStatementEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_separator; stream_separator->add(stream_separator, separator12.tree, NULL); }

            	    }
            	    break;

            	default:
            	    goto loop10;	/* break out of the loop */
            	    break;
                }
            }
            loop10: ; /* Jump out to here if this rule does not match */


             
            /* AST REWRITE
             * elements          : s2, s1
             * token labels      : s2, s1
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_s2;
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_s1;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_s2=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token s2", s2);
            	stream_s1=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token s1", s1);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 50:98: -> ^( WHEN_PRED_BLOCK $s1 ( $s2)* )
            	{
            	    // .//LexWhenPred.g:50:101: ^( WHEN_PRED_BLOCK $s1 ( $s2)* )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WHEN_PRED_BLOCK, (pANTLR3_UINT8)"WHEN_PRED_BLOCK"), root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_s1 == NULL ? NULL : stream_s1->nextNode(stream_s1));
            	        // .//LexWhenPred.g:50:123: ( $s2)*
            	        {
            	        	while ( (stream_s2 != NULL && stream_s2->hasNext(stream_s2))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_s2 == NULL ? NULL : stream_s2->nextNode(stream_s2));

            	        	}
            	        	if (stream_s2 != NULL) stream_s2->reset(stream_s2);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_s2 != NULL) stream_s2->free(stream_s2); 
            	if (stream_s1 != NULL) stream_s1->free(stream_s1); 
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulewhenPredStatementEx; /* Prevent compiler warnings */
    rulewhenPredStatementEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_Identifier != NULL) stream_Identifier->free(stream_Identifier);
        if (stream_separator != NULL) stream_separator->free(stream_separator);
        if (stream_literal != NULL) stream_literal->free(stream_literal);
    }

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
    }

    if ( BACKTRACKING>0 ) { MEMOIZE(4, whenPredStatement_StartIndex); }
    return retval;
}
/* $ANTLR end whenPredStatement */

/** 
 * $ANTLR start literal
 * .//LexWhenPred.g:55:1: literal : ( StringLiteral | NumericLiteral );
 */
static LexWhenPredParser_literal_return
literal(pLexWhenPredParser ctx)
{   
    LexWhenPredParser_literal_return retval;
    ANTLR3_UINT32 literal_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set13;

    pANTLR3_BASE_TREE set13_tree;

    /* Initialize rule variables
     */
    literal_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(5)) )
    {
    	retval.start = 0;

        return retval; 
    }
    set13       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    set13_tree   = NULL;


    retval.tree  = NULL;
    {
        // .//LexWhenPred.g:56:9: ( StringLiteral | NumericLiteral )
        // .//LexWhenPred.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            set13=(pANTLR3_COMMON_TOKEN)LT(1);
            if ( ((LA(1) >= StringLiteral) && (LA(1) <= NumericLiteral)) )
            {
                CONSUME();
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set13)));
                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE; 
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_literal0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_literal0);    goto ruleliteralEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleliteralEx; /* Prevent compiler warnings */
    ruleliteralEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
    }

    if ( BACKTRACKING>0 ) { MEMOIZE(5, literal_StartIndex); }
    return retval;
}
/* $ANTLR end literal */

/** 
 * $ANTLR start separator
 * .//LexWhenPred.g:60:1: separator : ( LTERM | '+' | '-' | '(' | ')' | '[' | ']' | '!' | '=' | '*' | '/' | '>' | '<' | '%' | '&' | '|' | '^' | '{' | '}' | ';' );
 */
static LexWhenPredParser_separator_return
separator(pLexWhenPredParser ctx)
{   
    LexWhenPredParser_separator_return retval;
    ANTLR3_UINT32 separator_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set14;

    pANTLR3_BASE_TREE set14_tree;

    /* Initialize rule variables
     */
    separator_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(6)) )
    {
    	retval.start = 0;

        return retval; 
    }
    set14       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    set14_tree   = NULL;


    retval.tree  = NULL;
    {
        // .//LexWhenPred.g:61:9: ( LTERM | '+' | '-' | '(' | ')' | '[' | ']' | '!' | '=' | '*' | '/' | '>' | '<' | '%' | '&' | '|' | '^' | '{' | '}' | ';' )
        // .//LexWhenPred.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            set14=(pANTLR3_COMMON_TOKEN)LT(1);
            if ( LA(1) == LTERM || ((LA(1) >= 33) && (LA(1) <= 51)) )
            {
                CONSUME();
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set14)));
                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE; 
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_separator0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_separator0);    goto ruleseparatorEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleseparatorEx; /* Prevent compiler warnings */
    ruleseparatorEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
    }

    if ( BACKTRACKING>0 ) { MEMOIZE(6, separator_StartIndex); }
    return retval;
}
/* $ANTLR end separator */

// $ANTLR start synpred7_LexWhenPred
static void synpred7_LexWhenPred_fragment(pLexWhenPredParser ctx ) 
{
	pANTLR3_COMMON_TOKEN    s2;

	s2       = NULL;

    // .//LexWhenPred.g:50:36: ( ( separator )+ s2= Identifier )
    // .//LexWhenPred.g:50:36: ( separator )+ s2= Identifier
    {
        // .//LexWhenPred.g:50:36: ( separator )+
        {
            int cnt12=0;

            for (;;)
            {
                int alt12=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA12_0 = LA(1);
        	    if ( (LA12_0 == LTERM || ((LA12_0 >= 33) && (LA12_0 <= 51))) ) 
        	    {
        	        alt12=1;
        	    }

        	}
        	switch (alt12) 
        	{
        	    case 1:
        	        // .//LexWhenPred.g:0:0: separator
        	        {
        	            FOLLOWPUSH(FOLLOW_separator_in_synpred7_LexWhenPred195);
        	            separator(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulesynpred7_LexWhenPredEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }
        	        break;

        	    default:
        	    
        		if ( cnt12 >= 1 )
        		{
        		    goto loop12;
        		}
        		if (BACKTRACKING>0)
        		{
        		    FAILEDFLAG = ANTLR3_TRUE; 
        		    return ;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto rulesynpred7_LexWhenPredEx;
        	}
        	cnt12++;
            }
            loop12: ;	/* Jump to here if this rule does not match */
        }
        s2 = (pANTLR3_COMMON_TOKEN) MATCHT(Identifier, &FOLLOW_Identifier_in_synpred7_LexWhenPred201); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred7_LexWhenPredEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred7_LexWhenPredEx; /* Prevent compiler warnings */
rulesynpred7_LexWhenPredEx: ;

}
// $ANTLR end synpred7_LexWhenPred

// $ANTLR start synpred8_LexWhenPred
static void synpred8_LexWhenPred_fragment(pLexWhenPredParser ctx ) 
{
    // .//LexWhenPred.g:50:64: ( separator )
    // .//LexWhenPred.g:50:64: separator
    {
        FOLLOWPUSH(FOLLOW_separator_in_synpred8_LexWhenPred205);
        separator(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred8_LexWhenPredEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred8_LexWhenPredEx; /* Prevent compiler warnings */
rulesynpred8_LexWhenPredEx: ;

}
// $ANTLR end synpred8_LexWhenPred

// $ANTLR start synpred9_LexWhenPred
static void synpred9_LexWhenPred_fragment(pLexWhenPredParser ctx ) 
{
    // .//LexWhenPred.g:50:75: ( literal )
    // .//LexWhenPred.g:50:75: literal
    {
        FOLLOWPUSH(FOLLOW_literal_in_synpred9_LexWhenPred208);
        literal(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred9_LexWhenPredEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred9_LexWhenPredEx; /* Prevent compiler warnings */
rulesynpred9_LexWhenPredEx: ;

}
// $ANTLR end synpred9_LexWhenPred

// $ANTLR start synpred10_LexWhenPred
static void synpred10_LexWhenPred_fragment(pLexWhenPredParser ctx ) 
{
    // .//LexWhenPred.g:50:84: ( separator )
    // .//LexWhenPred.g:50:84: separator
    {
        FOLLOWPUSH(FOLLOW_separator_in_synpred10_LexWhenPred211);
        separator(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred10_LexWhenPredEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred10_LexWhenPredEx; /* Prevent compiler warnings */
rulesynpred10_LexWhenPredEx: ;

}
// $ANTLR end synpred10_LexWhenPred
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
static ANTLR3_BOOLEAN synpred7_LexWhenPred(pLexWhenPredParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred7_LexWhenPred_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred8_LexWhenPred(pLexWhenPredParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred8_LexWhenPred_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred10_LexWhenPred(pLexWhenPredParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred10_LexWhenPred_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred9_LexWhenPred(pLexWhenPredParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred9_LexWhenPred_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
