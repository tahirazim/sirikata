libproxyobject/include/sirikata/proxyobject/ProxyObject.hpp:/*  Sirikata Utilities -- Sirikata Listener Pattern
libproxyobject/include/sirikata/proxyobject/ProxyObject.hpp:                toWorld(ppop->globalLocation(timeStamp));
libproxyobject/include/sirikata/proxyobject/ProxyManager.hpp:/*  Sirikata Object Host -- Proxy Creation and Destruction manager
libproxyobject/include/sirikata/proxyobject/ProxyManager.hpp:    ///Removes from internal ProxyObject map, calls destruction listeners, and calls newObj->destroy().
libproxyobject/include/sirikata/proxyobject/OverlayPosition.hpp:/*  Sirikata Object Host -- Overlay Position
libproxyobject/include/sirikata/proxyobject/OverlayPosition.hpp:* Describes the position of a viewport-overlay in relative/absolute metrics.
libproxyobject/include/sirikata/proxyobject/OverlayPosition.hpp:	* Creates a relatively-positioned OverlayPosition object.
libproxyobject/include/sirikata/proxyobject/OverlayPosition.hpp:	* Creates an absolutely-positioned OverlayPosition object.
libproxyobject/include/sirikata/proxyobject/OverlayPosition.hpp:	* Creates an empty OverlayPosition object (defaults to top-left corner).
libproxyobject/include/sirikata/proxyobject/models/MeshObject.hpp:/*  Sirikata liboh -- MeshObject Model Interface (Bridge Pattern)
libproxyobject/include/sirikata/proxyobject/CameraListener.hpp:/*  Sirikata Utilities -- Sirikata Listener Pattern
libproxyobject/include/sirikata/proxyobject/MeshListener.hpp:        Disabled = 0,               /// non-active, remove from physics
libproxyobject/include/sirikata/proxyobject/MeshListener.hpp:        DynamicBox,                 /// fully physical -- collision & dynamics
libproxyobject/include/sirikata/proxyobject/TimeSteppedSimulation.hpp:/*  Sirikata Utilities -- Sirikata Listener Pattern
libproxyobject/include/sirikata/proxyobject/WebViewListener.hpp:/*  Sirikata Object Host -- WebView Listener
libproxyobject/include/sirikata/proxyobject/TimeOffsetManager.hpp:/*  Sirikata Utilities -- Sirikata Listener Pattern
libproxyobject/include/sirikata/proxyobject/ModelsSystemFactory.hpp:/*  Sirikata Object Host -- Models System Factory Interface
libproxyobject/include/sirikata/proxyobject/TimeSteppedQueryableSimulation.hpp:/*  Sirikata Utilities -- Sirikata Listener Pattern
libproxyobject/include/sirikata/proxyobject/Platform.hpp:/*  Sirikata Object Host -- Platform Dependent Definitions
libproxyobject/include/sirikata/proxyobject/Platform.hpp: *  Copyright (c) 2009, Ewen Cheslack-Postava and Daniel Reiter Horn
libproxyobject/include/sirikata/proxyobject/SimulationFactory.hpp:/*  Sirikata Object Host -- Proxy Creation and Destruction manager
libproxyobject/include/sirikata/proxyobject/LightInfo.hpp:/*  Sirikata Utilities -- Sirikata Listener Pattern
libproxyobject/include/sirikata/proxyobject/ProxyWebViewObject.hpp:/*  Sirikata Object Host -- Proxy WebView Object
libproxyobject/include/sirikata/proxyobject/ModelsSystem.hpp:/*  Sirikata Object Host -- Models Creation and Destruction system
libproxyobject/include/sirikata/proxyobject/ProxyCameraObject.hpp:/*  Sirikata Utilities -- Sirikata Listener Pattern
libproxyobject/include/sirikata/proxyobject/VWObject.hpp:/*  Sirikata liboh -- Object Host
libproxyobject/include/sirikata/proxyobject/VWObject.hpp: *   In general any camera-like VWObject will be a ProxyManager for ProxyObjects it makes in a space
libproxyobject/plugins/ogre/InputBindingEvent.cpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/InputBindingEvent.cpp: *  Copyright (c) 2009, Ewen Cheslack-Postava
libproxyobject/plugins/ogre/Entity.hpp:        return fromOgre(mSceneNode->getPosition(), getScene()->getOffset());
libproxyobject/plugins/ogre/Entity.hpp:        return fromOgre(mSceneNode->getOrientation());
libproxyobject/plugins/ogre/Entity.hpp:      mSceneNode->showBoundingBox(selected);
libproxyobject/plugins/ogre/Entity.hpp:        return mProxy->getObjectReference();
libproxyobject/plugins/ogre/DragActions.cpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/DragActions.cpp:            mDevice->pushRelativeMode();
libproxyobject/plugins/ogre/DragActions.cpp:            mDevice->popRelativeMode();
libproxyobject/plugins/ogre/DragActions.cpp:    return iter->second;
libproxyobject/plugins/ogre/DragActions.cpp:    SILOG(input,info,"FOV Y Radians: "<<cam->getOgreCamera()->getFOVy().valueRadians()<<"; aspect = "<<cam->getOgreCamera()->getAspectRatio());
libproxyobject/plugins/ogre/DragActions.cpp:    xRadians = cam->getOgreCamera()->getFOVy().valueRadians() * cam->getOgreCamera()->getAspectRatio() * deltaXPct;
libproxyobject/plugins/ogre/DragActions.cpp:    yRadians = cam->getOgreCamera()->getFOVy().valueRadians() * deltaYPct;
libproxyobject/plugins/ogre/DragActions.cpp:    xRadian = sin(cam->getOgreCamera()->getFOVy().valueRadians()*.5) * cam->getOgreCamera()->getAspectRatio() * xPixel;
libproxyobject/plugins/ogre/DragActions.cpp:    yRadian = sin(cam->getOgreCamera()->getFOVy().valueRadians()*.5) * yPixel;
libproxyobject/plugins/ogre/DragActions.cpp:    return Vector3f(-orient.zAxis()*cos(cam->getOgreCamera()->getFOVy().valueRadians()*.5) +
libproxyobject/plugins/ogre/DragActions.cpp:    Time now(camera->getScene()->getLocalTimeOffset()->now(camera->getProxy()));
libproxyobject/plugins/ogre/DragActions.cpp:    Quaternion orient(camera->getProxy().globalLocation(now).getOrientation());
libproxyobject/plugins/ogre/DragActions.cpp:    Quaternion dragStart (camera->getProxy().extrapolateLocation(now).getOrientation());
libproxyobject/plugins/ogre/DragActions.cpp:    Quaternion dvorient = Quaternion(dhorient * orient * Vector3f(1,0,0),-radianY);
libproxyobject/plugins/ogre/DragActions.cpp:    Location location = camera->getProxy().extrapolateLocation(now);
libproxyobject/plugins/ogre/DragActions.cpp:    camera->getProxy().resetLocation(now, location);
libproxyobject/plugins/ogre/DragActions.cpp:        Time now(camera->getScene()->getLocalTimeOffset()->now(camera->getProxy()));
libproxyobject/plugins/ogre/DragActions.cpp:        Quaternion orient(camera->getProxy().globalLocation(now).getOrientation());
libproxyobject/plugins/ogre/DragActions.cpp:        Location location (camera->getProxy().extrapolateLocation(now));
libproxyobject/plugins/ogre/DragActions.cpp:        camera->getProxy().resetLocation(now, location);
libproxyobject/plugins/ogre/DragActions.cpp:        Time now(mParent->getLocalTimeOffset()->now(camera->getProxy()));
libproxyobject/plugins/ogre/DragActions.cpp:        Location cameraLoc = camera->getProxy().globalLocation(now);
libproxyobject/plugins/ogre/DragActions.cpp:        Vector3f cameraAxis = -cameraLoc.getOrientation().zAxis();
libproxyobject/plugins/ogre/DragActions.cpp:            mPositions.push_back(obj->extrapolateLocation(now).getPosition());
libproxyobject/plugins/ogre/DragActions.cpp:            Vector3d deltaPosition (obj->globalLocation(now).getPosition() - cameraLoc.getPosition());
libproxyobject/plugins/ogre/DragActions.cpp:        std::cout << "MOVE: mX = "<<ev->mX<<"; mY = "<<ev->mY<<". mXStart = "<< ev->mXStart<<"; mYStart = "<<ev->mYStart<<std::endl;
libproxyobject/plugins/ogre/DragActions.cpp:        Time now(mParent->getLocalTimeOffset()->now(camera->getProxy()));
libproxyobject/plugins/ogre/DragActions.cpp:        Location cameraLoc = camera->getProxy().globalLocation(now);
libproxyobject/plugins/ogre/DragActions.cpp:        Vector3f cameraAxis = -cameraLoc.getOrientation().zAxis();
libproxyobject/plugins/ogre/DragActions.cpp:        if (mParent->getInputManager()->isModifierDown(Input::MOD_ALT)) sensitivity = 5.0;
libproxyobject/plugins/ogre/DragActions.cpp:        if (mParent->getInputManager()->isModifierDown(Input::MOD_SHIFT &&
libproxyobject/plugins/ogre/DragActions.cpp:                mParent->getInputManager()->isModifierDown(Input::MOD_CTRL))) {
libproxyobject/plugins/ogre/DragActions.cpp:            toMove.y = ev->deltaY()*sensitivity;
libproxyobject/plugins/ogre/DragActions.cpp:        else if (mParent->getInputManager()->isModifierDown(Input::MOD_SHIFT)) {
libproxyobject/plugins/ogre/DragActions.cpp:            if (cameraAxis.z > 0) sensitivity *=-1;
libproxyobject/plugins/ogre/DragActions.cpp:            toMove.x = ev->deltaX()*sensitivity;
libproxyobject/plugins/ogre/DragActions.cpp:        else if (mParent->getInputManager()->isModifierDown(Input::MOD_CTRL)) {
libproxyobject/plugins/ogre/DragActions.cpp:            if (cameraAxis.x < 0) sensitivity *=-1;
libproxyobject/plugins/ogre/DragActions.cpp:            toMove.z = ev->deltaX()*sensitivity;
libproxyobject/plugins/ogre/DragActions.cpp:            Vector3d startAxis (pixelToDirection(camera, cameraLoc.getOrientation(), ev->mXStart, ev->mYStart));
libproxyobject/plugins/ogre/DragActions.cpp:            Vector3d endAxis (pixelToDirection(camera, cameraLoc.getOrientation(), ev->mX, ev->mY));
libproxyobject/plugins/ogre/DragActions.cpp:            toMove = (end - start);
libproxyobject/plugins/ogre/DragActions.cpp:            if (toMove.length() > 10*mParent->getInputManager()->mWorldScale->as<float>()) {
libproxyobject/plugins/ogre/DragActions.cpp:                toMove *= (10*mParent->getInputManager()->mWorldScale->as<float>()/toMove.length());
libproxyobject/plugins/ogre/DragActions.cpp:                Location toSet (obj->extrapolateLocation(now));
libproxyobject/plugins/ogre/DragActions.cpp:                obj->setLocation(now, toSet);
libproxyobject/plugins/ogre/DragActions.cpp:        Time now(mParent->getLocalTimeOffset()->now(camera->getProxy()));
libproxyobject/plugins/ogre/DragActions.cpp:                Location currentLoc = obj->extrapolateLocation(now);
libproxyobject/plugins/ogre/DragActions.cpp:        Time now(mParent->getLocalTimeOffset()->now(camera->getProxy()));
libproxyobject/plugins/ogre/DragActions.cpp:        Location cameraLoc = camera->getProxy().globalLocation(now);
libproxyobject/plugins/ogre/DragActions.cpp:        Vector3f cameraAxis = -cameraLoc.getOrientation().zAxis();
libproxyobject/plugins/ogre/DragActions.cpp:            Location loc (ent->extrapolateLocation(now));
libproxyobject/plugins/ogre/DragActions.cpp:        if (mParent->getInputManager()->isModifierDown(Input::MOD_ALT)) {
libproxyobject/plugins/ogre/DragActions.cpp:        if (mParent->getInputManager()->isModifierDown(ctlX)) {
libproxyobject/plugins/ogre/DragActions.cpp:            if (mParent->getInputManager()->isModifierDown(ctlZ)) {
libproxyobject/plugins/ogre/DragActions.cpp:                radianZ = 3.14159 * 2 * -ev->deltaX() * sensitivity;
libproxyobject/plugins/ogre/DragActions.cpp:                if (cameraAxis.z > 0) sensitivity *=-1;
libproxyobject/plugins/ogre/DragActions.cpp:            radianX = 3.14159 * 2 * -ev->deltaY() * sensitivity;
libproxyobject/plugins/ogre/DragActions.cpp:        else if (mParent->getInputManager()->isModifierDown(ctlZ)) {
libproxyobject/plugins/ogre/DragActions.cpp:            if (cameraAxis.x <= 0) sensitivity *=-1;
libproxyobject/plugins/ogre/DragActions.cpp:            radianZ = 3.14159 * 2 * -ev->deltaY() * sensitivity;
libproxyobject/plugins/ogre/DragActions.cpp:            radianY = 3.14159 * 2 * ev->deltaX() * sensitivity;
libproxyobject/plugins/ogre/DragActions.cpp:            Location loc (ent->extrapolateLocation(now));
libproxyobject/plugins/ogre/DragActions.cpp:            Vector3d localTrans = mOriginalPosition[i] - avgPos;
libproxyobject/plugins/ogre/DragActions.cpp:            ent->resetLocation(now, loc);
libproxyobject/plugins/ogre/DragActions.cpp:            : RelativeDrag(info.ev->getDevice()),
libproxyobject/plugins/ogre/DragActions.cpp:        Time now(mParent->getLocalTimeOffset()->now(camera->getProxy()));
libproxyobject/plugins/ogre/DragActions.cpp:            Location currentLoc = obj->extrapolateLocation(now);
libproxyobject/plugins/ogre/DragActions.cpp:        dragMultiplier = mParent->getInputManager()->mDragMultiplier->as<float>();
libproxyobject/plugins/ogre/DragActions.cpp:        Time now(mParent->getLocalTimeOffset()->now(camera->getProxy()));
libproxyobject/plugins/ogre/DragActions.cpp:        if (ev->deltaLastY() != 0) {
libproxyobject/plugins/ogre/DragActions.cpp:            float scaleamt = exp(dragMultiplier*ev->deltaLastY());
libproxyobject/plugins/ogre/DragActions.cpp:                Location loc (ent->extrapolateLocation(now));
libproxyobject/plugins/ogre/DragActions.cpp:                Location loc (ent->extrapolateLocation(now));
libproxyobject/plugins/ogre/DragActions.cpp:                Vector3d localTrans = mOriginalPosition[i] - avgPos;
libproxyobject/plugins/ogre/DragActions.cpp:                ent->resetLocation(now, loc);
libproxyobject/plugins/ogre/DragActions.cpp:                    meshptr->setScale(meshptr->getScale() * scaleamt);
libproxyobject/plugins/ogre/DragActions.cpp:        if (ev->deltaLastX() != 0) {
libproxyobject/plugins/ogre/DragActions.cpp:            //rotateXZ(AxisValue::fromCentered(ev->deltaLastX()));
libproxyobject/plugins/ogre/DragActions.cpp:            //rotateCamera(mParent->mPrimaryCamera, ev->deltaLastX() * AXIS_TO_RADIANS, 0);
libproxyobject/plugins/ogre/DragActions.cpp:    RotateCameraDrag(const DragStartInfo &info): RelativeDrag(info.ev->getDevice()) {
libproxyobject/plugins/ogre/DragActions.cpp:        pixelToRadians(camera, 2*mouseev->deltaLastX(), 2*mouseev->deltaLastY(), radianX, radianY);
libproxyobject/plugins/ogre/DragActions.cpp:        Time now(mParent->getLocalTimeOffset()->now(camera->getProxy()));
libproxyobject/plugins/ogre/DragActions.cpp:        Location cameraLoc = camera->getProxy().globalLocation(now);
libproxyobject/plugins/ogre/DragActions.cpp:            pixelToDirection(camera, cameraLoc.getOrientation(), info.ev->mXStart, info.ev->mYStart));
libproxyobject/plugins/ogre/DragActions.cpp:        mStartPan = camera->getProxy().extrapolateLocation(now).getPosition();
libproxyobject/plugins/ogre/DragActions.cpp:		if (mParent->getInputManager()->isModifierDown(Input::MOD_CTRL)) {
libproxyobject/plugins/ogre/DragActions.cpp:			float WORLD_SCALE = mParent->getInputManager()->mWorldScale->as<float>();
libproxyobject/plugins/ogre/DragActions.cpp:		} else if (!mParent->getInputManager()->isModifierDown(Input::MOD_SHIFT) &&
libproxyobject/plugins/ogre/DragActions.cpp:				   info.sys->rayTrace(cameraLoc.getPosition(), toMove, hitCount, distance, normal, subent)) {
libproxyobject/plugins/ogre/DragActions.cpp:            mPanDistance = (totalPosition - cameraLoc.getPosition()).length();
libproxyobject/plugins/ogre/DragActions.cpp:            float WORLD_SCALE = mParent->getInputManager()->mWorldScale->as<float>();
libproxyobject/plugins/ogre/DragActions.cpp:        Time now(mParent->getLocalTimeOffset()->now(camera->getProxy()));
libproxyobject/plugins/ogre/DragActions.cpp:        Location cameraLoc = camera->getProxy().globalLocation(now);
libproxyobject/plugins/ogre/DragActions.cpp:            pixelToRadians(camera, ev->deltaX(), ev->deltaY(), radianX, radianY);
libproxyobject/plugins/ogre/DragActions.cpp:            panCamera(camera, mStartPan, Vector3d(-radianX*mPanDistance, -radianY*mPanDistance, 0));
libproxyobject/plugins/ogre/DragActions.cpp:        dev->getAxis(Input::AXIS_CURSORX).getCentered(),
libproxyobject/plugins/ogre/DragActions.cpp:        dev->getAxis(Input::AXIS_CURSORY).getCentered()
libproxyobject/plugins/ogre/DragActions.cpp:    Time now(parent->getLocalTimeOffset()->now(camera->getProxy()));
libproxyobject/plugins/ogre/DragActions.cpp:    Location cameraLoc = camera->getProxy().extrapolateLocation(now);
libproxyobject/plugins/ogre/DragActions.cpp:    Location cameraGlobalLoc = camera->getProxy().globalLocation(now);
libproxyobject/plugins/ogre/DragActions.cpp:    float WORLD_SCALE = parent->getInputManager()->mWorldScale->as<float>();
libproxyobject/plugins/ogre/DragActions.cpp:    if (!parent->getInputManager()->isModifierDown(Input::MOD_CTRL) &&
libproxyobject/plugins/ogre/DragActions.cpp:        !parent->getInputManager()->isModifierDown(Input::MOD_SHIFT)) {
libproxyobject/plugins/ogre/DragActions.cpp:    } else if (parent->rayTrace(cameraGlobalLoc.getPosition(), direction(cameraGlobalLoc.getOrientation()), hitCount, distance, normal, subent) &&
libproxyobject/plugins/ogre/DragActions.cpp:               (distance*.75 < WORLD_SCALE || parent->getInputManager()->isModifierDown(Input::MOD_SHIFT))) {
libproxyobject/plugins/ogre/DragActions.cpp:        toMove *= (totalPosition - cameraGlobalLoc.getPosition()).length() * .75;
libproxyobject/plugins/ogre/DragActions.cpp:    camera->getProxy().resetLocation(now, cameraLoc);
libproxyobject/plugins/ogre/DragActions.cpp:        : RelativeDrag(info.ev->getDevice()) {
libproxyobject/plugins/ogre/DragActions.cpp:        if (ev->deltaLastY() != 0) {
libproxyobject/plugins/ogre/DragActions.cpp:            float dragMultiplier = mParent->getInputManager()->mDragMultiplier->as<float>();
libproxyobject/plugins/ogre/DragActions.cpp:            zoomInOut(AxisValue::fromCentered(dragMultiplier*ev->deltaLastY()), ev->getDevice(), mCamera, mSelection, mParent);
libproxyobject/plugins/ogre/DragActions.cpp:        CameraEntity *camera = mParent->mPrimaryCamera;
libproxyobject/plugins/ogre/DragActions.cpp:        Time now(mParent->getLocalTimeOffset()->now(camera->getProxy()));
libproxyobject/plugins/ogre/DragActions.cpp:        Location cameraLoc = camera->getProxy().globalLocation(now);
libproxyobject/plugins/ogre/DragActions.cpp:        Vector3d distance (cameraLoc.getPosition() - totalPosition);
libproxyobject/plugins/ogre/DragActions.cpp:        Quaternion dhorient2 = Quaternion(Vector3f(0,1,0), -radianX);
libproxyobject/plugins/ogre/DragActions.cpp:        camera->getProxy().resetLocation(now, cameraLoc);
libproxyobject/plugins/ogre/DragActions.cpp:        : RelativeDrag(info.ev->getDevice()),
libproxyobject/plugins/ogre/DragActions.cpp:        Time now(mParent->getLocalTimeOffset()->now(camera->getProxy()));
libproxyobject/plugins/ogre/DragActions.cpp:        Location cameraLoc = camera->getProxy().globalLocation(now);
libproxyobject/plugins/ogre/DragActions.cpp:        Vector3d amount (ev->deltaX(), ev->deltaY(), 0);
libproxyobject/plugins/ogre/DragActions.cpp:                             dev->getAxis(PointerDevice::CURSORX).getCentered(),
libproxyobject/plugins/ogre/DragActions.cpp:                             dev->getAxis(PointerDevice::CURSORY).getCentered()));
libproxyobject/plugins/ogre/DragActions.cpp:        if (mParent->rayTrace(cameraLoc.getPosition(), toMove, normal distance)) {
libproxyobject/plugins/ogre/DragActions.cpp:            double multiplier = (totalPosition - cameraLoc.getPosition()).length();
libproxyobject/plugins/ogre/DragActions.cpp:            panCamera(camera, camera->getProxy().extrapolateLocation(now).getPosition(), amount * multiplier);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:    ProxyObject *pp = one->getProxyPtr().get();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:    Time now = one->getScene()->getLocalTimeOffset()->now(*pp);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:    Location loc1 = pp->globalLocation(now);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:    pp = two->getProxyPtr().get();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:    Location loc2 = pp->globalLocation(now);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        return mesh1->getPhysical().name < mesh2->getPhysical().name;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            while (!end() && !((*mIter).second->getProxy().getParent() == mParentEntity->id())) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                mOgreSys(parent->getScene()) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            mIter = mOgreSys->mSceneEntities.begin();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            return (mIter == mOgreSys->mSceneEntities.end());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Location location(cam->getProxy().globalLocation(time));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Ogre::Ray traceFrom(toOgre(location.getPosition(), mParent->getOffset()), toOgre(dir));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Entity *ent = obj ? mParent->getEntity(obj->getObjectReference()) : NULL;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            Ogre::Node *node = ent->getSceneNode();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            const Ogre::Vector3 &position = node->_getDerivedPosition();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            const Ogre::Quaternion &orient = node->_getDerivedOrientation();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            const Ogre::Vector3 &scale = node->_getDerivedScale();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            OgreMesh::intersectTri(OgreMesh::transformRay(ent->getSceneNode(), traceFrom), res, &newt, true); // &res.tri
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            WebView *wv = me->getWebView(mMouseDownSubEntity);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                wv->getExtents(wid,hei);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                    wv->injectMouseDown(x, y);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                    wv->injectMouseUp(x, y);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                    wv->injectMouseMove(x, y);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Location location(cam->getProxy().globalLocation(time));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        int subent=-1;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Ogre::Ray traceFrom(toOgre(location.getPosition(), mParent->getOffset()), toOgre(dir));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Entity *mouseOverEntity = mParent->internalRayTrace(traceFrom, false, *hitCount, dist, normal, subent, &res, mousedown, which);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                mMouseDownObject = me->getProxyPtr();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                WebView *wv = me->getWebView(mMouseDownSubEntity);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                    //if (which==0) {*hitCount=-1;}
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            while (!(mouseOverEntity->getProxy().getParent() == mCurrentGroup)) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                mouseOverEntity = mParent->getEntity(mouseOverEntity->getProxy().getParent());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            ProxyObjectPtr obj(selectIter->lock());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            Entity *ent = obj ? mParent->getEntity(obj->getObjectReference()) : NULL;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                ent->setSelected(false);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        mParent->quit();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        float delx = x-*lastX;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        float dely = y-*lastY;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        if (delx<0) delx=-delx;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        if (dely<0) dely=-dely;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        if (!mParent||!mParent->mPrimaryCamera) return;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        CameraEntity *camera = mParent->mPrimaryCamera;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Time time = mParent->getLocalTimeOffset()->now(camera->getProxy());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        if (mParent->mInputManager->isModifierDown(Input::MOD_SHIFT)) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            if (mouseOver->id() == mLastShiftSelected && numObjectsUnderCursor==mLastHitCount ) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                SelectedObjectSet::iterator selectIter = mSelectedObjects.find(mouseOver->getProxyPtr());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                    ProxyObjectPtr obj(selectIter->lock());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                    Entity *ent = obj ? mParent->getEntity(obj->getObjectReference()) : NULL;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                        ent->setSelected(false);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            SelectedObjectSet::iterator selectIter = mSelectedObjects.find(mouseOver->getProxyPtr());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                SILOG(input,info,"Added selection " << mouseOver->id());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                mSelectedObjects.insert(mouseOver->getProxyPtr());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                mouseOver->setSelected(true);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                mLastShiftSelected = mouseOver->id();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                ProxyObjectPtr obj(selectIter->lock());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                Entity *ent = obj ? mParent->getEntity(obj->getObjectReference()) : NULL;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                    SILOG(input,info,"Deselected " << ent->id());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                    ent->setSelected(false);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        else if (mParent->mInputManager->isModifierDown(Input::MOD_CTRL)) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                mSelectedObjects.insert(mouseOver->getProxyPtr());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                mouseOver->setSelected(true);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                SILOG(input,info,"Replaced selection with " << mouseOver->id());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            ProxyObjectPtr obj(iter->lock());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            obj->sendMessage(
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        SpaceObjectReference newId = SpaceObjectReference(ent->id().space(), ObjectReference(UUID::random()));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Location loc = ent->getProxy().globalLocation(now);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Location localLoc = ent->getProxy().extrapolateLocation(now);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        ProxyManager *proxyMgr = ent->getProxy().getProxyManager();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            std::tr1::dynamic_pointer_cast<ProxyMeshObject>(ent->getProxyPtr()));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            std::tr1::dynamic_pointer_cast<ProxyLightObject>(ent->getProxyPtr()));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                std::tr1::dynamic_pointer_cast<ProxyWebViewObject>(ent->getProxyPtr()));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                std::tr1::shared_ptr<ProxyWebViewObject> newWebObject(new ProxyWebViewObject(proxyMgr, newId, parentPtr->odp()));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                newWebObject->loadURL("http://www.google.com/");
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                newMeshObject = std::tr1::shared_ptr<ProxyMeshObject>(new ProxyMeshObject(proxyMgr, newId, parentPtr->odp()));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            proxyMgr->createObject(newMeshObject,mParent->getPrimaryCamera()->getProxy().getQueryTracker());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            newMeshObject->setMesh(meshObj->getMesh());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            newMeshObject->setScale(meshObj->getScale());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            std::tr1::shared_ptr<ProxyLightObject> newLightObject (new ProxyLightObject(proxyMgr, newId, parentPtr->odp()));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            proxyMgr->createObject(newLightObject,mParent->getPrimaryCamera()->getProxy().getQueryTracker());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            newLightObject->update(lightObj->getLastLightInfo());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            newObj = ProxyObjectPtr(new ProxyMeshObject(proxyMgr, newId, parentPtr->odp()));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            proxyMgr->createObject(newObj,mParent->getPrimaryCamera()->getProxy().getQueryTracker());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                newObj->setParent(parentPtr, now, loc, localLoc);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                newObj->resetLocation(now, localLoc);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                newObj->resetLocation(now, loc);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        return mParent->getEntity(newId);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        float WORLD_SCALE = mParent->mInputManager->mWorldScale->as<float>();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            ProxyObjectPtr obj(iter->lock());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            Entity *ent = obj ? mParent->getEntity(obj->getObjectReference()) : NULL;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            Time objnow=Time::convertFrom(now,mParent->getLocalTimeOffset()->offset(ent->getProxy()));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            Entity *newEnt = doCloneObject(ent, ent->getProxy().getParentProxy(), objnow);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            Location loc (ent->getProxy().extrapolateLocation(objnow));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            newEnt->getProxy().resetLocation(objnow, loc);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            newSelectedObjects.insert(newEnt->getProxyPtr());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            newEnt->setSelected(true);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            ent->setSelected(false);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        if (!mParent->mPrimaryCamera) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        ProxyManager *proxyMgr = mParent->mPrimaryCamera->getProxy().getProxyManager();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Time now(mParent->getLocalTimeOffset()->now(mParent->mPrimaryCamera->getProxy()));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            ProxyObjectPtr obj(iter->lock());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            Entity *ent = obj ? mParent->getEntity(obj->getObjectReference()) : NULL;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            if (ent->getProxy().getProxyManager() != proxyMgr) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            if (!(ent->getProxy().getParent() == parentId)) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                SILOG(input,error,"Multiple select "<< ent->id() <<
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                      " has parent  "<<ent->getProxy().getParent() << " instead of " << mCurrentGroup);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Entity *parentEntity = mParent->getEntity(parentId);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            totalLocation = parentEntity->getProxy().globalLocation(now);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        proxyMgr->createObject(ProxyObjectPtr(new ProxyMeshObject(proxyMgr, newParentId, mParent->getPrimaryCamera()->getProxy().odp())),mParent->getPrimaryCamera()->getProxy().getQueryTracker());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Entity *newParentEntity = mParent->getEntity(newParentId);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        newParentEntity->getProxy().resetLocation(now, totalLocation);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            newParentEntity->getProxy().setParent(parentEntity->getProxyPtr(), now);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            ProxyObjectPtr obj(iter->lock());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            Entity *ent = obj ? mParent->getEntity(obj->getObjectReference()) : NULL;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            ent->getProxy().setParent(newParentEntity->getProxyPtr(), now);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            ent->setSelected(false);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        mSelectedObjects.insert(newParentEntity->getProxyPtr());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        newParentEntity->setSelected(true);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            ProxyObjectPtr obj(iter->lock());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            Entity *parentEnt = obj ? mParent->getEntity(obj->getObjectReference()) : NULL;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            ProxyManager *proxyMgr = parentEnt->getProxy().getProxyManager();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            ProxyObjectPtr parentParent (parentEnt->getProxy().getParentProxy());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            mCurrentGroup = parentEnt->getProxy().getParent(); // parentParent may be NULL.
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                ent->getProxy().setParent(parentParent, Time::convertFrom(now,mParent->getLocalTimeOffset()->offset(ent->getProxy())));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                newSelectedObjects.insert(ent->getProxyPtr());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                ent->setSelected(true);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                parentEnt->setSelected(false);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                proxyMgr->destroyObject(parentEnt->getProxyPtr(),mParent->getPrimaryCamera()->getProxy().getQueryTracker());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                newSelectedObjects.insert(parentEnt->getProxyPtr());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            ProxyObjectPtr obj(iter->lock());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            parentEnt = obj ? mParent->getEntity(obj->getObjectReference()) : NULL;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                newSelectedObjects.insert(ent->getProxyPtr());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                ent->setSelected(true);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                mCurrentGroup = parentEnt->id();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            ProxyObjectPtr obj(iter->lock());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            Entity *selent = obj ? mParent->getEntity(obj->getObjectReference()) : NULL;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                selent->setSelected(false);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Entity *ent = mParent->getEntity(mCurrentGroup);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            mCurrentGroup = ent->getProxy().getParent();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            Entity *parentEnt = mParent->getEntity(mCurrentGroup);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                mSelectedObjects.insert(parentEnt->getProxyPtr());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        ui_wv->loadFile(ui_page);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        float WORLD_SCALE = mParent->mInputManager->mWorldScale->as<float>();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        CameraEntity *camera = mParent->mPrimaryCamera;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        SpaceObjectReference newId = SpaceObjectReference(camera->id().space(), ObjectReference(UUID::random()));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        ProxyManager *proxyMgr = camera->getProxy().getProxyManager();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Time now(mParent->getLocalTimeOffset()->now(camera->getProxy()));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Location loc (camera->getProxy().globalLocation(now));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        std::tr1::shared_ptr<ProxyWebViewObject> newWebObject (new ProxyWebViewObject(proxyMgr, newId, camera->getProxy().odp()));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        proxyMgr->createObject(newWebObject,mParent->getPrimaryCamera()->getProxy().getQueryTracker());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            newWebObject->setMesh(URI("meru:///webview.mesh"));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            newWebObject->loadURL("http://www.yahoo.com/");
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Entity *parentent = mParent->getEntity(mCurrentGroup);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            Location localLoc = loc.toLocal(parentent->getProxy().globalLocation(now));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            newWebObject->setParent(parentent->getProxyPtr(), now, loc, localLoc);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            newWebObject->resetLocation(now, localLoc);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            newWebObject->resetLocation(now, loc);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        createLight(now)->setParent(newWebObject, now);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Entity *ent = mParent->getEntity(newId);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            ent->setSelected(true);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        float WORLD_SCALE = mParent->mInputManager->mWorldScale->as<float>();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        CameraEntity *camera = mParent->mPrimaryCamera;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Time now(mParent->getLocalTimeOffset()->now(camera->getProxy()));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Location curLoc (camera->getProxy().globalLocation(now));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        camera->getProxy().sendMessage(
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            script_type = type_it->second;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        float WORLD_SCALE = mParent->mInputManager->mWorldScale->as<float>();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        CameraEntity *camera = mParent->mPrimaryCamera;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Time now(mParent->getLocalTimeOffset()->now(camera->getProxy()));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Location curLoc (camera->getProxy().globalLocation(now));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            script_args.add_keys(arg_it->first); script_args.add_values(arg_it->second);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        camera->getProxy().sendMessage(
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        float WORLD_SCALE = mParent->mInputManager->mWorldScale->as<float>();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        CameraEntity *camera = mParent->mPrimaryCamera;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        SpaceObjectReference newId = SpaceObjectReference(camera->id().space(), ObjectReference(UUID::random()));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        ProxyManager *proxyMgr = camera->getProxy().getProxyManager();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Location loc (camera->getProxy().globalLocation(now));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        loc.setOrientation(Quaternion(0.886995, 0.000000, -0.461779, 0.000000, Quaternion::WXYZ()));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        std::tr1::shared_ptr<ProxyLightObject> newLightObject (new ProxyLightObject(proxyMgr, newId, camera->getProxy().odp()));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        proxyMgr->createObject(newLightObject,camera->getProxy().getQueryTracker());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            newLightObject->update(li);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Entity *parentent = mParent->getEntity(mCurrentGroup);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            Location localLoc = loc.toLocal(parentent->getProxy().globalLocation(now));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            newLightObject->setParent(parentent->getProxyPtr(), now, loc, localLoc);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            newLightObject->resetLocation(now, localLoc);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            newLightObject->resetLocation(now, loc);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Entity *ent = mParent->getEntity(newId);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            ent->setSelected(true);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        CameraEntity *camera = mParent->mPrimaryCamera;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        createLight(mParent->getLocalTimeOffset()->now(camera->getProxy()));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:		while ((parentProxy=camProxy->getParentProxy())) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        float WORLD_SCALE = mParent->mInputManager->mWorldScale->as<float>();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        if (!mParent||!mParent->mPrimaryCamera) return;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        ProxyObjectPtr cam = getTopLevelParent(mParent->mPrimaryCamera->getProxyPtr());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Time now(mParent->getLocalTimeOffset()->now(*cam));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Location loc = cam->extrapolateLocation(now);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        cam->requestLocation(now, rloc);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        float WORLD_SCALE = mParent->mInputManager->mWorldScale->as<float>();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        if (!mParent||!mParent->mPrimaryCamera) return;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        ProxyObjectPtr cam = getTopLevelParent(mParent->mPrimaryCamera->getProxyPtr());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Time now(mParent->getLocalTimeOffset()->now(*cam));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Location loc = cam->extrapolateLocation(now);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        cam->requestLocation(now, rloc);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        float WORLD_SCALE = mParent->mInputManager->mWorldScale->as<float>();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        if (!mParent||!mParent->mPrimaryCamera) return;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        ProxyObjectPtr cam = getTopLevelParent(mParent->mPrimaryCamera->getProxyPtr());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Time now(mParent->getLocalTimeOffset()->now(*cam));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Location loc = cam->extrapolateLocation(now);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        raxis.z = -std::sin(p*DEG2RAD);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        cam->requestLocation(now, rloc);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        mParent->mInputManager->filesDropped(files);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        for (iter = mParent->mSceneEntities.begin(); iter != mParent->mSceneEntities.end(); ++iter) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            entlist.push_back(iter->second);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        roll = std::atan2((2*((q0*q1)+(q2*q3))), (1-(2*(std::pow(q1,2.0)+std::pow(q2,2.0)))));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        pitch = std::asin((2*((q0*q2)-(q3*q1))));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        yaw = std::atan2((2*((q0*q3)+(q1*q2))), (1-(2*(std::pow(q2,2.0)+std::pow(q3,2.0)))));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        std::string name = obj->getPhysical().name;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            name = obj->getMesh().filename();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            name.resize(name.size()-5);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        ProxyObject *pp = e->getProxyPtr().get();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Time now(mParent->getLocalTimeOffset()->now(*pp));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Location loc = pp->globalLocation(now);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        ProxyObjectPtr parentObj = pp->getParentProxy();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            const LightInfo &linfo = light->getLastLightInfo();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            URI uri = mesh->getMesh();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            const PhysicalParameters &phys = mesh->getPhysical();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                    mesh->getScale().x,mesh->getScale().y,mesh->getScale().z,
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        if (!mParent||!mParent->mPrimaryCamera) return;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        zoomInOut(value, axes, mParent->mPrimaryCamera, mSelectedObjects, mParent);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        float multiplier = mParent->mInputManager->mWheelToAxis->as<float>();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        if (axisev->mAxis == SDLMouse::WHEELY) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            bool used = WebViewManager::getSingleton().injectMouseWheel(WebViewCoord(0, axisev->mValue.getCentered()/multiplier));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        if (axisev->mAxis == SDLMouse::WHEELX) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            bool used = WebViewManager::getSingleton().injectMouseWheel(WebViewCoord(axisev->mValue.getCentered()/multiplier, 0));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        if (mParent->mPrimaryCamera) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            CameraEntity *camera = mParent->mPrimaryCamera;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            Time time = mParent->getLocalTimeOffset()->now(camera->getProxy());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            mouseOverWebView(camera, time, mouseev->mX, mouseev->mY, false, false);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            mWebViewActiveButtons.insert(mouseev->mButton);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        if (mParent->mPrimaryCamera) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            CameraEntity *camera = mParent->mPrimaryCamera;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            Time time = mParent->getLocalTimeOffset()->now(camera->getProxy());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            hoverEntity(camera, time, mouseev->mXStart, mouseev->mYStart, true, &lhc, mWhichRayObject);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            mouseOverWebView(camera, time, mouseev->mXStart, mouseev->mYStart, true, false);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        if (mWebViewActiveButtons.find(mouseev->mButton) != mWebViewActiveButtons.end()) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            mWebViewActiveButtons.erase(mouseev->mButton);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        if (mParent->mPrimaryCamera) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            CameraEntity *camera = mParent->mPrimaryCamera;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            Time time = mParent->getLocalTimeOffset()->now(camera->getProxy());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            mouseOverWebView(camera, time, mouseev->mX, mouseev->mY, false, true);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        if (!mParent||!mParent->mPrimaryCamera) return EventResponse::nop();
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        std::set<int>::iterator iter = mWebViewActiveButtons.find(ev->mButton);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            if (ev->mType == Input::DRAG_END) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        if (mParent->mPrimaryCamera) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            CameraEntity *camera = mParent->mPrimaryCamera;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            Time time = mParent->getLocalTimeOffset()->now(camera->getProxy());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            mouseOverWebView(camera, time, ev->mX, ev->mY, false, ev->mType == Input::DRAG_END);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        if (ev->mType == Input::DRAG_END) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        ActiveDrag * &drag = mActiveDrag[ev->mButton];
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        if (ev->mType == Input::DRAG_START) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                /*.camera = */ mParent->mPrimaryCamera, // for now...
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            if (mDragAction[ev->mButton]) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                drag = mDragAction[ev->mButton](info);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            drag->mouseMoved(ev);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            if (ev->mType == Input::DRAG_END) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        if (!mParent||!mParent->mPrimaryCamera) return;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        ProxyObjectPtr cam = getTopLevelParent(mParent->mPrimaryCamera->getProxyPtr());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Time now(mParent->getLocalTimeOffset()->now(*cam));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Location loc = cam->extrapolateLocation(now);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        cam->setLocation(now, loc);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        mCameraPathIndex = mCameraPath.clampKeyIndex(mCameraPathIndex-1);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        if (!mParent||!mParent->mPrimaryCamera) return;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        ProxyObjectPtr cam = getTopLevelParent(mParent->mPrimaryCamera->getProxyPtr());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Time now(mParent->getLocalTimeOffset()->now(*cam));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Location loc = cam->extrapolateLocation(now);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        Task::DeltaTime dt = t - mLastCameraTime;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        switch (ev->mType) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            if (!!(std::tr1::dynamic_pointer_cast<SDLMouse>(ev->mDevice))) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                SubscriptionId subId = mParent->mInputManager->subscribeId(
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                mDeviceSubscriptions.insert(DeviceSubMap::value_type(&*ev->mDevice, subId));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            if (!!(std::tr1::dynamic_pointer_cast<SDLKeyboard>(ev->mDevice))) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                    SubscriptionId subId = mParent->mInputManager->subscribeId(
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                    mDeviceSubscriptions.insert(DeviceSubMap::value_type(&*ev->mDevice, subId));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                    SubscriptionId subId = mParent->mInputManager->subscribeId(
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                    mDeviceSubscriptions.insert(DeviceSubMap::value_type(&*ev->mDevice, subId));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            while ((iter = mDeviceSubscriptions.find(&*ev->mDevice))!=mDeviceSubscriptions.end()) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                mParent->mInputManager->unsubscribe((*iter).second);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        mEvents.push_back(mParent->mInputManager->registerDeviceListener(
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        mEvents.push_back(mParent->mInputManager->subscribeId(
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        mEvents.push_back(mParent->mInputManager->subscribeId(
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        mEvents.push_back(mParent->mInputManager->subscribeId(
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        mEvents.push_back(mParent->mInputManager->subscribeId(
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        mEvents.push_back(mParent->mInputManager->subscribeId(
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        mEvents.push_back(mParent->mInputManager->subscribeId(
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        mInputResponses["moveForward"] = new FloatToggleInputResponse(std::tr1::bind(&MouseHandler::moveAction, this, Vector3f(0, 0, -1), _1), 1, 0);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        mInputResponses["moveLeft"] = new FloatToggleInputResponse(std::tr1::bind(&MouseHandler::moveAction, this, Vector3f(-1, 0, 0), _1), 1, 0);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        mInputResponses["moveDown"] = new FloatToggleInputResponse(std::tr1::bind(&MouseHandler::moveAction, this, Vector3f(0, -1, 0), _1), 1, 0);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        mInputResponses["rotateXNeg"] = new FloatToggleInputResponse(std::tr1::bind(&MouseHandler::rotateAction, this, Vector3f(-1, 0, 0), _1), 1, 0);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        mInputResponses["rotateYNeg"] = new FloatToggleInputResponse(std::tr1::bind(&MouseHandler::rotateAction, this, Vector3f(0, -1, 0), _1), 1, 0);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        mInputResponses["rotateZNeg"] = new FloatToggleInputResponse(std::tr1::bind(&MouseHandler::rotateAction, this, Vector3f(0, 0, -1), _1), 1, 0);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        mInputResponses["stableRotateNeg"] = new FloatToggleInputResponse(std::tr1::bind(&MouseHandler::stableRotateAction, this, -1.f, _1), 1, 0);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        mInputResponses["selectObjectReverse"] = new Vector2fInputResponse(std::tr1::bind(&MouseHandler::selectObjectAction, this, _1, -1));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        mInputResponses["cameraPathSpeedUp"] = new SimpleInputResponse(std::tr1::bind(&MouseHandler::cameraPathChangeSpeed, this, -0.1f));
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            mParent->mInputManager->unsubscribe(*iter);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            delete iter->second;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:            if(iter->second!=NULL)
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:                delete iter->second;
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        mMouseHandler->setParentGroupAndClear(obj->getProxy().getParent());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:    if (mMouseHandler->getParentGroup() == obj->getProxy().getParent()) {
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        mMouseHandler->addToSelection(obj->getProxyPtr());
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        obj->setSelected(true);
libproxyobject/plugins/ogre/OgreSystemMouseHandler.cpp:        mMouseHandler->tick(t);
libproxyobject/plugins/ogre/MeshEntity.cpp:                 id.length()?id:ogreMeshName(pmo->getObjectReference()),
libproxyobject/plugins/ogre/MeshEntity.cpp:        (grm->getResourceEntity(pmo->getObjectReference(), this));
libproxyobject/plugins/ogre/MeshEntity.cpp:    mResource->entityDestroyed();
libproxyobject/plugins/ogre/MeshEntity.cpp:        getScene()->getSceneManager()->destroyEntity(toDestroy);
libproxyobject/plugins/ogre/MeshEntity.cpp:		if (tus->getTextureName() == mFrom) {
libproxyobject/plugins/ogre/MeshEntity.cpp:			tus->setTextureName(mTo);
libproxyobject/plugins/ogre/MeshEntity.cpp:		if (mFrom.find(tus->getTextureName()) != mFrom.end()) {
libproxyobject/plugins/ogre/MeshEntity.cpp:	int numTechniques = material->getNumTechniques();
libproxyobject/plugins/ogre/MeshEntity.cpp:		Ogre::Technique *tech = material->getTechnique(whichTechnique);
libproxyobject/plugins/ogre/MeshEntity.cpp:		int numPasses = tech->getNumPasses();
libproxyobject/plugins/ogre/MeshEntity.cpp:			Ogre::Pass *pass = tech->getPass(whichPass);
libproxyobject/plugins/ogre/MeshEntity.cpp:			int numTUS = pass->getNumTextureUnitStates();
libproxyobject/plugins/ogre/MeshEntity.cpp:				Ogre::TextureUnitState *tus = pass->getTextureUnitState(whichTUS);
libproxyobject/plugins/ogre/MeshEntity.cpp:	if (whichSubEnt >= (int)(ent->getNumSubEntities()) || whichSubEnt < 0) {
libproxyobject/plugins/ogre/MeshEntity.cpp:		WebView *wv = WebViewManager::getSingleton().getWebView(iter->second.first);
libproxyobject/plugins/ogre/MeshEntity.cpp:	int numSubEntities = ent->getNumSubEntities();
libproxyobject/plugins/ogre/MeshEntity.cpp:		int whichSubEntity = iter->first;
libproxyobject/plugins/ogre/MeshEntity.cpp:		Ogre::SubEntity *subEnt = ent->getSubEntity(whichSubEntity);
libproxyobject/plugins/ogre/MeshEntity.cpp:		Ogre::MaterialPtr origMaterial = iter->second.second;
libproxyobject/plugins/ogre/MeshEntity.cpp:		subEnt->setMaterial(origMaterial);
libproxyobject/plugins/ogre/MeshEntity.cpp:		Ogre::SubEntity *subEnt = ent->getSubEntity(whichSubEntity);
libproxyobject/plugins/ogre/MeshEntity.cpp:		Ogre::MaterialPtr material = subEnt->getMaterial();
libproxyobject/plugins/ogre/MeshEntity.cpp:			Ogre::MaterialPtr newMaterial = material->clone(material->getName()+id().toString(), false, Ogre::String());
libproxyobject/plugins/ogre/MeshEntity.cpp:				SILOG(ogre,debug,"Replacing a texture "<<id()<<" : "<<iter->first<<" -> "<<iter->second);
libproxyobject/plugins/ogre/MeshEntity.cpp:				forEachTexture(newMaterial, ReplaceTexture(iter->first, iter->second));
libproxyobject/plugins/ogre/MeshEntity.cpp:				newTexture = iter->second;
libproxyobject/plugins/ogre/MeshEntity.cpp:			subEnt->setMaterial(newMaterial);
libproxyobject/plugins/ogre/MeshEntity.cpp:        new_entity = getScene()->getSceneManager()->createEntity(
libproxyobject/plugins/ogre/MeshEntity.cpp:        new_entity = getScene()->getSceneManager()->createEntity(ogreMovableName(),Ogre::SceneManager::PT_CUBE);
libproxyobject/plugins/ogre/MeshEntity.cpp:            getScene()->getSceneManager()->destroyEntity(oldMeshObj);
libproxyobject/plugins/ogre/MeshEntity.cpp:    SILOG(ogre,debug,"Bounding box: " << new_entity->getBoundingBox());
libproxyobject/plugins/ogre/MeshEntity.cpp:        new_entity->setMaterialName("BaseWhiteTexture");
libproxyobject/plugins/ogre/MeshEntity.cpp:    unsigned int num_subentities=new_entity->getNumSubEntities();
libproxyobject/plugins/ogre/MeshEntity.cpp:    Ogre::Vector4 parallax_steps(getScene()->mParallaxSteps->as<float>(),getScene()->mParallaxShadowSteps->as<int>(),0.0,1.0);
libproxyobject/plugins/ogre/MeshEntity.cpp:        new_entity->getSubEntity(subent)->setCustomParameter(0,random_values);
libproxyobject/plugins/ogre/MeshEntity.cpp:        new_entity->getSubEntity(subent)->setCustomParameter(1,parallax_steps);
libproxyobject/plugins/ogre/MeshEntity.cpp:        getScene()->getSceneManager()->destroyEntity(oldMeshObj);
libproxyobject/plugins/ogre/MeshEntity.cpp:    //init(getScene()->getSceneManager()->createEntity(ogreMovableName(), Ogre::SceneManager::PT_CUBE));
libproxyobject/plugins/ogre/MeshEntity.cpp:        getScene()->getSceneManager()->destroyEntity(meshObj);
libproxyobject/plugins/ogre/MeshEntity.cpp:    /// hack to support collada mesh -- eventually this should be smarter
libproxyobject/plugins/ogre/MeshEntity.cpp:    if (fn.rfind(".dae")==fn.size()-4) is_collada=true;
libproxyobject/plugins/ogre/MeshEntity.cpp:        Meru::SharedResourcePtr newModelPtr = grm->getResourceAsset ( meshFile, Meru::GraphicsResource::MODEL );
libproxyobject/plugins/ogre/MeshEntity.cpp:        mResource->setMeshResource ( newModelPtr );
libproxyobject/plugins/ogre/MeshEntity.cpp:        Meru::SharedResourcePtr newMeshPtr = grm->getResourceAsset ( meshFile, Meru::GraphicsResource::MESH );
libproxyobject/plugins/ogre/MeshEntity.cpp:        mResource->setMeshResource ( newMeshPtr );
libproxyobject/plugins/ogre/MeshEntity.cpp:    if (up==3) return Vector3f(v[0],v[2], -v[1]);
libproxyobject/plugins/ogre/MeshEntity.cpp:        Ogre::MaterialPtr mat = base_mat->clone(matname);
libproxyobject/plugins/ogre/MeshEntity.cpp:        mat->getTechnique(0)->getPass(0)->createTextureUnitState("Cache/" + mTextureFingerprints[texURI], 0);
libproxyobject/plugins/ogre/MeshEntity.cpp:            base_mat->getName();
libproxyobject/plugins/ogre/MeshEntity.cpp:                tv = 1.0-uv[1];           //  why you gotta be like that?
libproxyobject/plugins/ogre/MeshEntity.cpp:    loadMesh(hash);                     /// this is here because we removed  mResource->loaded(true, mEpoch) in  ModelLoadTask::doRun
libproxyobject/plugins/ogre/MeshEntity.cpp:    if ((int)ev->getStatus())
libproxyobject/plugins/ogre/MeshEntity.cpp:        << " status: " << (int)ev->getStatus()
libproxyobject/plugins/ogre/MeshEntity.cpp:        << " fingerprint: " << ev->fingerprint()
libproxyobject/plugins/ogre/MeshEntity.cpp:        << " length: " << (int)ev->data().length()
libproxyobject/plugins/ogre/MeshEntity.cpp:    SILOG(ogre,fatal,ev->uri().toString() << " -> " << ev->fingerprint().convertToHexString());
libproxyobject/plugins/ogre/MeshEntity.cpp:    mTextureFingerprints[ev->uri().toString()] = ev->fingerprint().convertToHexString();
libproxyobject/plugins/ogre/MeshEntity.cpp:    mRemainingDownloads--;
libproxyobject/plugins/ogre/MeshEntity.cpp:        /*mScene->mTransferManager->download(
libproxyobject/plugins/ogre/MeshEntity.cpp:    mSceneNode->setScale ( toOgre ( scale ) );
libproxyobject/plugins/ogre/InputBinding.cpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/InputBinding.cpp: *  Copyright (c) 2009, Ewen Cheslack-Postava
libproxyobject/plugins/ogre/InputBinding.cpp:    InputResponse::InputEventDescriptorList evts = response->getInputEvents(evt);
libproxyobject/plugins/ogre/InputBinding.cpp:    Input::EventDescriptor descriptor = evt->getDescriptor();
libproxyobject/plugins/ogre/InputBinding.cpp:        InputResponse* response = it->second;
libproxyobject/plugins/ogre/InputBinding.cpp:        response->invoke(evt);
libproxyobject/plugins/ogre/meruCompat/DependencyManager.hpp:		b->addDepender(a);
libproxyobject/plugins/ogre/meruCompat/SequentialWorkQueue.hpp:        return mWorkQueue->probablyEmpty()?0:1;
libproxyobject/plugins/ogre/meruCompat/SequentialWorkQueue.hpp:    	return mWorkQueue->dequeuePoll();
libproxyobject/plugins/ogre/meruCompat/SequentialWorkQueue.hpp:    	mWorkQueue->dequeueAll();
libproxyobject/plugins/ogre/meruCompat/SequentialWorkQueue.hpp:    	mWorkQueue->enqueue(new WorkItemClass(work));
libproxyobject/plugins/ogre/meruCompat/SequentialWorkQueue.hpp:        mWorkQueue->enqueue(item);
libproxyobject/plugins/ogre/meruCompat/SequentialWorkQueue.hpp:        return mWorkQueue->dequeuePoll();
libproxyobject/plugins/ogre/meruCompat/SequentialWorkQueue.hpp:        return mWorkQueue->dequeueUntil(until)!=0;
libproxyobject/plugins/ogre/meruCompat/SequentialWorkQueue.hpp~:        return mWorkQueue->probablyEmpty()?0:1;
libproxyobject/plugins/ogre/meruCompat/SequentialWorkQueue.hpp~:    	return mWorkQueue->dequeuePoll();
libproxyobject/plugins/ogre/meruCompat/SequentialWorkQueue.hpp~:    	mWorkQueue->dequeueAll();
libproxyobject/plugins/ogre/meruCompat/SequentialWorkQueue.hpp~:    	mWorkQueue->enqueue(new WorkItemClass(work));
libproxyobject/plugins/ogre/meruCompat/SequentialWorkQueue.hpp~:        mWorkQueue->enqueue(item);
libproxyobject/plugins/ogre/meruCompat/SequentialWorkQueue.hpp~:        return mWorkQueue->dequeuePoll();
libproxyobject/plugins/ogre/meruCompat/SequentialWorkQueue.hpp~:        return mWorkQueue->dequeueUntil(until)!=0;
libproxyobject/plugins/ogre/meruCompat/Event.cpp:    os<<"("<< getId().toString() <<" - ["<< (mTime-Time::null()).toSeconds() << "])";
libproxyobject/plugins/ogre/meruCompat/Event.cpp:    return String("(") + getId().toString() + String(" - ") + mObject.toString() + String(")");
libproxyobject/plugins/ogre/meruCompat/Event.cpp:    return String("(") + getId().toString() + String(" - ") + mUUID.toString() + String(")");
libproxyobject/plugins/ogre/meruCompat/Event.cpp:    return String("(") + getId().toString() + String(" - [") + mObjects[0].toString() + String(",") + mObjects[1].toString() + String("]") + String(")");
libproxyobject/plugins/ogre/meruCompat/Event.cpp:  os <<String("(")<< getId().toString()<< String(" - [") << mID.toString() <<
libproxyobject/plugins/ogre/meruCompat/Event.cpp:        String(" at ") << (time-Time::null()).toSeconds() << String(", ") <<
libproxyobject/plugins/ogre/meruCompat/Event.cpp:    os << "(" << getId().toString() << " - [" << (time-Time::null()).toSeconds() << ", " <<
libproxyobject/plugins/ogre/meruCompat/Singleton.hpp:/** ManualSingleton - Templated singleton class for types
libproxyobject/plugins/ogre/meruCompat/Singleton.hpp:/** AutoSingleton - Templated singleton class for types
libproxyobject/plugins/ogre/InputResponse.cpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/InputResponse.cpp: *  Copyright (c) 2009, Ewen Cheslack-Postava
libproxyobject/plugins/ogre/InputResponse.cpp:    if (evt->args.size() > 0) {
libproxyobject/plugins/ogre/InputResponse.cpp:            arg = boost::lexical_cast<float>(evt->args[0]);
libproxyobject/plugins/ogre/InputResponse.cpp:    mCallback(Vector2f(evt->mX, evt->mY));
libproxyobject/plugins/ogre/InputResponse.cpp:    mCallback(Vector2f(evt->mX, evt->mY));
libproxyobject/plugins/ogre/InputResponse.cpp:    float val = evt->mValue.getCentered();
libproxyobject/plugins/ogre/InputResponse.cpp:    InputDevicePtr dev = evt->getDevice();
libproxyobject/plugins/ogre/InputResponse.cpp:            dev->getAxis(Input::AXIS_CURSORX).getCentered(),
libproxyobject/plugins/ogre/InputResponse.cpp:            dev->getAxis(Input::AXIS_CURSORY).getCentered()
libproxyobject/plugins/ogre/InputResponse.cpp:    const std::vector<String>& args = wvevt->args;
libproxyobject/plugins/ogre/InputResponse.cpp:    const std::vector<String>& args = wvevt->args;
libproxyobject/plugins/ogre/OgreSystem.hpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/OgreSystem.hpp:        if (os->initialize(proxyManager,localTimeOffset,options))
libproxyobject/plugins/ogre/OgreSystem.hpp:        return getEntity(proxy->getObjectReference());
libproxyobject/plugins/ogre/WebView.cpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/WebView.cpp:		overlay->panel->setUV(0, 0, (Real)viewWidth/(Real)texWidth, (Real)viewHeight/(Real)texHeight);
libproxyobject/plugins/ogre/WebView.cpp:	this->texFiltering = texFiltering;
libproxyobject/plugins/ogre/WebView.cpp:	MaterialManager::getSingletonPtr()->remove(getMaterialName());
libproxyobject/plugins/ogre/WebView.cpp:	if (!this->viewTexture.isNull()) {
libproxyobject/plugins/ogre/WebView.cpp:        ResourcePtr res(this->viewTexture);
libproxyobject/plugins/ogre/WebView.cpp:        this->viewTexture.setNull();
libproxyobject/plugins/ogre/WebView.cpp:	if(this->proxyObject) {
libproxyobject/plugins/ogre/WebView.cpp:		this->proxyObject->WebViewProvider::removeListener(this);
libproxyobject/plugins/ogre/WebView.cpp:		this->proxyObject->ProxyObjectProvider::removeListener(this);
libproxyobject/plugins/ogre/WebView.cpp:	this->proxyObject = proxyObject;
libproxyobject/plugins/ogre/WebView.cpp:	if(this->proxyObject) {
libproxyobject/plugins/ogre/WebView.cpp:		proxyObject->WebViewProvider::addListener(this);
libproxyobject/plugins/ogre/WebView.cpp:		proxyObject->ProxyObjectProvider::addListener(this);
libproxyobject/plugins/ogre/WebView.cpp:    webView->setDelegate(this);
libproxyobject/plugins/ogre/WebView.cpp:        webView->resize(viewWidth-mBorderLeft-mBorderRight, viewHeight-mBorderTop-mBorderBottom);
libproxyobject/plugins/ogre/WebView.cpp:        webView->resize(0, 0);
libproxyobject/plugins/ogre/WebView.cpp:		if(Root::getSingleton().getRenderSystem()->getCapabilities()->hasCapability(RSC_NON_POWER_OF_2_TEXTURES))
libproxyobject/plugins/ogre/WebView.cpp:			if(Root::getSingleton().getRenderSystem()->getCapabilities()->getNonPOW2TexturesLimited())
libproxyobject/plugins/ogre/WebView.cpp:    this->viewTexture = texture;
libproxyobject/plugins/ogre/WebView.cpp:	HardwarePixelBufferSharedPtr pixelBuffer = texture->getBuffer();
libproxyobject/plugins/ogre/WebView.cpp:	pixelBuffer->lock(HardwareBuffer::HBL_DISCARD);
libproxyobject/plugins/ogre/WebView.cpp:	const PixelBox& pixelBox = pixelBuffer->getCurrentLock();
libproxyobject/plugins/ogre/WebView.cpp:     pixelBuffer->unlock();
libproxyobject/plugins/ogre/WebView.cpp:     matPass = material->getTechnique(0)->getPass(0);
libproxyobject/plugins/ogre/WebView.cpp:     //matPass->setSeparateSceneBlending (SBF_SOURCE_ALPHA, SBF_ONE_MINUS_SOURCE_ALPHA, SBF_SOURCE_ALPHA, SBF_ONE_MINUS_SOURCE_ALPHA);
libproxyobject/plugins/ogre/WebView.cpp:     matPass->setSeparateSceneBlending (SBF_ONE, SBF_ONE_MINUS_SOURCE_ALPHA, SBF_SOURCE_ALPHA, SBF_ONE_MINUS_SOURCE_ALPHA);
libproxyobject/plugins/ogre/WebView.cpp:     matPass->setDepthWriteEnabled(false);
libproxyobject/plugins/ogre/WebView.cpp:     baseTexUnit = matPass->createTextureUnitState(getViewTextureName());
libproxyobject/plugins/ogre/WebView.cpp:     baseTexUnit->setTextureFiltering(texFiltering, texFiltering, FO_NONE);
libproxyobject/plugins/ogre/WebView.cpp:         baseTexUnit->setTextureAnisotropy(4);
libproxyobject/plugins/ogre/WebView.cpp:     tex->setTextureType(TEX_TYPE_2D);
libproxyobject/plugins/ogre/WebView.cpp:     tex->setWidth(texWidth);
libproxyobject/plugins/ogre/WebView.cpp:     tex->setHeight(texHeight);
libproxyobject/plugins/ogre/WebView.cpp:     tex->setNumMipmaps(0);
libproxyobject/plugins/ogre/WebView.cpp:     tex->setFormat(PF_BYTE_BGRA);
libproxyobject/plugins/ogre/WebView.cpp:     tex->setUsage(TU_DYNAMIC);
libproxyobject/plugins/ogre/WebView.cpp:     tex->createInternalResources();
libproxyobject/plugins/ogre/WebView.cpp:         if(timer.getMilliseconds() - lastUpdateTime < 1000 / maxUpdatePS)
libproxyobject/plugins/ogre/WebView.cpp:         baseTexUnit->setAlphaOperation(LBX_SOURCE1, LBS_MANUAL, LBS_CURRENT, fadeValue * opacity);
libproxyobject/plugins/ogre/WebView.cpp:         baseTexUnit->setAlphaOperation(LBX_BLEND_TEXTURE_ALPHA, LBS_MANUAL, LBS_TEXTURE, fadeValue * opacity);
libproxyobject/plugins/ogre/WebView.cpp:         baseTexUnit->setAlphaOperation(LBX_SOURCE1, LBS_MANUAL, LBS_CURRENT, fadeValue * opacity);
libproxyobject/plugins/ogre/WebView.cpp:         fadeValue += deltaFadePerMS * (timer.getMilliseconds() - lastFadeTimeMS);
libproxyobject/plugins/ogre/WebView.cpp:             if(overlay) {overlay->hide();}
libproxyobject/plugins/ogre/WebView.cpp:     if(!overlay || !overlay->isVisible || !overlay->viewport)
libproxyobject/plugins/ogre/WebView.cpp:     int localX = overlay->getRelativeX(x);
libproxyobject/plugins/ogre/WebView.cpp:     int localY = overlay->getRelativeY(y);
libproxyobject/plugins/ogre/WebView.cpp:     if(localX > 0 && localX < overlay->width)
libproxyobject/plugins/ogre/WebView.cpp:         if(localY > 0 && localY < overlay->height)
libproxyobject/plugins/ogre/WebView.cpp:     webView->navigateTo(url.data(),url.length());
libproxyobject/plugins/ogre/WebView.cpp:     webView->navigateTo(url.data(),url.length());
libproxyobject/plugins/ogre/WebView.cpp: static std::string htmlPrepend("data:text/html;charset=utf-8,");
libproxyobject/plugins/ogre/WebView.cpp:     webView->navigateTo(data,htmlPrepend.length()+html.length());
libproxyobject/plugins/ogre/WebView.cpp:     webView->executeJavascript(outchars,len);
libproxyobject/plugins/ogre/WebView.cpp:         overlay->setViewport(newViewport);
libproxyobject/plugins/ogre/WebView.cpp:     webView->setTransparent(isTransparent);
libproxyobject/plugins/ogre/WebView.cpp:     this->opacity = opacity;
libproxyobject/plugins/ogre/WebView.cpp:         overlay->setPosition(viewPosition);
libproxyobject/plugins/ogre/WebView.cpp:         overlay->resetPosition();
libproxyobject/plugins/ogre/WebView.cpp:         deltaFadePerMS = -1 / (double)fadeDurationMS;
libproxyobject/plugins/ogre/WebView.cpp:         if (overlay) {overlay->hide();}
libproxyobject/plugins/ogre/WebView.cpp:     if (overlay) {overlay->show();}
libproxyobject/plugins/ogre/WebView.cpp:     webView->focus();
libproxyobject/plugins/ogre/WebView.cpp:     webView->unfocus();
libproxyobject/plugins/ogre/WebView.cpp:         overlay->move(deltaX, deltaY);
libproxyobject/plugins/ogre/WebView.cpp:         return overlay->getRelativeX(absX);
libproxyobject/plugins/ogre/WebView.cpp:         return overlay->getRelativeY(absY);
libproxyobject/plugins/ogre/WebView.cpp:         return overlay->isVisible;
libproxyobject/plugins/ogre/WebView.cpp:         return !overlay->isVisible;
libproxyobject/plugins/ogre/WebView.cpp:         return overlay->isVisible;
libproxyobject/plugins/ogre/WebView.cpp:    if (xPos>mBorderLeft&&yPos>mBorderTop&&xPos<viewWidth-mBorderRight) {
libproxyobject/plugins/ogre/WebView.cpp:        webView->mouseMoved(xPos-mBorderLeft, yPos-mBorderTop);
libproxyobject/plugins/ogre/WebView.cpp:    webView->mouseWheel(relScrollX, relScrollY);
libproxyobject/plugins/ogre/WebView.cpp:    if (xPos>mBorderLeft&&yPos>mBorderTop&&xPos<viewWidth-mBorderRight) {
libproxyobject/plugins/ogre/WebView.cpp:        webView->mouseMoved(xPos-mBorderLeft, yPos-mBorderTop);
libproxyobject/plugins/ogre/WebView.cpp:    webView->mouseButton(0, true);
libproxyobject/plugins/ogre/WebView.cpp:    if (xPos>mBorderLeft&&yPos>mBorderTop&&xPos<viewWidth-mBorderRight) {
libproxyobject/plugins/ogre/WebView.cpp:        webView->mouseMoved(xPos-mBorderLeft, yPos-mBorderTop);
libproxyobject/plugins/ogre/WebView.cpp:        webView->mouseButton(0, false);
libproxyobject/plugins/ogre/WebView.cpp:	webView->keyEvent(press, modifiers, vk_code, scancode);
libproxyobject/plugins/ogre/WebView.cpp:    webView->textEvent(outchars,len);
libproxyobject/plugins/ogre/WebView.cpp:		if(Root::getSingleton().getRenderSystem()->getCapabilities()->hasCapability(RSC_NON_POWER_OF_2_TEXTURES))
libproxyobject/plugins/ogre/WebView.cpp:			if(Root::getSingleton().getRenderSystem()->getCapabilities()->getNonPOW2TexturesLimited())
libproxyobject/plugins/ogre/WebView.cpp:	if (overlay) {overlay->resize(viewWidth, viewHeight);}
libproxyobject/plugins/ogre/WebView.cpp:        webView->resize(viewWidth-mBorderLeft-mBorderRight, viewHeight-mBorderTop-mBorderBottom);
libproxyobject/plugins/ogre/WebView.cpp:        webView->resize(0, 0);
libproxyobject/plugins/ogre/WebView.cpp:            overlay->panel->setUV(u1, v1, u2, v2);
libproxyobject/plugins/ogre/WebView.cpp:	matPass->removeAllTextureUnitStates();
libproxyobject/plugins/ogre/WebView.cpp:	if (!this->viewTexture.isNull()) {
libproxyobject/plugins/ogre/WebView.cpp:        ResourcePtr res(this->viewTexture);
libproxyobject/plugins/ogre/WebView.cpp:        this->viewTexture.setNull();
libproxyobject/plugins/ogre/WebView.cpp:	this->viewTexture = TextureManager::getSingleton().createManual(
libproxyobject/plugins/ogre/WebView.cpp:    TexturePtr texture = this->viewTexture;
libproxyobject/plugins/ogre/WebView.cpp:	HardwarePixelBufferSharedPtr pixelBuffer = texture->getBuffer();
libproxyobject/plugins/ogre/WebView.cpp:	pixelBuffer->lock(HardwareBuffer::HBL_DISCARD);
libproxyobject/plugins/ogre/WebView.cpp:	const PixelBox& pixelBox = pixelBuffer->getCurrentLock();
libproxyobject/plugins/ogre/WebView.cpp:	pixelBuffer->unlock();
libproxyobject/plugins/ogre/WebView.cpp:	if (!this->backingTexture.isNull()) {
libproxyobject/plugins/ogre/WebView.cpp:        ResourcePtr res(this->backingTexture);
libproxyobject/plugins/ogre/WebView.cpp:        this->backingTexture.setNull();
libproxyobject/plugins/ogre/WebView.cpp:        this->backingTexture = TextureManager::getSingleton().createManual(
libproxyobject/plugins/ogre/WebView.cpp:	baseTexUnit = matPass->createTextureUnitState(viewTexture->getName());
libproxyobject/plugins/ogre/WebView.cpp:	baseTexUnit->setTextureFiltering(texFiltering, texFiltering, FO_NONE);
libproxyobject/plugins/ogre/WebView.cpp:		baseTexUnit->setTextureAnisotropy(4);
libproxyobject/plugins/ogre/WebView.cpp:    pixelBufferRect.mHeight=pixelBuffer->getHeight()-mBorderTop-mBorderBottom;
libproxyobject/plugins/ogre/WebView.cpp:    pixelBufferRect.mWidth=pixelBuffer->getWidth()-mBorderLeft-mBorderRight;
libproxyobject/plugins/ogre/WebView.cpp:                HardwarePixelBufferSharedPtr shadowBuffer = shadow->getBuffer();
libproxyobject/plugins/ogre/WebView.cpp:                shadowBuffer->blit(
libproxyobject/plugins/ogre/WebView.cpp:                    Ogre::Box(scrollRect.left()-dx+mBorderLeft, scrollRect.top()+mBorderTop-dy, scrollRect.right()+mBorderLeft-dx, scrollRect.bottom()-dy+mBorderTop),
libproxyobject/plugins/ogre/WebView.cpp:                pixelBuffer->blit(
libproxyobject/plugins/ogre/WebView.cpp:        SILOG(webview,error,"Incoming berkelium size mismatch ["<<pixelBufferRect.left()<<' '<<pixelBufferRect.top()<<'-'<<pixelBufferRect.right()<<' '<<pixelBufferRect.bottom()<<"] != [" <<rect.left()<<' '<<rect.top()<<'-'<<rect.right()<<' '<<rect.bottom()<<"]");
libproxyobject/plugins/ogre/WebView.cpp:    pixelBuffer->blitFromMemory(
libproxyobject/plugins/ogre/WebView.cpp:    HardwarePixelBufferSharedPtr pixelBuffer = texture->getBuffer();
libproxyobject/plugins/ogre/WebView.cpp:    Berkelium::Widget *wid = newwin->getWidget();
libproxyobject/plugins/ogre/WebView.cpp:    if (wid && wid->getRect().mWidth > 0 && wid->getRect().mHeight > 0) {
libproxyobject/plugins/ogre/WebView.cpp:        r = wid->getRect();
libproxyobject/plugins/ogre/WebView.cpp:        overlay?overlay->viewport:WebViewManager::getSingleton().defaultViewport);
libproxyobject/plugins/ogre/WebView.cpp:        if (!where->second.isNull()) {
libproxyobject/plugins/ogre/WebView.cpp:            ResourcePtr mfd(where->second);
libproxyobject/plugins/ogre/WebView.cpp:        viewTexture->getBuffer()->blit(backingTexture->getBuffer(),
libproxyobject/plugins/ogre/WebView.cpp:                                       Ogre::Box(0,0,viewTexture->getWidth(),viewTexture->getHeight()),
libproxyobject/plugins/ogre/WebView.cpp:                                       Ogre::Box(0,0,viewTexture->getWidth(),viewTexture->getHeight()));
libproxyobject/plugins/ogre/WebView.cpp:        int minwid=old->getWidth()<(unsigned int)w?old->getWidth():w;
libproxyobject/plugins/ogre/WebView.cpp:        int minhei=old->getHeight()<(unsigned int)h?old->getHeight():h;
libproxyobject/plugins/ogre/WebView.cpp:        tmp->getBuffer()->blit(old->getBuffer(),Ogre::Box(0,0,minwid,minhei),Ogre::Box(0,0,minwid,minhei));
libproxyobject/plugins/ogre/WebView.cpp:/*        viewBuffer->blit(backingBuffer,
libproxyobject/plugins/ogre/WebView.cpp:                         Ogre::Box(0,0,viewTexture->getWidth(),viewTexture->getHeight()),
libproxyobject/plugins/ogre/WebView.cpp:                         Ogre::Box(0,0,viewTexture->getWidth(),viewTexture->getHeight()));
libproxyobject/plugins/ogre/WebView.cpp:        viewTexture->getBuffer()->blit(backingTexture->getBuffer(),
libproxyobject/plugins/ogre/WebView.cpp:                                       Ogre::Box(0,0,viewTexture->getWidth(),viewTexture->getHeight()),
libproxyobject/plugins/ogre/WebView.cpp:                                       Ogre::Box(0,0,viewTexture->getWidth(),viewTexture->getHeight()));
libproxyobject/plugins/ogre/WebView.cpp:        for (Berkelium::Window::BackToFrontIter i=win->backIter(),ie=win->backEnd();
libproxyobject/plugins/ogre/WebView.cpp:                if (!where->second.isNull()){
libproxyobject/plugins/ogre/WebView.cpp:                    Berkelium::Rect rect=(*i)->getRect();
libproxyobject/plugins/ogre/WebView.cpp:                    SILOG(webkit,warning,"Blitting to "<<rect.left()<<","<<rect.top()<<" - "<<rect.right()<<","<<rect.bottom());
libproxyobject/plugins/ogre/WebView.cpp:					windowRect.mHeight = viewTexture->getBuffer()->getHeight();
libproxyobject/plugins/ogre/WebView.cpp:					windowRect.mWidth = viewTexture->getBuffer()->getWidth();
libproxyobject/plugins/ogre/WebView.cpp:					srcRect.mTop = rect.mTop - srcRect.mTop;
libproxyobject/plugins/ogre/WebView.cpp:					srcRect.mLeft = rect.mLeft - srcRect.mLeft;
libproxyobject/plugins/ogre/WebView.cpp:                    viewTexture->getBuffer()->blit(where->second->getBuffer(),
libproxyobject/plugins/ogre/WebView.cpp:            TEX_TYPE_2D, viewTexture->getWidth(), viewTexture->getHeight(), 0, PF_BYTE_BGRA,
libproxyobject/plugins/ogre/WebView.cpp:        HardwarePixelBufferSharedPtr viewBuffer = viewTexture->getBuffer();
libproxyobject/plugins/ogre/WebView.cpp:        HardwarePixelBufferSharedPtr backingBuffer = backingTexture->getBuffer();
libproxyobject/plugins/ogre/WebView.cpp:        backingBuffer->blit(viewBuffer,
libproxyobject/plugins/ogre/WebView.cpp:                            Ogre::Box(0,0,viewTexture->getWidth(),viewTexture->getHeight()),
libproxyobject/plugins/ogre/WebView.cpp:                            Ogre::Box(0,0,viewTexture->getWidth(),viewTexture->getHeight()));
libproxyobject/plugins/ogre/WebView.cpp:        onWidgetResize(win,wid,wid->getRect().width(),wid->getRect().height());
libproxyobject/plugins/ogre/WebView.cpp:    blitNewImage(widgetTex->getBuffer(),sourceBuffer,rect,dx,dy,scrollRect);
libproxyobject/plugins/ogre/WebView.cpp:		i->second(this, argVector);
libproxyobject/plugins/ogre/OgreConversions.hpp:    return (pos - base).downCast<Ogre::Real>().convert<Ogre::Vector3>();
libproxyobject/plugins/ogre/CameraPath.cpp: *  Copyright (c) 2009, Ewen Cheslack-Postava
libproxyobject/plugins/ogre/CameraPath.cpp:    return empty() ? DeltaTime::zero() : (*this)[numPoints()-1].time;
libproxyobject/plugins/ogre/CameraPath.cpp:    if (idx >= (int32)numPoints()) return numPoints()-1;
libproxyobject/plugins/ogre/CameraPath.cpp:        SILOG(ogre,error,"Error loading camera path -- file doesn't exist");
libproxyobject/plugins/ogre/CameraPath.cpp:        SILOG(ogre,error,"Error loading camera path -- couldn't open file");
libproxyobject/plugins/ogre/CameraPath.cpp:        SILOG(ogre,error,"Error saving camera path -- couldn't open file");
libproxyobject/plugins/ogre/CameraPath.cpp:        uint32 min_idx = clampKeyIndex(idx - k);
libproxyobject/plugins/ogre/CameraPath.cpp:        double didx = (double)(max_idx - min_idx + 1);
libproxyobject/plugins/ogre/CameraPath.cpp:        DeltaTime dt = max_time - min_time;
libproxyobject/plugins/ogre/CameraPath.cpp:            difft = (keyFrameTime(i) - t).toSeconds();
libproxyobject/plugins/ogre/CameraPath.cpp:            difft = (t - keyFrameTime(i)).toSeconds();
libproxyobject/plugins/ogre/CameraPath.cpp:        float weight = (float)exp( - difft * difft / (stddev*stddev));
libproxyobject/plugins/ogre/input/SDLInputDevice.hpp:/*  Sirikata Input Plugin -- plugins/input
libproxyobject/plugins/ogre/input/SDLInputDevice.hpp:            return "screll-x";
libproxyobject/plugins/ogre/input/SDLInputDevice.hpp:            return "scroll-y";
libproxyobject/plugins/ogre/input/SDLInputDevice.hpp:    // Full keyboard--pointless to list all the possible buttons.
libproxyobject/plugins/ogre/input/SDLInputDevice.hpp:    virtual int getNumButtons() const { return -1; }
libproxyobject/plugins/ogre/input/SDLInputManager.hpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/input/SDLInputManager.hpp:        width = this->mWidth;
libproxyobject/plugins/ogre/input/SDLInputManager.hpp:        height = this->mHeight;
libproxyobject/plugins/ogre/input/InputEvents.cpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/input/InputEvents.cpp:    WindowEventType t = (WindowEventType)-1;
libproxyobject/plugins/ogre/input/InputEvents.cpp:        args.reserve(jsargs.size()-1);
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:        //  window". We have to fake a window-move to allow SDL
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:        mWheelToAxis=new OptionValue("wheelpct","0.008",OptionValueType<float>(),"Percentage points for each wheel tick (platform-dependent)."),
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:		mKeys.back()->setInputManager(this);
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:		mMice.back()->setInputManager(this);
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:		mJoy.back()->setInputManager(this);
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:        switch(event->type)
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:            mKeys[event->key.which]->fireButton(
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                mKeys[event->key.which],
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                (unsigned int)event->key.keysym.scancode,
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                (event->key.state == SDL_PRESSED),
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                modifiersFromSDL(event->key.keysym.mod));
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:            mMice[event->button.which]->fireButton(
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                mMice[event->button.which],
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                event->button.button,
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                (event->button.state == SDL_PRESSED),
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                (1<<SDL_GetCurrentCursor(event->button.which))>>1);
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:            mMice[event->button.which]->firePointerClick(
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                mMice[event->button.which],
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                (2.0*(float)event->button.x)/mWidth - 1,
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                1 - (2.0*(float)event->button.y)/mHeight,
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                SDL_GetCurrentCursor(event->button.which),
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                event->button.button,
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                event->button.state == SDL_PRESSED);
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:            mJoy[event->jbutton.which]->fireButton(
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                mJoy[event->jbutton.which],
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                event->jbutton.button,
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                event->jbutton.state == SDL_PRESSED);
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                                    mKeys[event->text.which],
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                                    event->text.text)));
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:            mMice[event->motion.which]->fireMotion(
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                mMice[event->motion.which],
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                event->motion);
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:            mMice[event->wheel.which]->fireWheel(
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                mMice[event->wheel.which],
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                event->wheel.x,
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                event->wheel.y);
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:            mJoy[event->wheel.which]->fireAxis(
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                mJoy[event->wheel.which],
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                event->jaxis.axis,
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                AxisValue::fromCentered(event->jaxis.value/32767.));
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:            mJoy[event->wheel.which]->fireHat(
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                mJoy[event->wheel.which],
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                event->jhat.hat,
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                event->jhat.value);
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:            mJoy[event->wheel.which]->fireBall(
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                mJoy[event->wheel.which],
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                event->jball.ball,
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                event->jball.xrel,
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                event->jball.yrel);
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:				  SDL_SysWMmsg *msg = event->syswm.msg;
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:				  // Drag-and-drop is windows only for now.
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:				  switch (msg->msg) {
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:					  HDROP hDrop = (HDROP)msg->wParam;
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                    getWindowEventId((SDL_WindowEventID)event->window.event),
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                    event->window.data1,
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:                    event->window.data2)));
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:			if (event->window.event==SDL_WINDOWEVENT_CLOSE) {
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:            if (event->window.event==SDL_WINDOWEVENT_FOCUS_LOST) {
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:            if (event->window.event==SDL_WINDOWEVENT_FOCUS_GAINED) {
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:            fire(Task::EventPtr(new WindowEvent(WindowEvent::Quit, -1, -1)));
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:    int oldmouse = SDL_SelectMouse(-1);
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:        if (mMice[i]->getRelativeMode()) {
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:            int x = mMice[i]->getAxis(PointerDevice::CURSORX).get01() * mWidth;
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:            int y = mMice[i]->getAxis(PointerDevice::CURSORY).get01() * mHeight;
libproxyobject/plugins/ogre/input/SDLInputManager.cpp:    getWorkQueue()->dequeueUntil(Task::LocalTime::now()+Duration::seconds(.01));
libproxyobject/plugins/ogre/input/SDLInputDevice.cpp:/*  Sirikata Input Plugin -- plugins/input
libproxyobject/plugins/ogre/input/SDLInputDevice.cpp:    manager->getWindowSize(wid,hei);
libproxyobject/plugins/ogre/input/SDLInputDevice.cpp:    float drag_deadband (manager->mDragDeadband->as<float>());
libproxyobject/plugins/ogre/input/SDLInputDevice.cpp:    em->getWindowSize(screenwid, screenhei);
libproxyobject/plugins/ogre/input/SDLInputDevice.cpp:    AxisValue yPctFromCenter = AxisValue::from01(1-(event.y / float(screenhei)));
libproxyobject/plugins/ogre/input/SDLInputDevice.cpp:        // negate y axis since coordinates start at bottom-left.
libproxyobject/plugins/ogre/input/SDLInputDevice.cpp:        float to_axis(em->mRelativeMouseToAxis->as<float>());
libproxyobject/plugins/ogre/input/SDLInputDevice.cpp:        fireAxis(thisptr, em, AXIS_RELY, AxisValue::fromCentered(-to_axis*event.yrel));
libproxyobject/plugins/ogre/input/SDLInputDevice.cpp:                          -event.yrel/float(screenhei), event.cursor,
libproxyobject/plugins/ogre/input/SDLInputDevice.cpp:    float to_axis (em->mWheelToAxis->as<float>());
libproxyobject/plugins/ogre/input/SDLInputDevice.cpp:    this->mJoy = SDL_JoystickOpen(whichDevice);
libproxyobject/plugins/ogre/input/SDLInputDevice.cpp:        unsigned int ballaxis = axis - mNumGeneralAxes;
libproxyobject/plugins/ogre/input/SDLInputDevice.cpp:    this->fireButton(thisptr, em, mNumButtons + HAT_MAX*num + HAT_UP, !!(val & SDL_HAT_UP));
libproxyobject/plugins/ogre/input/SDLInputDevice.cpp:    this->fireButton(thisptr, em, mNumButtons + HAT_MAX*num + HAT_RIGHT, !!(val & SDL_HAT_RIGHT));
libproxyobject/plugins/ogre/input/SDLInputDevice.cpp:    this->fireButton(thisptr, em, mNumButtons + HAT_MAX*num + HAT_DOWN, !!(val & SDL_HAT_DOWN));
libproxyobject/plugins/ogre/input/SDLInputDevice.cpp:    this->fireButton(thisptr, em, mNumButtons + HAT_MAX*num + HAT_LEFT, !!(val & SDL_HAT_LEFT));
libproxyobject/plugins/ogre/input/SDLInputDevice.cpp:    float to_axis (em->mJoyBallToAxis->as<float>());
libproxyobject/plugins/ogre/input/SDLInputDevice.cpp:        int hatbutton = button - mNumButtons;
libproxyobject/plugins/ogre/input/InputDevice.cpp:/*  Sirikata Input Plugin -- plugins/input
libproxyobject/plugins/ogre/input/InputDevice.cpp:                em->fire(EventPtr(new ButtonReleased(thisptr, button, oldmodifiers)));
libproxyobject/plugins/ogre/input/InputDevice.cpp:            em->fire(EventPtr(new ButtonPressed(thisptr, button, modifiers)));
libproxyobject/plugins/ogre/input/InputDevice.cpp:            em->fire(EventPtr(new ButtonReleased(thisptr, button, oldmodifiers)));
libproxyobject/plugins/ogre/input/InputDevice.cpp:        em->fire(EventPtr(new AxisEvent(thisptr, axis, newState)));
libproxyobject/plugins/ogre/input/InputDevice.cpp:        em->fire(EventPtr(
libproxyobject/plugins/ogre/input/InputDevice.cpp:            em->fire(EventPtr(
libproxyobject/plugins/ogre/input/InputDevice.cpp:            em->fire(EventPtr(
libproxyobject/plugins/ogre/input/InputDevice.cpp:        em->fire(EventPtr(new MouseHoverEvent(thisptr, xPixelArg, yPixelArg, cursorType)));
libproxyobject/plugins/ogre/input/InputDevice.cpp:                    float xdiff = (xPixel - di.mDragStartX);
libproxyobject/plugins/ogre/input/InputDevice.cpp:                    float ydiff = (yPixel - di.mDragStartY);
libproxyobject/plugins/ogre/input/InputDevice.cpp:                em->fire(EventPtr(new MouseDragEvent(
libproxyobject/plugins/ogre/input/InputDevice.cpp:                di.mOffsetX += di.mDragX - xPixel;
libproxyobject/plugins/ogre/input/InputDevice.cpp:                di.mOffsetY += di.mDragY - yPixel;
libproxyobject/plugins/ogre/input/ButtonToAxis.hpp:/*  Sirikata Input Plugin -- plugins/input
libproxyobject/plugins/ogre/input/ButtonToAxis.hpp:/** Mostly for hatswitches or d-pad's on a joystick. */
libproxyobject/plugins/ogre/input/ButtonToAxis.hpp:        std::ostringstream os ("[" + mParentDevice->getAxisName(mParentAxis) + " ");
libproxyobject/plugins/ogre/input/ButtonToAxis.hpp:        std::string os = "[" + mParentDevice->getName() + " ";
libproxyobject/plugins/ogre/input/ButtonToAxis.hpp:            os += mParentDevice->getButtonName((*iter).first);
libproxyobject/plugins/ogre/input/InputDevice.hpp:/*  Sirikata Input Plugin -- plugins/input
libproxyobject/plugins/ogre/input/InputDevice.hpp:Choose two analog inputs and one keyboard/joystick->key bindings
libproxyobject/plugins/ogre/input/InputDevice.hpp:        AxisValue ret = {(val-0.5f)*2.0f};
libproxyobject/plugins/ogre/input/InputDevice.hpp:        if (value < -1.0) {
libproxyobject/plugins/ogre/input/InputDevice.hpp:            value = -1.0;
libproxyobject/plugins/ogre/input/InputDevice.hpp:    AxisValue operator - () const {
libproxyobject/plugins/ogre/input/InputDevice.hpp:        return fromCentered(-getCentered());
libproxyobject/plugins/ogre/input/InputDevice.hpp:    the DRAG_DEADBAND state -- in this case, see MouseClickEvent.
libproxyobject/plugins/ogre/input/InputDevice.hpp:            if (--mRelativeMode == 0) {
libproxyobject/plugins/ogre/input/InputManager.hpp:/*  Sirikata Input Plugin -- plugins/input
libproxyobject/plugins/ogre/input/InputEvents.hpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/input/InputEvents.hpp:    not take into account relative (per-frame) versus absolute axes.
libproxyobject/plugins/ogre/input/InputEvents.hpp:    mText is always a UTF-8 formatted string, not a scancode.
libproxyobject/plugins/ogre/input/InputEvents.hpp:    contains 2-key sequences for complicated characters, like Multi+a+e
libproxyobject/plugins/ogre/input/InputEvents.hpp:    produces the "ae" digraph.  mText will contain the single UTF-8
libproxyobject/plugins/ogre/input/InputEvents.hpp:    std::string mText; ///< UTF-8 formatted string to be appended to an input box.
libproxyobject/plugins/ogre/input/InputEvents.hpp:    float mX; ///< X coordinate, from -1 (left) to 1 (right), same as AxisEvent
libproxyobject/plugins/ogre/input/InputEvents.hpp:    float mY; ///< Y coordinate, from -1 (bottom) to 1 (top), same as AxisEvent
libproxyobject/plugins/ogre/input/InputEvents.hpp:    int mCursorType; ///< Platform-dependent value as defined by SDL.
libproxyobject/plugins/ogre/input/InputEvents.hpp:    float mXStart; ///< X coordinate when the mouse button was first pressed, -1 to 1
libproxyobject/plugins/ogre/input/InputEvents.hpp:    float mYStart; ///< Y coordinate when the mouse button was pressed, -1 to 1
libproxyobject/plugins/ogre/input/InputEvents.hpp:    /** mX - mXStart: Returns a value between -1 and 1 */
libproxyobject/plugins/ogre/input/InputEvents.hpp:        return (mX - mXStart)/2.0f;
libproxyobject/plugins/ogre/input/InputEvents.hpp:    /** mY - mYStart: Returns a value between -1 and 1 */
libproxyobject/plugins/ogre/input/InputEvents.hpp:        return (mY - mYStart)/2.0f;
libproxyobject/plugins/ogre/input/InputEvents.hpp:        return (mY - mLastY)/2.0f;
libproxyobject/plugins/ogre/input/InputEvents.hpp:        return (mX - mLastX)/2.0f;
libproxyobject/plugins/ogre/input/InputEvents.hpp:/** Various SDL-specific events relating to the status of the
libproxyobject/plugins/ogre/input/InputEvents.hpp:    top-level window. */
libproxyobject/plugins/ogre/input/InputEventDescriptor.cpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/input/InputEventDescriptor.cpp: *  Copyright (c) 2009, Ewen Cheslack-Postava
libproxyobject/plugins/ogre/input/InputEventDescriptor.cpp:        return mDescriptor.web.wvname->compare(*rhs.mDescriptor.web.wvname) < 0 ||
libproxyobject/plugins/ogre/input/InputEventDescriptor.cpp:            (mDescriptor.web.wvname->compare(*rhs.mDescriptor.web.wvname) == 0 &&
libproxyobject/plugins/ogre/input/InputEventDescriptor.cpp:                (mDescriptor.web.name->compare(*rhs.mDescriptor.web.name) < 0
libproxyobject/plugins/ogre/input/InputEventDescriptor.hpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/input/InputEventDescriptor.hpp: *  Copyright (c) 2009, Ewen Cheslack-Postava
libproxyobject/plugins/ogre/WebView.hpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/WebView.hpp:		* example an animated 'dock' with floating icons on a transparent background: the mouse-out event would never
libproxyobject/plugins/ogre/WebView.hpp:		* Using alpha-masking/transparency doesn't just affect the visuals of a WebView; by default, WebViews 'ignore'
libproxyobject/plugins/ogre/WebView.hpp:		* @param ignoreTrans Whether or not this WebView should ignore 'transparent' areas when mouse-picking.
libproxyobject/plugins/ogre/WebView.hpp:		* Transforms an X-coordinate in screen-space to that of this WebView's relative space.
libproxyobject/plugins/ogre/WebView.hpp:		* @param	absX	The X-coordinate in screen-space to transform.
libproxyobject/plugins/ogre/WebView.hpp:		* @return	The X-coordinate in this WebView's relative space.
libproxyobject/plugins/ogre/WebView.hpp:		* Transforms a Y-coordinate in screen-space to that of this WebView's relative space.
libproxyobject/plugins/ogre/WebView.hpp:		* @param absY The Y-coordinate in screen-space to transform.
libproxyobject/plugins/ogre/WebView.hpp:		* @return The Y-coordinate in this WebView's relative space.
libproxyobject/plugins/ogre/WebView.hpp:		* NPOT-support on the videocard by using the next-highest POT texture. Normal WebViews compensate their UV's accordingly
libproxyobject/plugins/ogre/WebView.hpp:		* @param[out]	u1	The Ogre::Real that will be used to store the retrieved u1-coordinate.
libproxyobject/plugins/ogre/WebView.hpp:		* @param[out]	v1	The Ogre::Real that will be used to store the retrieved v1-coordinate.
libproxyobject/plugins/ogre/WebView.hpp:		* @param[out]	u2	The Ogre::Real that will be used to store the retrieved u2-coordinate.
libproxyobject/plugins/ogre/WebView.hpp:		* @param[out]	v2	The Ogre::Real that will be used to store the retrieved v2-coordinate.
libproxyobject/plugins/ogre/WebView.hpp:		* @param	xPos	The X-coordinate of the mouse, relative to this WebView's origin.
libproxyobject/plugins/ogre/WebView.hpp:		* @param	yPos	The Y-coordinate of the mouse, relative to this WebView's origin.
libproxyobject/plugins/ogre/WebView.hpp:		* @param	xPos	The absolute X-Value of the mouse, relative to this WebView's origin.
libproxyobject/plugins/ogre/WebView.hpp:		* @param	yPos	The absolute Y-Value of the mouse, relative to this WebView's origin.
libproxyobject/plugins/ogre/WebView.hpp:		* @param	xPos	The absolute X-Value of the mouse, relative to this WebView's origin.
libproxyobject/plugins/ogre/WebView.hpp:		* @param	yPos	The absolute Y-Value of the mouse, relative to this WebView's origin.
libproxyobject/plugins/ogre/WebView.hpp:        ///The left border of the frame around the window. Chrome is told about a window that's viewWidth-mBorderLeft-mBorderRight. May be 0
libproxyobject/plugins/ogre/WebView.hpp:        ///The right border of the frame around the window. Chrome is told about a window that's viewWidth-mBorderLeft-mBorderRight. May be 0
libproxyobject/plugins/ogre/WebView.hpp:        ///The top border/titlebar of the frame around the window. Chrome is told about a window that's viewWidth-mBorderLeft-mBorderRight. May be 0
libproxyobject/plugins/ogre/WebView.hpp:        ///The bottom border of the frame around the window. Chrome is told about a window that's viewWidth-mBorderLeft-mBorderRight.  May be 0
libproxyobject/plugins/ogre/WebView.hpp:     * a negative z-index (i.e. below anything else on the screen).
libproxyobject/plugins/ogre/MeshEntity.cpp~:                 id.length()?id:ogreMeshName(pmo->getObjectReference()),
libproxyobject/plugins/ogre/MeshEntity.cpp~:        (grm->getResourceEntity(pmo->getObjectReference(), this));
libproxyobject/plugins/ogre/MeshEntity.cpp~:    mResource->entityDestroyed();
libproxyobject/plugins/ogre/MeshEntity.cpp~:        getScene()->getSceneManager()->destroyEntity(toDestroy);
libproxyobject/plugins/ogre/MeshEntity.cpp~:		if (tus->getTextureName() == mFrom) {
libproxyobject/plugins/ogre/MeshEntity.cpp~:			tus->setTextureName(mTo);
libproxyobject/plugins/ogre/MeshEntity.cpp~:		if (mFrom.find(tus->getTextureName()) != mFrom.end()) {
libproxyobject/plugins/ogre/MeshEntity.cpp~:	int numTechniques = material->getNumTechniques();
libproxyobject/plugins/ogre/MeshEntity.cpp~:		Ogre::Technique *tech = material->getTechnique(whichTechnique);
libproxyobject/plugins/ogre/MeshEntity.cpp~:		int numPasses = tech->getNumPasses();
libproxyobject/plugins/ogre/MeshEntity.cpp~:			Ogre::Pass *pass = tech->getPass(whichPass);
libproxyobject/plugins/ogre/MeshEntity.cpp~:			int numTUS = pass->getNumTextureUnitStates();
libproxyobject/plugins/ogre/MeshEntity.cpp~:				Ogre::TextureUnitState *tus = pass->getTextureUnitState(whichTUS);
libproxyobject/plugins/ogre/MeshEntity.cpp~:	if (whichSubEnt >= (int)(ent->getNumSubEntities()) || whichSubEnt < 0) {
libproxyobject/plugins/ogre/MeshEntity.cpp~:		WebView *wv = WebViewManager::getSingleton().getWebView(iter->second.first);
libproxyobject/plugins/ogre/MeshEntity.cpp~:	int numSubEntities = ent->getNumSubEntities();
libproxyobject/plugins/ogre/MeshEntity.cpp~:		int whichSubEntity = iter->first;
libproxyobject/plugins/ogre/MeshEntity.cpp~:		Ogre::SubEntity *subEnt = ent->getSubEntity(whichSubEntity);
libproxyobject/plugins/ogre/MeshEntity.cpp~:		Ogre::MaterialPtr origMaterial = iter->second.second;
libproxyobject/plugins/ogre/MeshEntity.cpp~:		subEnt->setMaterial(origMaterial);
libproxyobject/plugins/ogre/MeshEntity.cpp~:		Ogre::SubEntity *subEnt = ent->getSubEntity(whichSubEntity);
libproxyobject/plugins/ogre/MeshEntity.cpp~:		Ogre::MaterialPtr material = subEnt->getMaterial();
libproxyobject/plugins/ogre/MeshEntity.cpp~:			Ogre::MaterialPtr newMaterial = material->clone(material->getName()+id().toString(), false, Ogre::String());
libproxyobject/plugins/ogre/MeshEntity.cpp~:				SILOG(ogre,debug,"Replacing a texture "<<id()<<" : "<<iter->first<<" -> "<<iter->second);
libproxyobject/plugins/ogre/MeshEntity.cpp~:				forEachTexture(newMaterial, ReplaceTexture(iter->first, iter->second));
libproxyobject/plugins/ogre/MeshEntity.cpp~:				newTexture = iter->second;
libproxyobject/plugins/ogre/MeshEntity.cpp~:			subEnt->setMaterial(newMaterial);
libproxyobject/plugins/ogre/MeshEntity.cpp~:        new_entity = getScene()->getSceneManager()->createEntity(
libproxyobject/plugins/ogre/MeshEntity.cpp~:        new_entity = getScene()->getSceneManager()->createEntity(ogreMovableName(),Ogre::SceneManager::PT_CUBE);
libproxyobject/plugins/ogre/MeshEntity.cpp~:            getScene()->getSceneManager()->destroyEntity(oldMeshObj);
libproxyobject/plugins/ogre/MeshEntity.cpp~:    SILOG(ogre,debug,"Bounding box: " << new_entity->getBoundingBox());
libproxyobject/plugins/ogre/MeshEntity.cpp~:        new_entity->setMaterialName("BaseWhiteTexture");
libproxyobject/plugins/ogre/MeshEntity.cpp~:    unsigned int num_subentities=new_entity->getNumSubEntities();
libproxyobject/plugins/ogre/MeshEntity.cpp~:    Ogre::Vector4 parallax_steps(getScene()->mParallaxSteps->as<float>(),getScene()->mParallaxShadowSteps->as<int>(),0.0,1.0);
libproxyobject/plugins/ogre/MeshEntity.cpp~:        new_entity->getSubEntity(subent)->setCustomParameter(0,random_values);
libproxyobject/plugins/ogre/MeshEntity.cpp~:        new_entity->getSubEntity(subent)->setCustomParameter(1,parallax_steps);
libproxyobject/plugins/ogre/MeshEntity.cpp~:        getScene()->getSceneManager()->destroyEntity(oldMeshObj);
libproxyobject/plugins/ogre/MeshEntity.cpp~:    //init(getScene()->getSceneManager()->createEntity(ogreMovableName(), Ogre::SceneManager::PT_CUBE));
libproxyobject/plugins/ogre/MeshEntity.cpp~:        getScene()->getSceneManager()->destroyEntity(meshObj);
libproxyobject/plugins/ogre/MeshEntity.cpp~:    /// hack to support collada mesh -- eventually this should be smarter
libproxyobject/plugins/ogre/MeshEntity.cpp~:    if (fn.rfind(".dae")==fn.size()-4) is_collada=true;
libproxyobject/plugins/ogre/MeshEntity.cpp~:        Meru::SharedResourcePtr newModelPtr = grm->getResourceAsset ( meshFile, Meru::GraphicsResource::MODEL );
libproxyobject/plugins/ogre/MeshEntity.cpp~:        mResource->setMeshResource ( newModelPtr );
libproxyobject/plugins/ogre/MeshEntity.cpp~:        Meru::SharedResourcePtr newMeshPtr = grm->getResourceAsset ( meshFile, Meru::GraphicsResource::MESH );
libproxyobject/plugins/ogre/MeshEntity.cpp~:        mResource->setMeshResource ( newMeshPtr );
libproxyobject/plugins/ogre/MeshEntity.cpp~:    if (up==3) return Vector3f(v[0],v[2], -v[1]);
libproxyobject/plugins/ogre/MeshEntity.cpp~:        Ogre::MaterialPtr mat = base_mat->clone(matname);
libproxyobject/plugins/ogre/MeshEntity.cpp~:        mat->getTechnique(0)->getPass(0)->createTextureUnitState("Cache/" + mTextureFingerprints[texURI], 0);
libproxyobject/plugins/ogre/MeshEntity.cpp~:            base_mat->getName();
libproxyobject/plugins/ogre/MeshEntity.cpp~:                tv = 1.0-uv[1];           //  why you gotta be like that?
libproxyobject/plugins/ogre/MeshEntity.cpp~:    loadMesh(hash);                     /// this is here because we removed  mResource->loaded(true, mEpoch) in  ModelLoadTask::doRun
libproxyobject/plugins/ogre/MeshEntity.cpp~:    if ((int)ev->getStatus())
libproxyobject/plugins/ogre/MeshEntity.cpp~:        << " status: " << (int)ev->getStatus()
libproxyobject/plugins/ogre/MeshEntity.cpp~:        << " fingerprint: " << ev->fingerprint()
libproxyobject/plugins/ogre/MeshEntity.cpp~:        << " length: " << (int)ev->data().length()
libproxyobject/plugins/ogre/MeshEntity.cpp~:    SILOG(ogre,fatal,ev->uri().toString() << " -> " << ev->fingerprint().convertToHexString());
libproxyobject/plugins/ogre/MeshEntity.cpp~:    mTextureFingerprints[ev->uri().toString()] = ev->fingerprint().convertToHexString();
libproxyobject/plugins/ogre/MeshEntity.cpp~:    mRemainingDownloads--;
libproxyobject/plugins/ogre/MeshEntity.cpp~:        mScene->mTransferManager->download(
libproxyobject/plugins/ogre/MeshEntity.cpp~:    mSceneNode->setScale ( toOgre ( scale ) );
libproxyobject/plugins/ogre/InputBinding.hpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/InputBinding.hpp: *  Copyright (c) 2009, Ewen Cheslack-Postava
libproxyobject/plugins/ogre/OgreSystem.cpp~:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/OgreSystem.cpp~:volatile char assert_thread_support_is_gequal_2[OGRE_THREAD_SUPPORT*2-3]={0};
libproxyobject/plugins/ogre/OgreSystem.cpp~:volatile char assert_thread_support_is_lequal_2[5-OGRE_THREAD_SUPPORT*2]={0};
libproxyobject/plugins/ogre/OgreSystem.cpp~://volatile char assert_malloc_is_gequal_1[OGRE_MEMORY_ALLOCATOR*2-1]={0};
libproxyobject/plugins/ogre/OgreSystem.cpp~://volatile char assert_malloc_is_lequal_1[3-OGRE_MEMORY_ALLOCATOR*2]={0};
libproxyobject/plugins/ogre/OgreSystem.cpp~:    if (mRenderTarget->getName()==name) {
libproxyobject/plugins/ogre/OgreSystem.cpp~:        name=mRenderTarget->getName();
libproxyobject/plugins/ogre/OgreSystem.cpp~:    if (width==0) width=mWindowWidth->as<uint32>();
libproxyobject/plugins/ogre/OgreSystem.cpp~:    if (height==0) height=mWindowHeight->as<uint32>();
libproxyobject/plugins/ogre/OgreSystem.cpp~:    return createRenderTarget(name,width,height,true,mWindowDepth->as<Ogre::PixelFormat>());
libproxyobject/plugins/ogre/OgreSystem.cpp~:    if (mRenderTarget&&mRenderTarget->getName()==name) {
libproxyobject/plugins/ogre/OgreSystem.cpp~:    }else if (sRenderTarget&&sRenderTarget->getName()==name) {
libproxyobject/plugins/ogre/OgreSystem.cpp~:            return texptr->getBuffer()->getRenderTarget();
libproxyobject/plugins/ogre/OgreSystem.cpp~:                width=texptr->getWidth();
libproxyobject/plugins/ogre/OgreSystem.cpp~:                height=texptr->getHeight();
libproxyobject/plugins/ogre/OgreSystem.cpp~:                uint32 nummipmaps=texptr->getNumMipmaps();
libproxyobject/plugins/ogre/OgreSystem.cpp~:                pf=texptr->getFormat();
libproxyobject/plugins/ogre/OgreSystem.cpp~:                return texptr->getBuffer()->getRenderTarget();
libproxyobject/plugins/ogre/OgreSystem.cpp~:        for (i = settings->begin(); i != settings->end(); ++i)
libproxyobject/plugins/ogre/OgreSystem.cpp~:            typeName = i->first;
libproxyobject/plugins/ogre/OgreSystem.cpp~:            archName = i->second;
libproxyobject/plugins/ogre/OgreSystem.cpp~:    proxyManager->addListener(this);
libproxyobject/plugins/ogre/OgreSystem.cpp~:                           mParallaxSteps=new OptionValue("parallax-steps","1.0",OptionValueType<float>(),"Multiplies the per-material parallax steps by this constant (default 1.0)"),
libproxyobject/plugins/ogre/OgreSystem.cpp~:                           mParallaxShadowSteps=new OptionValue("parallax-shadow-steps","10",OptionValueType<int>(),"Total number of steps for shadow parallax mapping (default 10)"),
libproxyobject/plugins/ogre/OgreSystem.cpp~:    (mOptions=OptionSet::getOptions("ogregraphics",this))->parse(options);
libproxyobject/plugins/ogre/OgreSystem.cpp~:    mTransferManager = (Transfer::TransferManager*)transferManager->as<void*>();
libproxyobject/plugins/ogre/OgreSystem.cpp~:    static bool success=((sRoot=OGRE_NEW Ogre::Root(pluginFile->as<String>(),configFile->as<String>(),ogreLogFile->as<String>()))!=NULL
libproxyobject/plugins/ogre/OgreSystem.cpp~:                         &&((purgeConfig->as<bool>()==false&&getRoot()->restoreConfig())
libproxyobject/plugins/ogre/OgreSystem.cpp~:                            || (userAccepted=getRoot()->showConfigDialog())));
libproxyobject/plugins/ogre/OgreSystem.cpp~:        if (!getRoot()->isInitialised()) {
libproxyobject/plugins/ogre/OgreSystem.cpp~:            sRoot->initialise(doAutoWindow,windowTitle->as<String>());
libproxyobject/plugins/ogre/OgreSystem.cpp~:            Ogre::RenderWindow *rw=(doAutoWindow?sRoot->getAutoCreatedWindow():NULL);
libproxyobject/plugins/ogre/OgreSystem.cpp~:            Meru::EventSource::sSingleton = ((Task::GenEventManager*)eventManager->as<void*>());
libproxyobject/plugins/ogre/OgreSystem.cpp~:            new SequentialWorkQueue ((Task::WorkQueue*)workQueue->as<void*>());
libproxyobject/plugins/ogre/OgreSystem.cpp~:            sRoot->installPlugin(&*mCDNArchivePlugin);
libproxyobject/plugins/ogre/OgreSystem.cpp~:                    if (mFullScreen->as<bool>()==false) {//does not work in fullscreen
libproxyobject/plugins/ogre/OgreSystem.cpp~:                    sRenderTarget=mRenderTarget=static_cast<Ogre::RenderTarget*>(rw=getRoot()->createRenderWindow(windowTitle->as<String>(),mWindowWidth->as<uint32>(),mWindowHeight->as<uint32>(),mFullScreen->as<bool>(),&misc));
libproxyobject/plugins/ogre/OgreSystem.cpp~:                    rw->setVisible(true);
libproxyobject/plugins/ogre/OgreSystem.cpp~:                rw->getCustomAttribute("WINDOW",&hWnd);
libproxyobject/plugins/ogre/OgreSystem.cpp~:                SILOG(ogre,warning,"Setting window width from "<<mWindowWidth->as<uint32>()<< " to "<<rw->getWidth()<<'\n'<<"Setting window height from "<<mWindowHeight->as<uint32>()<< " to "<<rw->getHeight()<<'\n');
libproxyobject/plugins/ogre/OgreSystem.cpp~:                *mWindowWidth->get()=Any(rw->getWidth());
libproxyobject/plugins/ogre/OgreSystem.cpp~:                *mWindowHeight->get()=Any(rw->getHeight());
libproxyobject/plugins/ogre/OgreSystem.cpp~:                mInputManager=new SDLInputManager(rw->getWidth(),
libproxyobject/plugins/ogre/OgreSystem.cpp~:                                                  rw->getHeight(),
libproxyobject/plugins/ogre/OgreSystem.cpp~:                                                  mFullScreen->as<bool>(),
libproxyobject/plugins/ogre/OgreSystem.cpp~:                                                  mWindowDepth->as<Ogre::PixelFormat>(),
libproxyobject/plugins/ogre/OgreSystem.cpp~:                                                  grabCursor->as<bool>(),
libproxyobject/plugins/ogre/OgreSystem.cpp~:                mInputManager=new SDLInputManager(mWindowWidth->as<uint32>(),
libproxyobject/plugins/ogre/OgreSystem.cpp~:                                                  mWindowHeight->as<uint32>(),
libproxyobject/plugins/ogre/OgreSystem.cpp~:                                                  mFullScreen->as<bool>(),
libproxyobject/plugins/ogre/OgreSystem.cpp~:                                                  mWindowDepth->as<Ogre::PixelFormat>(),
libproxyobject/plugins/ogre/OgreSystem.cpp~:                                                  grabCursor->as<bool>(),
libproxyobject/plugins/ogre/OgreSystem.cpp~:                    if (mFullScreen->as<bool>()==false) {//does not work in fullscreen
libproxyobject/plugins/ogre/OgreSystem.cpp~:                sRenderTarget=mRenderTarget=static_cast<Ogre::RenderTarget*>(rw=getRoot()->createRenderWindow(windowTitle->as<String>(),mWindowWidth->as<uint32>(),mWindowHeight->as<uint32>(),mFullScreen->as<bool>(),&misc));
libproxyobject/plugins/ogre/OgreSystem.cpp~:                SILOG(ogre,warning,"Setting window width from "<<mWindowWidth->as<uint32>()<< " to "<<rw->getWidth()<<'\n'<<"Setting window height from "<<mWindowHeight->as<uint32>()<< " to "<<rw->getHeight()<<'\n');
libproxyobject/plugins/ogre/OgreSystem.cpp~:                *mWindowWidth->get()=Any(rw->getWidth());
libproxyobject/plugins/ogre/OgreSystem.cpp~:                *mWindowHeight->get()=Any(rw->getHeight());
libproxyobject/plugins/ogre/OgreSystem.cpp~:                rw->setVisible(true);
libproxyobject/plugins/ogre/OgreSystem.cpp~:        } else if (createWindow->as<bool>()) {
libproxyobject/plugins/ogre/OgreSystem.cpp~:            mRenderTarget=rw=sRoot->createRenderWindow(windowTitle->as<String>(),mWindowWidth->as<uint32>(),mWindowHeight->as<uint32>(),mFullScreen->as<bool>());
libproxyobject/plugins/ogre/OgreSystem.cpp~:            rw->setVisible(true);
libproxyobject/plugins/ogre/OgreSystem.cpp~:            mRenderTarget=createRenderTarget(windowTitle->as<String>(),
libproxyobject/plugins/ogre/OgreSystem.cpp~:                                             mWindowWidth->as<uint32>(),
libproxyobject/plugins/ogre/OgreSystem.cpp~:                                             mWindowHeight->as<uint32>(),
libproxyobject/plugins/ogre/OgreSystem.cpp~:                                             renderBufferAutoMipmap->as<bool>(),
libproxyobject/plugins/ogre/OgreSystem.cpp~:                                             mWindowDepth->as<Ogre::PixelFormat>());
libproxyobject/plugins/ogre/OgreSystem.cpp~:    if (!getRoot()->isInitialised()) {
libproxyobject/plugins/ogre/OgreSystem.cpp~:        mSceneManager=getRoot()->createSceneManager(ogreSceneManager->as<String>());
libproxyobject/plugins/ogre/OgreSystem.cpp~:            SILOG(ogre,warning,"Cannot find ogre scene manager: "<<ogreSceneManager->as<String>());
libproxyobject/plugins/ogre/OgreSystem.cpp~:            getRoot()->createSceneManager(0);
libproxyobject/plugins/ogre/OgreSystem.cpp~:    mInputManager->subscribe(
libproxyobject/plugins/ogre/OgreSystem.cpp~:    mSceneManager->setShadowTechnique(shadowTechnique->as<Ogre::ShadowTechnique>());
libproxyobject/plugins/ogre/OgreSystem.cpp~:    mSceneManager->setShadowFarDistance(shadowFarDistance->as<float32>());
libproxyobject/plugins/ogre/OgreSystem.cpp~:    mSceneManager->setAmbientLight(Ogre::ColourValue(0.0,0.0,0.0,0));
libproxyobject/plugins/ogre/OgreSystem.cpp~:    //view->setProxyObject(webviewpxy);
libproxyobject/plugins/ogre/OgreSystem.cpp~:    view->loadURL("http://www.google.com");
libproxyobject/plugins/ogre/OgreSystem.cpp~:            if (ogreLoadPlugin("../../dependencies/ogre-1.6.1/lib",filename,false))
libproxyobject/plugins/ogre/OgreSystem.cpp~:            if (ogreLoadPlugin("../../dependencies/ogre-1.6.x/lib",filename,false))
libproxyobject/plugins/ogre/OgreSystem.cpp~:            if (ogreLoadPlugin("../../dependencies/ogre-1.6.1/lib/OGRE",filename,false))
libproxyobject/plugins/ogre/OgreSystem.cpp~:            if (ogreLoadPlugin("../../dependencies/ogre-1.6.x/lib/OGRE",filename,false))
libproxyobject/plugins/ogre/OgreSystem.cpp~:            if (ogreLoadPlugin("../../../dependencies/ogre-1.6.1/lib",filename,false))
libproxyobject/plugins/ogre/OgreSystem.cpp~:            if (ogreLoadPlugin("../../../dependencies/ogre-1.6.x/lib",filename,false))
libproxyobject/plugins/ogre/OgreSystem.cpp~:            if (ogreLoadPlugin("../../../dependencies/ogre-1.6.1/lib/OGRE",filename,false))
libproxyobject/plugins/ogre/OgreSystem.cpp~:            if (ogreLoadPlugin("../../../dependencies/ogre-1.6.x/lib/OGRE",filename,false))
libproxyobject/plugins/ogre/OgreSystem.cpp~:	retval=ogreLoadPlugin(mOgreRootDir->as<String>(),"RenderSystem_GL" OGRE_DEBUG_MACRO);
libproxyobject/plugins/ogre/OgreSystem.cpp~:	    retval=ogreLoadPlugin(mOgreRootDir->as<String>(),"RenderSystem_Direct3D9" OGRE_DEBUG_MACRO) || retval;
libproxyobject/plugins/ogre/OgreSystem.cpp~:    retval=ogreLoadPlugin(mOgreRootDir->as<String>(),"Plugin_CgProgramManager" OGRE_DEBUG_MACRO) && retval;
libproxyobject/plugins/ogre/OgreSystem.cpp~:    retval=ogreLoadPlugin(mOgreRootDir->as<String>(),"Plugin_ParticleFX" OGRE_DEBUG_MACRO) && retval;
libproxyobject/plugins/ogre/OgreSystem.cpp~:    retval=ogreLoadPlugin(mOgreRootDir->as<String>(),"Plugin_OctreeSceneManager" OGRE_DEBUG_MACRO) && retval;
libproxyobject/plugins/ogre/OgreSystem.cpp~:    getRoot()->installPlugin(&*sCDNArchivePlugin);
libproxyobject/plugins/ogre/OgreSystem.cpp~:    --sNumOgreSystems;
libproxyobject/plugins/ogre/OgreSystem.cpp~:    p->getProxyManager()->destroyObject(p,ogreSystem->getPrimaryCamera()->getProxy().getQueryTracker());
libproxyobject/plugins/ogre/OgreSystem.cpp~:				p->getObjectReference().toString(), 512, 512, Ogre::FO_ANISOTROPIC);
libproxyobject/plugins/ogre/OgreSystem.cpp~:            view->setProxyObject(webviewpxy);
libproxyobject/plugins/ogre/OgreSystem.cpp~:            view->bind("close", std::tr1::bind(&KillWebView, this, p));
libproxyobject/plugins/ogre/OgreSystem.cpp~:            mesh->bindTexture("webview", p->getObjectReference());
libproxyobject/plugins/ogre/OgreSystem.cpp~:                pospxy->getObjectReference().toString(),
libproxyobject/plugins/ogre/OgreSystem.cpp~:    RayTraceResult() { mDistance=3.0e38f;mMovableObject=NULL;mSubMesh=-1;}
libproxyobject/plugins/ogre/OgreSystem.cpp~:        returnName= retval->getProxy().getObjectReference();
libproxyobject/plugins/ogre/OgreSystem.cpp~:    mRayQuery = mSceneManager->createRayQuery(Ogre::Ray(), Ogre::SceneManager::WORLD_GEOMETRY_TYPE_MASK);
libproxyobject/plugins/ogre/OgreSystem.cpp~:    mRayQuery->setRay(traceFrom);
libproxyobject/plugins/ogre/OgreSystem.cpp~:    mRayQuery->setSortByDistance(aabbOnly);
libproxyobject/plugins/ogre/OgreSystem.cpp~:    const Ogre::RaySceneQueryResult& resultList = mRayQuery->execute();
libproxyobject/plugins/ogre/OgreSystem.cpp~:                Ogre::Ray meshRay = OgreMesh::transformRay(ourEntity->getSceneNode(), traceFrom);
libproxyobject/plugins/ogre/OgreSystem.cpp~:                Ogre::Mesh *mesh = foundEntity->getMesh().get();
libproxyobject/plugins/ogre/OgreSystem.cpp~:                uint16 numSubMeshes = mesh->getNumSubMeshes();
libproxyobject/plugins/ogre/OgreSystem.cpp~:                    Ogre::SubMesh *submesh = mesh->getSubMesh(ndx);
libproxyobject/plugins/ogre/OgreSystem.cpp~:                    ogreMesh.intersect(ourEntity->getSceneNode(), meshRay, intRes);
libproxyobject/plugins/ogre/OgreSystem.cpp~:    mRayQuery->clearResults();
libproxyobject/plugins/ogre/OgreSystem.cpp~:        mSceneManager->destroyQuery(mRayQuery);
libproxyobject/plugins/ogre/OgreSystem.cpp~:                Time now(mLocalTimeOffset->now(mPrimaryCamera->getProxy()));
libproxyobject/plugins/ogre/OgreSystem.cpp~:                SpaceObjectReference newId = SpaceObjectReference(mPrimaryCamera->id().space(), ObjectReference(UUID::random()));
libproxyobject/plugins/ogre/OgreSystem.cpp~:                Location loc (mPrimaryCamera->getProxy().globalLocation(now).getPosition(), Quaternion::identity(),
libproxyobject/plugins/ogre/OgreSystem.cpp~:                float scale = mInputManager->mWorldScale->as<float>();
libproxyobject/plugins/ogre/OgreSystem.cpp~:                loc.setPosition(loc.getPosition()+Vector3d(-scale*loc.getOrientation().zAxis())); // z-axis is backwards.
libproxyobject/plugins/ogre/OgreSystem.cpp~:                ProxyManager *proxyMgr = mPrimaryCamera->getProxy().getProxyManager();
libproxyobject/plugins/ogre/OgreSystem.cpp~:                proxyMgr->createObject(newMeshObject,mPrimaryCamera->getProxy().getQueryTracker());
libproxyobject/plugins/ogre/OgreSystem.cpp~:                newMeshObject->setMesh((*iter).first.mID);
libproxyobject/plugins/ogre/OgreSystem.cpp~:                newMeshObject->resetLocation(now, loc);
libproxyobject/plugins/ogre/OgreSystem.cpp~:    uploadreq->opts.uploadHashContext = Transfer::URIContext("mhash:///");
libproxyobject/plugins/ogre/OgreSystem.cpp~:    uploadreq->opts.uploadNameContext = Transfer::URIContext("meru:///");
libproxyobject/plugins/ogre/OgreSystem.cpp~:    for (std::vector<std::string>::const_iterator iter = dndev->mFilenames.begin(); iter != dndev->mFilenames.end(); ++iter) {
libproxyobject/plugins/ogre/OgreSystem.cpp~:				std::string::size_type lastslash = filename.rfind('/',filename.length()-2);
libproxyobject/plugins/ogre/OgreSystem.cpp~:		uploadreq->filenames.push_back(Meru::DiskFile::makediskfile(filename));
libproxyobject/plugins/ogre/OgreSystem.cpp~:    uploadreq->parent = this;
libproxyobject/plugins/ogre/OgreSystem.cpp~:    uploadreq->mTransferManager = mTransferManager;
libproxyobject/plugins/ogre/OgreSystem.cpp~:    return mFrameDuration->as<Duration>();
libproxyobject/plugins/ogre/OgreSystem.cpp~:        (*iter++)->preFrame(curFrameTime, deltaTime);
libproxyobject/plugins/ogre/OgreSystem.cpp~:    Duration postFrameDelta = postFrameTime-mLastFrameTime;
libproxyobject/plugins/ogre/OgreSystem.cpp~:    bool continueRendering=mInputManager->tick(postFrameTime,postFrameDelta);
libproxyobject/plugins/ogre/OgreSystem.cpp~:        (*iter++)->postFrame(postFrameTime, postFrameDelta);
libproxyobject/plugins/ogre/OgreSystem.cpp~:                WebViewManager::getSingleton().setDefaultViewport(mPrimaryCamera->getViewport());
libproxyobject/plugins/ogre/OgreSystem.cpp~:    Duration frameTime=curFrameTime-mLastFrameTime;
libproxyobject/plugins/ogre/OgreSystem.cpp~://        SILOG(ogre,debug,"Extrapolating "<<current<<" for time "<<(float64)(currentTime-debugStartTime));
libproxyobject/plugins/ogre/OgreSystem.cpp~:        SpaceID space(current->getProxy().getObjectReference().space());
libproxyobject/plugins/ogre/OgreSystem.cpp~:        current->extrapolateLocation(lastSpace==space?lastTime:(lastTime=Time::convertFrom(currentTime,mLocalTimeOffset->offset(current->getProxy()))));
libproxyobject/plugins/ogre/OgreSystem.cpp~:        mCubeMap->frameEnded(evt);
libproxyobject/plugins/ogre/OgreSystem.cpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/OgreSystem.cpp:volatile char assert_thread_support_is_gequal_2[OGRE_THREAD_SUPPORT*2-3]={0};
libproxyobject/plugins/ogre/OgreSystem.cpp:volatile char assert_thread_support_is_lequal_2[5-OGRE_THREAD_SUPPORT*2]={0};
libproxyobject/plugins/ogre/OgreSystem.cpp://volatile char assert_malloc_is_gequal_1[OGRE_MEMORY_ALLOCATOR*2-1]={0};
libproxyobject/plugins/ogre/OgreSystem.cpp://volatile char assert_malloc_is_lequal_1[3-OGRE_MEMORY_ALLOCATOR*2]={0};
libproxyobject/plugins/ogre/OgreSystem.cpp:    if (mRenderTarget->getName()==name) {
libproxyobject/plugins/ogre/OgreSystem.cpp:        name=mRenderTarget->getName();
libproxyobject/plugins/ogre/OgreSystem.cpp:    if (width==0) width=mWindowWidth->as<uint32>();
libproxyobject/plugins/ogre/OgreSystem.cpp:    if (height==0) height=mWindowHeight->as<uint32>();
libproxyobject/plugins/ogre/OgreSystem.cpp:    return createRenderTarget(name,width,height,true,mWindowDepth->as<Ogre::PixelFormat>());
libproxyobject/plugins/ogre/OgreSystem.cpp:    if (mRenderTarget&&mRenderTarget->getName()==name) {
libproxyobject/plugins/ogre/OgreSystem.cpp:    }else if (sRenderTarget&&sRenderTarget->getName()==name) {
libproxyobject/plugins/ogre/OgreSystem.cpp:            return texptr->getBuffer()->getRenderTarget();
libproxyobject/plugins/ogre/OgreSystem.cpp:                width=texptr->getWidth();
libproxyobject/plugins/ogre/OgreSystem.cpp:                height=texptr->getHeight();
libproxyobject/plugins/ogre/OgreSystem.cpp:                uint32 nummipmaps=texptr->getNumMipmaps();
libproxyobject/plugins/ogre/OgreSystem.cpp:                pf=texptr->getFormat();
libproxyobject/plugins/ogre/OgreSystem.cpp:                return texptr->getBuffer()->getRenderTarget();
libproxyobject/plugins/ogre/OgreSystem.cpp:        for (i = settings->begin(); i != settings->end(); ++i)
libproxyobject/plugins/ogre/OgreSystem.cpp:            typeName = i->first;
libproxyobject/plugins/ogre/OgreSystem.cpp:            archName = i->second;
libproxyobject/plugins/ogre/OgreSystem.cpp:    proxyManager->addListener(this);
libproxyobject/plugins/ogre/OgreSystem.cpp:                           mParallaxSteps=new OptionValue("parallax-steps","1.0",OptionValueType<float>(),"Multiplies the per-material parallax steps by this constant (default 1.0)"),
libproxyobject/plugins/ogre/OgreSystem.cpp:                           mParallaxShadowSteps=new OptionValue("parallax-shadow-steps","10",OptionValueType<int>(),"Total number of steps for shadow parallax mapping (default 10)"),
libproxyobject/plugins/ogre/OgreSystem.cpp:    (mOptions=OptionSet::getOptions("ogregraphics",this))->parse(options);
libproxyobject/plugins/ogre/OgreSystem.cpp:    mTransferManager = (Transfer::TransferManager*)transferManager->as<void*>();
libproxyobject/plugins/ogre/OgreSystem.cpp:    static bool success=((sRoot=OGRE_NEW Ogre::Root(pluginFile->as<String>(),configFile->as<String>(),ogreLogFile->as<String>()))!=NULL
libproxyobject/plugins/ogre/OgreSystem.cpp:                         &&((purgeConfig->as<bool>()==false&&getRoot()->restoreConfig())
libproxyobject/plugins/ogre/OgreSystem.cpp:                            || (userAccepted=getRoot()->showConfigDialog())));
libproxyobject/plugins/ogre/OgreSystem.cpp:        if (!getRoot()->isInitialised()) {
libproxyobject/plugins/ogre/OgreSystem.cpp:            sRoot->initialise(doAutoWindow,windowTitle->as<String>());
libproxyobject/plugins/ogre/OgreSystem.cpp:            Ogre::RenderWindow *rw=(doAutoWindow?sRoot->getAutoCreatedWindow():NULL);
libproxyobject/plugins/ogre/OgreSystem.cpp:            Meru::EventSource::sSingleton = ((Task::GenEventManager*)eventManager->as<void*>());
libproxyobject/plugins/ogre/OgreSystem.cpp:            new SequentialWorkQueue ((Task::WorkQueue*)workQueue->as<void*>());
libproxyobject/plugins/ogre/OgreSystem.cpp:            sRoot->installPlugin(&*mCDNArchivePlugin);
libproxyobject/plugins/ogre/OgreSystem.cpp:                    if (mFullScreen->as<bool>()==false) {//does not work in fullscreen
libproxyobject/plugins/ogre/OgreSystem.cpp:                    sRenderTarget=mRenderTarget=static_cast<Ogre::RenderTarget*>(rw=getRoot()->createRenderWindow(windowTitle->as<String>(),mWindowWidth->as<uint32>(),mWindowHeight->as<uint32>(),mFullScreen->as<bool>(),&misc));
libproxyobject/plugins/ogre/OgreSystem.cpp:                    rw->setVisible(true);
libproxyobject/plugins/ogre/OgreSystem.cpp:                rw->getCustomAttribute("WINDOW",&hWnd);
libproxyobject/plugins/ogre/OgreSystem.cpp:                SILOG(ogre,warning,"Setting window width from "<<mWindowWidth->as<uint32>()<< " to "<<rw->getWidth()<<'\n'<<"Setting window height from "<<mWindowHeight->as<uint32>()<< " to "<<rw->getHeight()<<'\n');
libproxyobject/plugins/ogre/OgreSystem.cpp:                *mWindowWidth->get()=Any(rw->getWidth());
libproxyobject/plugins/ogre/OgreSystem.cpp:                *mWindowHeight->get()=Any(rw->getHeight());
libproxyobject/plugins/ogre/OgreSystem.cpp:                mInputManager=new SDLInputManager(rw->getWidth(),
libproxyobject/plugins/ogre/OgreSystem.cpp:                                                  rw->getHeight(),
libproxyobject/plugins/ogre/OgreSystem.cpp:                                                  mFullScreen->as<bool>(),
libproxyobject/plugins/ogre/OgreSystem.cpp:                                                  mWindowDepth->as<Ogre::PixelFormat>(),
libproxyobject/plugins/ogre/OgreSystem.cpp:                                                  grabCursor->as<bool>(),
libproxyobject/plugins/ogre/OgreSystem.cpp:                mInputManager=new SDLInputManager(mWindowWidth->as<uint32>(),
libproxyobject/plugins/ogre/OgreSystem.cpp:                                                  mWindowHeight->as<uint32>(),
libproxyobject/plugins/ogre/OgreSystem.cpp:                                                  mFullScreen->as<bool>(),
libproxyobject/plugins/ogre/OgreSystem.cpp:                                                  mWindowDepth->as<Ogre::PixelFormat>(),
libproxyobject/plugins/ogre/OgreSystem.cpp:                                                  grabCursor->as<bool>(),
libproxyobject/plugins/ogre/OgreSystem.cpp:                    if (mFullScreen->as<bool>()==false) {//does not work in fullscreen
libproxyobject/plugins/ogre/OgreSystem.cpp:                sRenderTarget=mRenderTarget=static_cast<Ogre::RenderTarget*>(rw=getRoot()->createRenderWindow(windowTitle->as<String>(),mWindowWidth->as<uint32>(),mWindowHeight->as<uint32>(),mFullScreen->as<bool>(),&misc));
libproxyobject/plugins/ogre/OgreSystem.cpp:                SILOG(ogre,warning,"Setting window width from "<<mWindowWidth->as<uint32>()<< " to "<<rw->getWidth()<<'\n'<<"Setting window height from "<<mWindowHeight->as<uint32>()<< " to "<<rw->getHeight()<<'\n');
libproxyobject/plugins/ogre/OgreSystem.cpp:                *mWindowWidth->get()=Any(rw->getWidth());
libproxyobject/plugins/ogre/OgreSystem.cpp:                *mWindowHeight->get()=Any(rw->getHeight());
libproxyobject/plugins/ogre/OgreSystem.cpp:                rw->setVisible(true);
libproxyobject/plugins/ogre/OgreSystem.cpp:        } else if (createWindow->as<bool>()) {
libproxyobject/plugins/ogre/OgreSystem.cpp:            mRenderTarget=rw=sRoot->createRenderWindow(windowTitle->as<String>(),mWindowWidth->as<uint32>(),mWindowHeight->as<uint32>(),mFullScreen->as<bool>());
libproxyobject/plugins/ogre/OgreSystem.cpp:            rw->setVisible(true);
libproxyobject/plugins/ogre/OgreSystem.cpp:            mRenderTarget=createRenderTarget(windowTitle->as<String>(),
libproxyobject/plugins/ogre/OgreSystem.cpp:                                             mWindowWidth->as<uint32>(),
libproxyobject/plugins/ogre/OgreSystem.cpp:                                             mWindowHeight->as<uint32>(),
libproxyobject/plugins/ogre/OgreSystem.cpp:                                             renderBufferAutoMipmap->as<bool>(),
libproxyobject/plugins/ogre/OgreSystem.cpp:                                             mWindowDepth->as<Ogre::PixelFormat>());
libproxyobject/plugins/ogre/OgreSystem.cpp:    if (!getRoot()->isInitialised()) {
libproxyobject/plugins/ogre/OgreSystem.cpp:        mSceneManager=getRoot()->createSceneManager(ogreSceneManager->as<String>());
libproxyobject/plugins/ogre/OgreSystem.cpp:            SILOG(ogre,warning,"Cannot find ogre scene manager: "<<ogreSceneManager->as<String>());
libproxyobject/plugins/ogre/OgreSystem.cpp:            getRoot()->createSceneManager(0);
libproxyobject/plugins/ogre/OgreSystem.cpp:    mInputManager->subscribe(
libproxyobject/plugins/ogre/OgreSystem.cpp:    mSceneManager->setShadowTechnique(shadowTechnique->as<Ogre::ShadowTechnique>());
libproxyobject/plugins/ogre/OgreSystem.cpp:    mSceneManager->setShadowFarDistance(shadowFarDistance->as<float32>());
libproxyobject/plugins/ogre/OgreSystem.cpp:    mSceneManager->setAmbientLight(Ogre::ColourValue(0.0,0.0,0.0,0));
libproxyobject/plugins/ogre/OgreSystem.cpp:    //view->setProxyObject(webviewpxy);
libproxyobject/plugins/ogre/OgreSystem.cpp:    view->loadURL("http://www.google.com");
libproxyobject/plugins/ogre/OgreSystem.cpp:            if (ogreLoadPlugin("../../dependencies/ogre-1.6.1/lib",filename,false))
libproxyobject/plugins/ogre/OgreSystem.cpp:            if (ogreLoadPlugin("../../dependencies/ogre-1.6.x/lib",filename,false))
libproxyobject/plugins/ogre/OgreSystem.cpp:            if (ogreLoadPlugin("../../dependencies/ogre-1.6.1/lib/OGRE",filename,false))
libproxyobject/plugins/ogre/OgreSystem.cpp:            if (ogreLoadPlugin("../../dependencies/ogre-1.6.x/lib/OGRE",filename,false))
libproxyobject/plugins/ogre/OgreSystem.cpp:            if (ogreLoadPlugin("../../../dependencies/ogre-1.6.1/lib",filename,false))
libproxyobject/plugins/ogre/OgreSystem.cpp:            if (ogreLoadPlugin("../../../dependencies/ogre-1.6.x/lib",filename,false))
libproxyobject/plugins/ogre/OgreSystem.cpp:            if (ogreLoadPlugin("../../../dependencies/ogre-1.6.1/lib/OGRE",filename,false))
libproxyobject/plugins/ogre/OgreSystem.cpp:            if (ogreLoadPlugin("../../../dependencies/ogre-1.6.x/lib/OGRE",filename,false))
libproxyobject/plugins/ogre/OgreSystem.cpp:	retval=ogreLoadPlugin(mOgreRootDir->as<String>(),"RenderSystem_GL" OGRE_DEBUG_MACRO);
libproxyobject/plugins/ogre/OgreSystem.cpp:	    retval=ogreLoadPlugin(mOgreRootDir->as<String>(),"RenderSystem_Direct3D9" OGRE_DEBUG_MACRO) || retval;
libproxyobject/plugins/ogre/OgreSystem.cpp:    retval=ogreLoadPlugin(mOgreRootDir->as<String>(),"Plugin_CgProgramManager" OGRE_DEBUG_MACRO) && retval;
libproxyobject/plugins/ogre/OgreSystem.cpp:    retval=ogreLoadPlugin(mOgreRootDir->as<String>(),"Plugin_ParticleFX" OGRE_DEBUG_MACRO) && retval;
libproxyobject/plugins/ogre/OgreSystem.cpp:    retval=ogreLoadPlugin(mOgreRootDir->as<String>(),"Plugin_OctreeSceneManager" OGRE_DEBUG_MACRO) && retval;
libproxyobject/plugins/ogre/OgreSystem.cpp:    getRoot()->installPlugin(&*sCDNArchivePlugin);
libproxyobject/plugins/ogre/OgreSystem.cpp:    --sNumOgreSystems;
libproxyobject/plugins/ogre/OgreSystem.cpp:    p->getProxyManager()->destroyObject(p,ogreSystem->getPrimaryCamera()->getProxy().getQueryTracker());
libproxyobject/plugins/ogre/OgreSystem.cpp:				p->getObjectReference().toString(), 512, 512, Ogre::FO_ANISOTROPIC);
libproxyobject/plugins/ogre/OgreSystem.cpp:            view->setProxyObject(webviewpxy);
libproxyobject/plugins/ogre/OgreSystem.cpp:            view->bind("close", std::tr1::bind(&KillWebView, this, p));
libproxyobject/plugins/ogre/OgreSystem.cpp:            mesh->bindTexture("webview", p->getObjectReference());
libproxyobject/plugins/ogre/OgreSystem.cpp:                pospxy->getObjectReference().toString(),
libproxyobject/plugins/ogre/OgreSystem.cpp:    RayTraceResult() { mDistance=3.0e38f;mMovableObject=NULL;mSubMesh=-1;}
libproxyobject/plugins/ogre/OgreSystem.cpp:        returnName= retval->getProxy().getObjectReference();
libproxyobject/plugins/ogre/OgreSystem.cpp:    mRayQuery = mSceneManager->createRayQuery(Ogre::Ray(), Ogre::SceneManager::WORLD_GEOMETRY_TYPE_MASK);
libproxyobject/plugins/ogre/OgreSystem.cpp:    mRayQuery->setRay(traceFrom);
libproxyobject/plugins/ogre/OgreSystem.cpp:    mRayQuery->setSortByDistance(aabbOnly);
libproxyobject/plugins/ogre/OgreSystem.cpp:    const Ogre::RaySceneQueryResult& resultList = mRayQuery->execute();
libproxyobject/plugins/ogre/OgreSystem.cpp:                Ogre::Ray meshRay = OgreMesh::transformRay(ourEntity->getSceneNode(), traceFrom);
libproxyobject/plugins/ogre/OgreSystem.cpp:                Ogre::Mesh *mesh = foundEntity->getMesh().get();
libproxyobject/plugins/ogre/OgreSystem.cpp:                uint16 numSubMeshes = mesh->getNumSubMeshes();
libproxyobject/plugins/ogre/OgreSystem.cpp:                    Ogre::SubMesh *submesh = mesh->getSubMesh(ndx);
libproxyobject/plugins/ogre/OgreSystem.cpp:                    ogreMesh.intersect(ourEntity->getSceneNode(), meshRay, intRes);
libproxyobject/plugins/ogre/OgreSystem.cpp:    mRayQuery->clearResults();
libproxyobject/plugins/ogre/OgreSystem.cpp:        mSceneManager->destroyQuery(mRayQuery);
libproxyobject/plugins/ogre/OgreSystem.cpp:                Time now(mLocalTimeOffset->now(mPrimaryCamera->getProxy()));
libproxyobject/plugins/ogre/OgreSystem.cpp:                SpaceObjectReference newId = SpaceObjectReference(mPrimaryCamera->id().space(), ObjectReference(UUID::random()));
libproxyobject/plugins/ogre/OgreSystem.cpp:                Location loc (mPrimaryCamera->getProxy().globalLocation(now).getPosition(), Quaternion::identity(),
libproxyobject/plugins/ogre/OgreSystem.cpp:                float scale = mInputManager->mWorldScale->as<float>();
libproxyobject/plugins/ogre/OgreSystem.cpp:                loc.setPosition(loc.getPosition()+Vector3d(-scale*loc.getOrientation().zAxis())); // z-axis is backwards.
libproxyobject/plugins/ogre/OgreSystem.cpp:                ProxyManager *proxyMgr = mPrimaryCamera->getProxy().getProxyManager();
libproxyobject/plugins/ogre/OgreSystem.cpp:                proxyMgr->createObject(newMeshObject,mPrimaryCamera->getProxy().getQueryTracker());
libproxyobject/plugins/ogre/OgreSystem.cpp:                newMeshObject->setMesh((*iter).first.mID);
libproxyobject/plugins/ogre/OgreSystem.cpp:                newMeshObject->resetLocation(now, loc);
libproxyobject/plugins/ogre/OgreSystem.cpp:    uploadreq->opts.uploadHashContext = Transfer::URIContext("mhash:///");
libproxyobject/plugins/ogre/OgreSystem.cpp:    uploadreq->opts.uploadNameContext = Transfer::URIContext("meru:///");
libproxyobject/plugins/ogre/OgreSystem.cpp:    for (std::vector<std::string>::const_iterator iter = dndev->mFilenames.begin(); iter != dndev->mFilenames.end(); ++iter) {
libproxyobject/plugins/ogre/OgreSystem.cpp:				std::string::size_type lastslash = filename.rfind('/',filename.length()-2);
libproxyobject/plugins/ogre/OgreSystem.cpp:		uploadreq->filenames.push_back(Meru::DiskFile::makediskfile(filename));
libproxyobject/plugins/ogre/OgreSystem.cpp:    uploadreq->parent = this;
libproxyobject/plugins/ogre/OgreSystem.cpp:    uploadreq->mTransferManager = mTransferManager;
libproxyobject/plugins/ogre/OgreSystem.cpp:    return mFrameDuration->as<Duration>();
libproxyobject/plugins/ogre/OgreSystem.cpp:        (*iter++)->preFrame(curFrameTime, deltaTime);
libproxyobject/plugins/ogre/OgreSystem.cpp:    Duration postFrameDelta = postFrameTime-mLastFrameTime;
libproxyobject/plugins/ogre/OgreSystem.cpp:    bool continueRendering=mInputManager->tick(postFrameTime,postFrameDelta);
libproxyobject/plugins/ogre/OgreSystem.cpp:        (*iter++)->postFrame(postFrameTime, postFrameDelta);
libproxyobject/plugins/ogre/OgreSystem.cpp:                WebViewManager::getSingleton().setDefaultViewport(mPrimaryCamera->getViewport());
libproxyobject/plugins/ogre/OgreSystem.cpp:    Duration frameTime=curFrameTime-mLastFrameTime;
libproxyobject/plugins/ogre/OgreSystem.cpp://        SILOG(ogre,debug,"Extrapolating "<<current<<" for time "<<(float64)(currentTime-debugStartTime));
libproxyobject/plugins/ogre/OgreSystem.cpp:        SpaceID space(current->getProxy().getObjectReference().space());
libproxyobject/plugins/ogre/OgreSystem.cpp:        current->extrapolateLocation(lastSpace==space?lastTime:(lastTime=Time::convertFrom(currentTime,mLocalTimeOffset->offset(current->getProxy()))));
libproxyobject/plugins/ogre/OgreSystem.cpp:        mCubeMap->frameEnded(evt);
libproxyobject/plugins/ogre/InputResponse.hpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/InputResponse.hpp: *  Copyright (c) 2009, Ewen Cheslack-Postava
libproxyobject/plugins/ogre/InputResponse.hpp:// Input response that takes a string -> string map.
libproxyobject/plugins/ogre/WebViewManager.cpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/WebViewManager.cpp:        mychromeWebView->loadURL("http://yahoo.com/");
libproxyobject/plugins/ogre/WebViewManager.cpp:        mychromeWebView->loadURL("http://people.xiph.org/~maikmerten/demos/bigbuckbunny-videoonly.html");
libproxyobject/plugins/ogre/WebViewManager.cpp:        mychromeWebView->loadURL("http://www.youtube.com/watch?v=oHg5SJYRHA0");
libproxyobject/plugins/ogre/WebViewManager.cpp:        mychromeWebView->setTransparent(true);
libproxyobject/plugins/ogre/WebViewManager.cpp:        chromeWebView->loadFile("navbar.html");
libproxyobject/plugins/ogre/WebViewManager.cpp:        mychromeWebView->loadURL("http://google.com/");
libproxyobject/plugins/ogre/WebViewManager.cpp:        mychromeWebView->setTransparent(true);
libproxyobject/plugins/ogre/WebViewManager.cpp:        mychromeWebView->focus();
libproxyobject/plugins/ogre/WebViewManager.cpp:        mychromeWebView->loadURL("http://www.adobe.com/aboutadobe/contact.html");
libproxyobject/plugins/ogre/WebViewManager.cpp:        mychromeWebView->setTransparent(true);
libproxyobject/plugins/ogre/WebViewManager.cpp:        mychromeWebView->loadURL(http://dunnbypaul.net/js_mouse/");
libproxyobject/plugins/ogre/WebViewManager.cpp:        mychromeWebView->setTransparent(false);
libproxyobject/plugins/ogre/WebViewManager.cpp:		WebView* toDelete = iter->second;
libproxyobject/plugins/ogre/WebViewManager.cpp:		if(iter->second->okayToDelete)
libproxyobject/plugins/ogre/WebViewManager.cpp:			WebView* webViewToDelete = iter->second;
libproxyobject/plugins/ogre/WebViewManager.cpp:			iter->second->update();
libproxyobject/plugins/ogre/WebViewManager.cpp:			tooltipWebView->show(true);
libproxyobject/plugins/ogre/WebViewManager.cpp:	int highestZOrder = -1;
libproxyobject/plugins/ogre/WebViewManager.cpp:		if(iter->second->overlay)
libproxyobject/plugins/ogre/WebViewManager.cpp:			if(iter->second->overlay->getTier() == tier)
libproxyobject/plugins/ogre/WebViewManager.cpp:				if(iter->second->overlay->getZOrder() > highestZOrder)
libproxyobject/plugins/ogre/WebViewManager.cpp:					highestZOrder = iter->second->overlay->getZOrder();
libproxyobject/plugins/ogre/WebViewManager.cpp:	if(highestZOrder != -1)
libproxyobject/plugins/ogre/WebViewManager.cpp:        newWebView->createWebView(asyncRender, maxAsyncRenderRate);
libproxyobject/plugins/ogre/WebViewManager.cpp:        newWebView->bind("event", std::tr1::bind(&WebViewManager::onRaiseWebViewEvent, this, _1, _2));
libproxyobject/plugins/ogre/WebViewManager.cpp:	int highestZOrder = -1;
libproxyobject/plugins/ogre/WebViewManager.cpp:		if(iter->second->overlay)
libproxyobject/plugins/ogre/WebViewManager.cpp:			if(iter->second->overlay->getTier() == tier)
libproxyobject/plugins/ogre/WebViewManager.cpp:				if(iter->second->overlay->getZOrder() > highestZOrder)
libproxyobject/plugins/ogre/WebViewManager.cpp:					highestZOrder = iter->second->overlay->getZOrder();
libproxyobject/plugins/ogre/WebViewManager.cpp:	if(highestZOrder != -1)
libproxyobject/plugins/ogre/WebViewManager.cpp:        newWebView->initializeWebView(newwin);
libproxyobject/plugins/ogre/WebViewManager.cpp:        newWebView->bind("event", std::tr1::bind(&WebViewManager::onRaiseWebViewEvent, this, _1, _2));
libproxyobject/plugins/ogre/WebViewManager.cpp:        newWebView->createWebView(asyncRender, maxAsyncRenderRate);
libproxyobject/plugins/ogre/WebViewManager.cpp:        newWebView->bind("event", std::tr1::bind(&WebViewManager::onRaiseWebViewEvent, this, _1, _2));
libproxyobject/plugins/ogre/WebViewManager.cpp:		return iter->second;
libproxyobject/plugins/ogre/WebViewManager.cpp:		iter->second->okayToDelete = true;
libproxyobject/plugins/ogre/WebViewManager.cpp:		webViewToDestroy->okayToDelete = true;
libproxyobject/plugins/ogre/WebViewManager.cpp:		if(!iter->second->isMaterialOnly())
libproxyobject/plugins/ogre/WebViewManager.cpp:			iter->second->resetPosition();
libproxyobject/plugins/ogre/WebViewManager.cpp:        focusedWebView->move(coord.x-mouseXPos, coord.y-mouseYPos);
libproxyobject/plugins/ogre/WebViewManager.cpp:            focusedWebView->getExtents(w,h);
libproxyobject/plugins/ogre/WebViewManager.cpp:            int32 new_w = w + (coord.x - mouseXPos), new_h = h + (coord.y - mouseYPos);
libproxyobject/plugins/ogre/WebViewManager.cpp:            focusedWebView->resize(new_w, new_h);
libproxyobject/plugins/ogre/WebViewManager.cpp:        if (focusedWebView && !focusedWebView->isMaterialOnly()) {
libproxyobject/plugins/ogre/WebViewManager.cpp:            focusedWebView->injectMouseMove(
libproxyobject/plugins/ogre/WebViewManager.cpp:                focusedWebView->getRelativeX(coord.x),
libproxyobject/plugins/ogre/WebViewManager.cpp:                focusedWebView->getRelativeY(coord.y));
libproxyobject/plugins/ogre/WebViewManager.cpp:				top->injectMouseMove(top->getRelativeX(coord.x), top->getRelativeY(coord.y));
libproxyobject/plugins/ogre/WebViewManager.cpp:				if(iter->second->ignoringBounds) {
libproxyobject/plugins/ogre/WebViewManager.cpp:					if(!(iter->second->isPointOverMe(coord.x, coord.y) && iter->second->overlay->panel->getZOrder() < top->overlay->panel->getZOrder())) {
libproxyobject/plugins/ogre/WebViewManager.cpp:						if (iter->second != top && iter->second != focusedWebView) {
libproxyobject/plugins/ogre/WebViewManager.cpp:							iter->second->injectMouseMove(iter->second->getRelativeX(coord.x), iter->second->getRelativeY(coord.y));
libproxyobject/plugins/ogre/WebViewManager.cpp:			if(!tooltipParent->isPointOverMe(coord.x, coord.y))
libproxyobject/plugins/ogre/WebViewManager.cpp:		if(tooltipWebView && tooltipWebView->getNonStrictVisibility())
libproxyobject/plugins/ogre/WebViewManager.cpp:			tooltipWebView->setPosition(OverlayPosition(coord.x, coord.y + 15));
libproxyobject/plugins/ogre/WebViewManager.cpp:		focusedWebView->injectMouseWheel(relScroll.x, relScroll.y);
libproxyobject/plugins/ogre/WebViewManager.cpp:			int relX = focusedWebView->getRelativeX(mouseXPos);
libproxyobject/plugins/ogre/WebViewManager.cpp:			int relY = focusedWebView->getRelativeY(mouseYPos);
libproxyobject/plugins/ogre/WebViewManager.cpp:			focusedWebView->injectMouseDown(relX, relY);
libproxyobject/plugins/ogre/WebViewManager.cpp:		int relX = focusedWebView->getRelativeX(mouseXPos);
libproxyobject/plugins/ogre/WebViewManager.cpp:		int relY = focusedWebView->getRelativeY(mouseYPos);
libproxyobject/plugins/ogre/WebViewManager.cpp:		focusedWebView->injectMouseUp(relX, relY);
libproxyobject/plugins/ogre/WebViewManager.cpp:        focusedWebView->injectKeyEvent(pressed, wvmods, vk_code, numpad);
libproxyobject/plugins/ogre/WebViewManager.cpp:		focusedWebView->injectTextEvent(utf8text);
libproxyobject/plugins/ogre/WebViewManager.cpp:struct compare { bool operator()(WebView* a, WebView* b){ return(a->getOverlay()->getZOrder() > b->getOverlay()->getZOrder()); }};
libproxyobject/plugins/ogre/WebViewManager.cpp:		if(iter->second->overlay && webViewToFocus->overlay) {
libproxyobject/plugins/ogre/WebViewManager.cpp:			if(iter->second->overlay->getTier() == webViewToFocus->overlay->getTier()) {
libproxyobject/plugins/ogre/WebViewManager.cpp:				sortedWebViews.push_back(iter->second);
libproxyobject/plugins/ogre/WebViewManager.cpp:			unsigned short highestZ = sortedWebViews.at(0)->overlay->getZOrder();
libproxyobject/plugins/ogre/WebViewManager.cpp:				sortedWebViews.at(i)->overlay->setZOrder(sortedWebViews.at(i+1)->overlay->getZOrder());
libproxyobject/plugins/ogre/WebViewManager.cpp:			sortedWebViews.at(popIdx)->overlay->setZOrder(highestZ);
libproxyobject/plugins/ogre/WebViewManager.cpp:	focusedWebView->focus();
libproxyobject/plugins/ogre/WebViewManager.cpp:		if(!iter->second->isPointOverMe(x, y))
libproxyobject/plugins/ogre/WebViewManager.cpp:			top = iter->second;
libproxyobject/plugins/ogre/WebViewManager.cpp:			top = top->overlay->panel->getZOrder() > iter->second->overlay->panel->getZOrder()? top : iter->second;
libproxyobject/plugins/ogre/WebViewManager.cpp:		iter->second->unfocus();
libproxyobject/plugins/ogre/WebViewManager.cpp:	astralMgr->defocusAll();
libproxyobject/plugins/ogre/WebViewManager.cpp:	hiddenWin->focus();
libproxyobject/plugins/ogre/WebViewManager.cpp:	hiddenWin->injectMouseMove(50, 50);
libproxyobject/plugins/ogre/WebViewManager.cpp:	hiddenWin->injectMouseDown(50, 50);
libproxyobject/plugins/ogre/WebViewManager.cpp:	hiddenWin->injectMouseUp(50, 50);
libproxyobject/plugins/ogre/WebViewManager.cpp:		if(iter->second->overlay)
libproxyobject/plugins/ogre/WebViewManager.cpp:			if(iter->second->overlay->viewport == defaultViewport)
libproxyobject/plugins/ogre/WebViewManager.cpp:				iter->second->overlay->setViewport(newViewport);
libproxyobject/plugins/ogre/WebViewManager.cpp:        tooltipWebView->resize(boost::lexical_cast<int>(xstr),
libproxyobject/plugins/ogre/WebViewManager.cpp:	tooltipWebView->setPosition(OverlayPosition(mouseXPos, mouseYPos + 15));
libproxyobject/plugins/ogre/WebViewManager.cpp:		tooltipWebView->show(true);
libproxyobject/plugins/ogre/WebViewManager.cpp:// FIXME: Only works for awesomium, doesn't handle utf-8, and has unsanitized javascript
libproxyobject/plugins/ogre/WebViewManager.cpp:		this->tooltipParent = tooltipParent;
libproxyobject/plugins/ogre/WebViewManager.cpp:		tooltipWebView->hide(true);
libproxyobject/plugins/ogre/WebViewManager.cpp:                tooltipWebView->resize(512, 256); // Large enough that it should hold anything we put in there.
libproxyobject/plugins/ogre/WebViewManager.cpp:		tooltipWebView->evaluateJS("setTooltip('" + tipStr + "')");
libproxyobject/plugins/ogre/WebViewManager.cpp:		tooltipWebView->hide(true);
libproxyobject/plugins/ogre/WebViewManager.cpp:        newwebview->loadURL("http://sirikata.com/");
libproxyobject/plugins/ogre/WebViewManager.cpp://        newwebview->setTransparent(true);
libproxyobject/plugins/ogre/WebViewManager.cpp:        focusedNonChromeWebView->evaluateJS("history.go(-1)");
libproxyobject/plugins/ogre/WebViewManager.cpp:        focusedNonChromeWebView->evaluateJS("history.go(1)");
libproxyobject/plugins/ogre/WebViewManager.cpp:        focusedNonChromeWebView->webView->refresh();
libproxyobject/plugins/ogre/WebViewManager.cpp:        focusedNonChromeWebView->loadURL("http://www.google.com");
libproxyobject/plugins/ogre/WebViewManager.cpp://        focusedNonChromeWebView->loadURL("");
libproxyobject/plugins/ogre/WebViewManager.cpp://        focusedNonChromeWebView->setTransparent(true);
libproxyobject/plugins/ogre/WebViewManager.cpp:    String command(str.substr(first, last - first));
libproxyobject/plugins/ogre/WebViewManager.cpp:    String target(str.substr(first, last - first));
libproxyobject/plugins/ogre/WebViewManager.cpp:    for (p = dispatchTable; p->name != NULL; ++p)
libproxyobject/plugins/ogre/WebViewManager.cpp:        if (strcmp(ccommand, p->name) == 0)
libproxyobject/plugins/ogre/WebViewManager.cpp:    if (p->handler != NULL)
libproxyobject/plugins/ogre/WebViewManager.cpp:        p->handler(target, args);
libproxyobject/plugins/ogre/WebViewManager.cpp:            focusedNonChromeWebView->loadURL(arg);
libproxyobject/plugins/ogre/WebViewManager.cpp:    mInputManager->fire(Task::EventPtr( new WebViewEvent(webview->getName(), args) ));
libproxyobject/plugins/ogre/WebViewManager.cpp:    this->injectMouseMove(InputCoordToWebViewCoord(e, e->mX, e->mY));
libproxyobject/plugins/ogre/WebViewManager.cpp:    this->injectMouseMove(InputCoordToWebViewCoord(e, e->mX, e->mY));
libproxyobject/plugins/ogre/WebViewManager.cpp:    int wvbutton = InputButtonToWebViewButton(e->mButton);
libproxyobject/plugins/ogre/WebViewManager.cpp:    bool success = this->injectMouseUp(wvbutton);
libproxyobject/plugins/ogre/WebViewManager.cpp:    this->injectMouseMove(InputCoordToWebViewCoord(e, e->mX, e->mY));
libproxyobject/plugins/ogre/WebViewManager.cpp:    int wvbutton = InputButtonToWebViewButton(e->mButton);
libproxyobject/plugins/ogre/WebViewManager.cpp:    bool success = this->injectMouseDown(wvbutton);
libproxyobject/plugins/ogre/WebViewManager.cpp:    this->injectMouseMove(InputCoordToWebViewCoord(e, e->mX, e->mY));
libproxyobject/plugins/ogre/WebViewManager.cpp:    int wvbutton = InputButtonToWebViewButton(e->mButton);
libproxyobject/plugins/ogre/WebViewManager.cpp:    switch(e->mType) {
libproxyobject/plugins/ogre/WebViewManager.cpp:        success = this->injectMouseUp(wvbutton);
libproxyobject/plugins/ogre/WebViewManager.cpp:	if(e->getDevice()->isKeyboard()) {
libproxyobject/plugins/ogre/WebViewManager.cpp:            success = this->injectKeyEvent(e->mEvent, e->mModifier, e->mButton);
libproxyobject/plugins/ogre/WebViewManager.cpp:	if (injectTextEvent(e->mText)) {
libproxyobject/plugins/ogre/WebViewManager.cpp:    evt->getDevice()->getInputManager()->getWindowSize(wid,hei);
libproxyobject/plugins/ogre/WebViewManager.cpp:    return WebViewCoord(((x+1)*wid)/2, ((1-y)*hei)/2);
libproxyobject/plugins/ogre/WebViewManager.cpp:WIN_VK_OEM_MINUS = 0xBD,	// '-' any country
libproxyobject/plugins/ogre/LightEntity.cpp:             id.length()?id:ogreLightName(plo->getObjectReference()),
libproxyobject/plugins/ogre/LightEntity.cpp:             scene->getSceneManager()->createLight(id.length()?id:ogreLightName(plo->getObjectReference()))) {
libproxyobject/plugins/ogre/LightEntity.cpp:    mScene->getSceneManager()->destroyLight(toDestroy);
libproxyobject/plugins/ogre/LightEntity.cpp:    //minimize sqrt((source.r*power - target.r)^2 + (source.g*power - target.g) + (source.b*power - target.b));
libproxyobject/plugins/ogre/LightEntity.cpp:    getOgreLight()->setDiffuseColour(diffuse_ambient);
libproxyobject/plugins/ogre/LightEntity.cpp:    getOgreLight()->setSpecularColour(specular_shadow);
libproxyobject/plugins/ogre/LightEntity.cpp:    getOgreLight()->setPowerScale(linfo.mPower);
libproxyobject/plugins/ogre/LightEntity.cpp:        getOgreLight()->setType(Ogre::Light::LT_POINT);
libproxyobject/plugins/ogre/LightEntity.cpp:        getOgreLight()->setType(Ogre::Light::LT_SPOTLIGHT);
libproxyobject/plugins/ogre/LightEntity.cpp:        getOgreLight()->setType(Ogre::Light::LT_DIRECTIONAL);
libproxyobject/plugins/ogre/LightEntity.cpp:        getOgreLight()->setAttenuation(
libproxyobject/plugins/ogre/LightEntity.cpp:        getOgreLight()->setSpotlightRange(
libproxyobject/plugins/ogre/LightEntity.cpp:    getOgreLight()->setCastShadows(linfo.mCastsShadow);
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:    VertexData *vertexData = subMesh->vertexData;
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:        VertexDeclaration *vertexDecl = vertexData->vertexDeclaration;
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:        const VertexElement *element = vertexDecl->findElementBySemantic(Ogre::VES_POSITION);
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:        const VertexElement *texelement = texcoord ? vertexDecl->findElementBySemantic(Ogre::VES_TEXTURE_COORDINATES) : NULL;
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:        VertexBufferBinding *bufferBinding = vertexData->vertexBufferBinding;
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:        HardwareVertexBuffer *buffer = bufferBinding->getBuffer(element->getSource()).get();
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:        unsigned char *pVert = static_cast<unsigned char*>(buffer->lock(HardwareBuffer::HBL_READ_ONLY));
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:        HardwareVertexBuffer *texbuffer = texelement ? bufferBinding->getBuffer(texelement->getSource()).get() : NULL;
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:                                  ? (texbuffer == buffer ? pVert : static_cast<unsigned char*>(texbuffer->lock(HardwareBuffer::HBL_READ_ONLY)))
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:        for (size_t vert = 0; vert < vertexData->vertexCount; vert++)
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:            element->baseVertexPointerToElement(pVert, &vertex);
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:                texelement->baseVertexPointerToElement(pTexVert, &texvertex);
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:                pTexVert += texbuffer->getVertexSize();
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:            pVert += buffer->getVertexSize();
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:        buffer->unlock();
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:        subMesh->_getRenderOperation(ro);
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:            IndexData * indexData = subMesh->indexData;
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:            HardwareIndexBuffer *indexBuffer = indexData->indexBuffer.get();
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:            void *pIndex = static_cast<unsigned char *>(indexBuffer->lock(HardwareBuffer::HBL_READ_ONLY));
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:            if (indexBuffer->getType() == HardwareIndexBuffer::IT_16BIT)
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:                for (size_t index = indexData->indexStart; index < indexData->indexCount; )
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:            else if (indexBuffer->getType() == HardwareIndexBuffer::IT_32BIT)
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:                for (size_t index = indexData->indexStart; index < indexData->indexCount; )
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:            indexBuffer->unlock();
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:  const Ogre::Vector3 &position = node->_getDerivedPosition();
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:  const Ogre::Quaternion &orient = node->_getDerivedOrientation();
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:  const Ogre::Vector3 &scale = node->_getDerivedScale();
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:  Ogre::Vector3 newStart = (orient.Inverse() * (ray.getOrigin() - position)) / scale;
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:      ? Ogre::Math::intersects(ray, Ogre::Plane(itr->v1.coord, itr->v2.coord,itr->v3.coord))
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:      : Ogre::Math::intersects(ray, itr->v1.coord, itr->v2.coord,itr->v3.coord, true, false);
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:      Ogre::Vector3 nml=(itr->v1.coord-itr->v2.coord).
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:              crossProduct(itr->v3.coord-itr->v2.coord);
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:      Ogre::Vector3 intersect = ray.getPoint(hit.second) - rtn.tri.v2.coord;
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:      Ogre::Vector3 aVec = (rtn.tri.v1.coord - rtn.tri.v2.coord);
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:      Ogre::Vector3 bVec = (rtn.tri.v3.coord - rtn.tri.v2.coord);
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:      if (aVec.length() > 1.0e-10 && bVec.length() > 1.0e-10) {
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:        rtn.u = rtn.tri.v2.u + (rtn.tri.v1.u - rtn.tri.v2.u)*cos(aVec.angleBetween(intersect).valueRadians())*intersect.length()/aVec.length();
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:        rtn.v = rtn.tri.v2.v + (rtn.tri.v3.v - rtn.tri.v2.v)*cos(bVec.angleBetween(intersect).valueRadians())*intersect.length()/bVec.length();
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:  const Ogre::Vector3 &position = node->_getDerivedPosition();
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:  const Ogre::Quaternion &orient = node->_getDerivedOrientation();
libproxyobject/plugins/ogre/OgreMeshRaytrace.cpp:  const Ogre::Vector3 &scale = node->_getDerivedScale();
libproxyobject/plugins/ogre/ViewportOverlay.cpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/ViewportOverlay.cpp:			"Z-order is out of bounds, must be within [0, 199].", "ViewportOverlay::ViewportOverlay");
libproxyobject/plugins/ogre/ViewportOverlay.cpp:	panel->setMetricsMode(Ogre::GMM_PIXELS);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:	panel->setMaterialName(matName);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:	panel->setDimensions(width, height);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:	overlay->add2D(panel);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:		viewport->getTarget()->addListener(this);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:		viewport->getTarget()->removeListener(this);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:		overlay->remove2D(panel);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:		OverlayManager::getSingletonPtr()->destroyOverlayElement(panel);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:		OverlayManager::getSingletonPtr()->destroy(overlay);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:	overlay->hide();
libproxyobject/plugins/ogre/ViewportOverlay.cpp:		viewport->getTarget()->removeListener(this);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:		viewport->getTarget()->addListener(this);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:	panel->setPosition(panel->getLeft()+deltaX, panel->getTop()+deltaY);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:	this->position = position;
libproxyobject/plugins/ogre/ViewportOverlay.cpp:		panel->setPosition(0, 0);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:	int viewWidth = viewport->getActualWidth();
libproxyobject/plugins/ogre/ViewportOverlay.cpp:	int viewHeight = viewport->getActualHeight();
libproxyobject/plugins/ogre/ViewportOverlay.cpp:		int center = (viewWidth/2)-(width/2) + position.data.rel.x;
libproxyobject/plugins/ogre/ViewportOverlay.cpp:		int right = viewWidth - width + position.data.rel.x;
libproxyobject/plugins/ogre/ViewportOverlay.cpp:		int middle = (viewHeight/2)-(height/2) + position.data.rel.y;
libproxyobject/plugins/ogre/ViewportOverlay.cpp:		int bottom = viewHeight-height + position.data.rel.y;
libproxyobject/plugins/ogre/ViewportOverlay.cpp:			panel->setPosition(left, middle);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:			panel->setPosition(left, top);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:			panel->setPosition(center, top);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:			panel->setPosition(right, top);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:			panel->setPosition(right, middle);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:			panel->setPosition(right, bottom);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:			panel->setPosition(center, bottom);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:			panel->setPosition(left, bottom);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:			panel->setPosition(center, middle);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:			panel->setPosition(position.data.rel.x, position.data.rel.y);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:		panel->setPosition(position.data.abs.left, position.data.abs.top);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:	this->width = width;
libproxyobject/plugins/ogre/ViewportOverlay.cpp:	this->height = height;
libproxyobject/plugins/ogre/ViewportOverlay.cpp:	panel->setDimensions(width, height);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:	this->tier = tier;
libproxyobject/plugins/ogre/ViewportOverlay.cpp:	overlay->setZOrder(200 * tier + zOrder);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:	this->zOrder = zOrder;
libproxyobject/plugins/ogre/ViewportOverlay.cpp:	overlay->setZOrder(200 * tier + zOrder);
libproxyobject/plugins/ogre/ViewportOverlay.cpp:	return viewport? viewport->getActualLeft() + panel->getLeft() : 0;
libproxyobject/plugins/ogre/ViewportOverlay.cpp:	return viewport? viewport->getActualTop() + panel->getTop() : 0;
libproxyobject/plugins/ogre/ViewportOverlay.cpp:	return viewport? absX - viewport->getActualLeft() - panel->getLeft() : 0;
libproxyobject/plugins/ogre/ViewportOverlay.cpp:	return viewport? absY - viewport->getActualTop() - panel->getTop() : 0;
libproxyobject/plugins/ogre/ViewportOverlay.cpp:	if(absX < viewport->getActualLeft() || absX > viewport->getActualWidth() + viewport->getActualLeft() ||
libproxyobject/plugins/ogre/ViewportOverlay.cpp:		absY < viewport->getActualTop() || absY > viewport->getActualHeight() + viewport->getActualTop())
libproxyobject/plugins/ogre/ViewportOverlay.cpp:		overlay->show();
libproxyobject/plugins/ogre/ViewportOverlay.cpp:	overlay->hide();
libproxyobject/plugins/ogre/OgreHeaders.hpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/InputBindingEvent.hpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/InputBindingEvent.hpp: *  Copyright (c) 2009, Ewen Cheslack-Postava
libproxyobject/plugins/ogre/Entity.cpp:    mSceneNode(scene->getSceneManager()->createSceneNode(ogreId)),
libproxyobject/plugins/ogre/Entity.cpp:    mMovingIter(scene->mMovingEntities.end())
libproxyobject/plugins/ogre/Entity.cpp:    mSceneNode->setInheritScale(false);
libproxyobject/plugins/ogre/Entity.cpp:    bool successful = scene->mSceneEntities.insert(
libproxyobject/plugins/ogre/Entity.cpp:        OgreSystem::SceneEntitiesMap::value_type(mProxy->getObjectReference(), this)).second;
libproxyobject/plugins/ogre/Entity.cpp:    ppo->ProxyObjectProvider::addListener(this);
libproxyobject/plugins/ogre/Entity.cpp:    ppo->PositionProvider::addListener(this);
libproxyobject/plugins/ogre/Entity.cpp:        mScene->mSceneEntities.find(mProxy->getObjectReference());
libproxyobject/plugins/ogre/Entity.cpp:    if (iter != mScene->mSceneEntities.end()) {
libproxyobject/plugins/ogre/Entity.cpp:        mScene->mSceneEntities.erase(iter);
libproxyobject/plugins/ogre/Entity.cpp:    if (mMovingIter != mScene->mMovingEntities.end()) {
libproxyobject/plugins/ogre/Entity.cpp:        mScene->mMovingEntities.erase(mMovingIter);
libproxyobject/plugins/ogre/Entity.cpp:        mMovingIter = mScene->mMovingEntities.end();
libproxyobject/plugins/ogre/Entity.cpp:    mSceneNode->detachAllObjects();
libproxyobject/plugins/ogre/Entity.cpp:    mSceneNode->removeAllChildren();
libproxyobject/plugins/ogre/Entity.cpp:    mScene->getSceneManager()->destroySceneNode(mSceneNode);
libproxyobject/plugins/ogre/Entity.cpp:    return Ogre::any_cast<Entity*>(movable->getUserAny());
libproxyobject/plugins/ogre/Entity.cpp:        mSceneNode->detachObject(mOgreObject);
libproxyobject/plugins/ogre/Entity.cpp:        mOgreObject->setUserAny(Ogre::Any(this));
libproxyobject/plugins/ogre/Entity.cpp:        mSceneNode->attachObject(obj);
libproxyobject/plugins/ogre/Entity.cpp:    const std::list<Entity*>::iterator end = mScene->mMovingEntities.end();
libproxyobject/plugins/ogre/Entity.cpp:            mScene->mMovingEntities.erase(mMovingIter);
libproxyobject/plugins/ogre/Entity.cpp:            mMovingIter = mScene->mMovingEntities.insert(end, this);
libproxyobject/plugins/ogre/Entity.cpp:    Ogre::SceneNode *oldParent = mSceneNode->getParentSceneNode();
libproxyobject/plugins/ogre/Entity.cpp:        oldParent->removeChild(mSceneNode);
libproxyobject/plugins/ogre/Entity.cpp:        newParent = mScene->getSceneManager()->getRootSceneNode();
libproxyobject/plugins/ogre/Entity.cpp:    newParent->addChild(mSceneNode);
libproxyobject/plugins/ogre/Entity.cpp:    Ogre::Vector3 ogrepos = toOgre(pos, getScene()->getOffset());
libproxyobject/plugins/ogre/Entity.cpp:    const Ogre::Vector3 &scale = mSceneNode->getScale();
libproxyobject/plugins/ogre/Entity.cpp:    mSceneNode->setPosition(ogrepos);
libproxyobject/plugins/ogre/Entity.cpp:    mSceneNode->setOrientation(toOgre(orient));
libproxyobject/plugins/ogre/Entity.cpp:    Entity *parentEntity = mScene->getEntity(parent);
libproxyobject/plugins/ogre/Entity.cpp:        SILOG(ogre,fatal,"No Entity has been created for proxy " << parent->getObjectReference() <<
libproxyobject/plugins/ogre/Entity.cpp:    addToScene(parentEntity->mSceneNode);
libproxyobject/plugins/ogre/OgrePlugin.cpp:    return --core_plugin_refcount;
libproxyobject/plugins/ogre/OgrePlugin.cpp:        core_plugin_refcount--;
libproxyobject/plugins/ogre/CubeMap.hpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/WebViewManager.hpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/WebViewManager.hpp:* The class you will need to go to for all your WebView-related needs.
libproxyobject/plugins/ogre/WebViewManager.hpp:	*                        in. This can be overriden per-WebView via the
libproxyobject/plugins/ogre/WebViewManager.hpp:     * @param	relScroll	The relative Scroll-Value of the mouse.
libproxyobject/plugins/ogre/WebViewManager.hpp:	* De-Focuses any currently-focused WebViews.
libproxyobject/plugins/ogre/MeshEntity.hpp://        return fromOgre(mSceneNode->getScale());
libproxyobject/plugins/ogre/ViewportOverlay.hpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
Binary file libproxyobject/plugins/ogre/data/chrome/turnleft.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/reload_h.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/deltab_h.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/turnright_h.png matches
libproxyobject/plugins/ogre/data/chrome/tooltip.html:      background-color: #EEFFFF;
libproxyobject/plugins/ogre/data/chrome/tooltip.html:      border-color: #000;
libproxyobject/plugins/ogre/data/chrome/tooltip.html:      border-style: solid;
libproxyobject/plugins/ogre/data/chrome/tooltip.html:      border-width: 1px;
Binary file libproxyobject/plugins/ogre/data/chrome/turnleft_h.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/go_h.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/help.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/turnright.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/forward_h.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/turnleft_d.png matches
libproxyobject/plugins/ogre/data/chrome/navbar.html:      margin-top: 3px;
libproxyobject/plugins/ogre/data/chrome/navbar.html:      padding-left: 6px;
libproxyobject/plugins/ogre/data/chrome/navbar.html:      margin-top: 1px;
libproxyobject/plugins/ogre/data/chrome/navbar.html:      border-width: 1px 0px 1px 1px;
libproxyobject/plugins/ogre/data/chrome/navbar.html:      border-color: #CCC;
libproxyobject/plugins/ogre/data/chrome/navbar.html:      border-style: solid;
libproxyobject/plugins/ogre/data/chrome/navbar.html:      margin-top: 6px;
libproxyobject/plugins/ogre/data/chrome/navbar.html:      margin-top: 6px;
Binary file libproxyobject/plugins/ogre/data/chrome/newtab_h.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/forward_p.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/back_d.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/forward.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/turnright_d.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/deltab.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/go_d.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/help_h.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/back.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/newtab_p.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/moveforward.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/reload_p.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/back_h.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/moveforward_d.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/go.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/newtab.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/reload.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/help_d.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/go_p.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/reload_d.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/back_p.png matches
Binary file libproxyobject/plugins/ogre/data/chrome/moveforward_h.png matches
libproxyobject/plugins/ogre/DragActions.hpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/DragActions.hpp:        totalPosition += (ent->globalLocation(now).getPosition());
libproxyobject/plugins/ogre/DragActions.hpp:    return -cameraAngle.zAxis();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceShader.cpp:  resourcePtr->parsed(true);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceShader.cpp:  mResource->loaded(true, mEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceShader.cpp:    resource->unloaded(true, mEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp:OptionValue*OPTION_VIDEO_MEMORY_RESOURCE_CACHE_SIZE = new OptionValue("video-memory-cache-size","1024",OptionValueType<int>(),"Number of megabytes to store from CDN in video memory");
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp:  mTransferPool = mTransferMediator->registerClient("OgreGraphics");
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp:  this->mTickListener = EventSource::getSingleton().subscribeId(
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp:  mBudget = OPTION_VIDEO_MEMORY_RESOURCE_CACHE_SIZE->as<int>() * 1024 * 1024;
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp:  EventSource::getSingleton().unsubscribe(this->mTickListener,false);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp:  return itr->second;
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp:  mIDResourceMap[curSharedPtr->getID()] = curSharedPtr;
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp:  mIDResourceMap[curSharedPtr->getID()] = curSharedPtr;
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp:    GraphicsResource::ParseState parseState = resource->getParseState();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp:      resource->parse();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp:    resource->updateValue(mEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp:    GraphicsResource* resource = mQueue.begin()->second;
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp:    float cost = resource->cost();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp:    ////////////////SILOG(resource,error,"Cost " << resource->cost() << " for "<<resource->getID()<<" is less than 0.");
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp:      GraphicsResource::LoadState loadState = resource->getLoadState();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp:        resource->load(mEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp:      resource->removeLoadDependencies(mEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp:    GraphicsResource::LoadState loadState = (*vitr)->getLoadState();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp:      (*vitr)->unload(mEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp:    mQueue.insert(pair<float, GraphicsResource*>(resource->value(), resource));
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp:  mQueue.insert(pair<float, GraphicsResource*>(resource->value(), resource));
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp:  itr = mQueue.find(pair<float, GraphicsResource*>(resource->value(), resource));
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp:  mIDResourceMap.erase(mIDResourceMap.find(resource->getID()));
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.hpp:     * This function gets a callback from the ReplacingDataStream whenever a material name depended-on is encountered
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.hpp:     * it uses this callback to replace internal material references with the now-known corresponding hash or third level name
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.hpp: * Naming-type tokens with the DataStream filename and __
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.hpp:     * \param input is another datastream this one piggy-backs on
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.hpp:     * \param textureAliases is a list of textures thirdname->first name list so that efficient materials can refer to the first names directly
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceTexture.cpp:  // The DDS format is stored in 32-bit little endian.
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceTexture.cpp:  resourcePtr->setCost(mBuffer.size());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceTexture.cpp:  resourcePtr->parsed(true);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceTexture.cpp:  mResource->loaded(true, mEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceTexture.cpp:  textureManager->remove(mHash.convertToHexString());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceTexture.cpp:  Ogre::ResourcePtr textureResource = textureManager->getByName(mHash.convertToHexString());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceTexture.cpp:    resource->unloaded(true, mEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceTexture.cpp:    : DependencyTask(mgr->getQueue()), mHash(hash)
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceTexture.cpp:    mHeaderTask->addDepender(this);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceTexture.cpp:    mDataTask->addDepender(this);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceTexture.cpp:	mHeaderTask->setRange(Transfer::Range(0, DDSHEADER_BYTESIZE, Transfer::BOUNDS));
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceTexture.cpp:    mHeaderTask->go();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceTexture.cpp:        --num_mipmaps;
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceTexture.cpp:        mDataTask->mergeData(sdata);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceTexture.cpp:                mDataTask->setRange(range);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceTexture.cpp:        mDataTask->go();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceTexture.cpp:                return; // We have a corrupt texture--not what we asked for!
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceTexture.cpp:            Transfer::Range range(0, DDSHEADER_BYTESIZE + (sdata.end()-iter),
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceTexture.cpp:            std::memcpy(fixedData->writableData(), header, DDSHEADER_BYTESIZE);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceTexture.cpp:            std::copy(iter, sdata.end(), fixedData->writableData()+DDSHEADER_BYTESIZE);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceTexture.cpp:            mOrigResourceRequestor->setResourceBuffer(SparseData(fixedData));
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceTexture.cpp:    mOrigResourceRequestor->setResourceBuffer(sdata);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp:        SharedResourcePtr hashResource = grm->getResourceAssetByHash(*hash, refType);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp:        resource->addDependency(hashResource);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp:        resource->parsed(true);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp:        resource->parsed(false);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp:      resource->parsed(false);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp:    SharedResourcePtr resourcePtr = itr->lock();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp:        resourcePtr->resolveName(mURI, assetPtr->getRemoteFileId());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp:        SILOG(resource,fatal,"Fatal: Dependency of GraphicsResourceName is not a GraphicsResourceAsset" << getID() << " -> " << (*mDependencies.begin())->getID());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp:        resourcePtr->resolveName(mURI, ResourceHash(URI((*mDependencies.begin())->getID())));
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp:      newParent.lock()->resolveName(mURI, assetPtr->getRemoteFileId());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp:      SILOG(resource,fatal,"Fatal: Dependency of GraphicsResourceName is not a GraphicsResourceAsset" << getID() << " -> " << (*mDependencies.begin())->getID());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp:      newParent.lock()->resolveName(mURI, ResourceHash(URI((*mDependencies.begin())->getID())));
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:    if (materialName.length()>2&&materialName[0]=='\"'&&materialName[materialName.length()-1]=='\"') {
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:        return mangleTextureName(resourceName,materialName.substr(1,materialName.length()-2));
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:    this->mTextureAliases=textureAliases;
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:        Ogre::NameValuePairList::const_iterator where=mTextureAliases->find("");
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:        if (where!=mTextureAliases->end()) {
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:            this->mSourceURI = URI(where->second);
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:    if (isspace(c)||c=='{'||(c=='/'&&comment_immunity==false&&return_lexeme_end+1<input.length()&&input[return_lexeme_end+1]=='/'&&(return_lexeme_end==where_lexeme_start||input[return_lexeme_end-1]!=':'))) {
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:      //  --return_lexeme_end;
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:  //if (return_lexeme_end>where_lexeme_start&&input[return_lexeme_end-1]=='\"') {
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:  //    --return_lexeme_end;
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:      Ogre::String provided=mangleTextureName(filename,input.substr(where_lexeme_start,return_lexeme_end-where_lexeme_start));
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:    if (input.length()>2&&input[0]=='\"'&&input[input.length()-1]=='\"') {
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:        return '\"'+possibleMhashCanonicalization(input.substr(1,input.length()-2))+'\"';
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:      Ogre::String depended=input.substr(where_lexeme_start,return_lexeme_end-where_lexeme_start);
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:      Ogre::String::size_type lexeme_start=second_input-input.begin(),return_lexeme_end;
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:          Ogre::String dep=input.substr(lexeme_start,return_lexeme_end-lexeme_start);
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:          retval+=input.substr(pwhere,lexeme_start-pwhere);
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:            uri = dep.substr(1,dep.length()-2);
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:            Ogre::NameValuePairList::const_iterator where=mTextureAliases->find(absURI);
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:            if (where!=mTextureAliases->end()) {
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:              uri=where->second;
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:    Ogre::String::size_type lexeme_start=second_input-input.begin(),return_lexeme_end;
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:      String dep=input.substr(lexeme_start,return_lexeme_end-lexeme_start);
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:        uri = dep.substr(1,dep.length()-2);
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:      Ogre::NameValuePairList::const_iterator where=mTextureAliases->find(absURI);
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:      if (where!=mTextureAliases->end()) {
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:        retval+=input.substr(pwhere,lexeme_start-pwhere);
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:        retval+=where->second;
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:      midval+=input.substr(pwhere,(what[0].second-input.begin())-pwhere);
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:      midval+=replace_lexeme(input,what[0].second-input.begin(),pwhere,mName);
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:          midval+=input.substr(pwhere,temp_size-pwhere);
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:        Ogre::String::size_type whereend=what[0].second-input.begin();
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:      midval+=input.substr(pwhere,(what[0].second-input.begin())-pwhere);
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:      midval+=full_replace_lexeme(input,what[0].second-input.begin(),pwhere,mName);
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:  size_t num_texture_aliases=mTextureAliases?mTextureAliases->size():0;
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:      for (Ogre::NameValuePairList::const_iterator iter=mTextureAliases->begin(),iterend=mTextureAliases->end();iter!=iterend;++iter) {
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:          if (iter->first.empty()) {
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:          cur_expr+=iter->first;
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:                  Ogre::NameValuePairList::const_iterator where=mTextureAliases->find(absURI);
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:                  if (where!=mTextureAliases->end()) {
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:                      retval+=midval.substr(pwhere,(what[0].first-midval.begin())-pwhere);
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:                      retval+=where->second;
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:                      pwhere=start-midval.begin();
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:    thus->dataAsString=thus->replaceData(thus->file->getAsString());
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:    thus->mSize=dataAsString.length();
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:    fwrite(dataAsString.data(),thus->mSize,1,fp);
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:    thus->helper=newhelper;
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:  provides=this->provides;
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:  depends_on=this->depends_on;
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:  return helper->read(buf,count);
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:  helper->skip(count);
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:  helper->seek(pos);
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:  return helper->tell();
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:  return helper->eof();
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:  helper->close();
libproxyobject/plugins/ogre/resourceManager/ReplacingDataStream.cpp:  file->close();
libproxyobject/plugins/ogre/resourceManager/ResourceManager.hpp:    /** Create a new resource from in-memory data.
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:OptionValue*OPTION_ENABLE_TEXTURES = new OptionValue("enable-textures","true",OptionValueType<bool>(),"Enable or disable texture rendering");
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:  Ogre::ResourcePtr meshResource = Ogre::MeshManager::getSingleton().getByName(resourcePtr->getID());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:  Ogre::Mesh::SubMeshIterator currSubMeshIter = meshPtr->getSubMeshIterator();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:    if (!OPTION_ENABLE_TEXTURES->as<bool>()) {
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:      curSubMesh->setMaterialName("BaseWhiteTexture");
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:      const Ogre::String& curMatName = curSubMesh->getMaterialName();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:      if (pos != -1) {
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:        std::map<String, String>::iterator itr = resourcePtr->mMaterialNames.find(start);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:        if (itr != resourcePtr->mMaterialNames.end())
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:          curSubMesh->setMaterialName(itr->second + ending);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:  if (OPTION_ENABLE_TEXTURES->as<bool>()) {
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:    for (itr = mBuffer.begin(), iend = mBuffer.end() - 7; itr != iend; ++itr) {
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:        SharedResourcePtr hashResource = grm->getResourceAsset(URI(matDep), GraphicsResource::MATERIAL);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:        resourcePtr->addDependency(hashResource);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:  resourcePtr->setCost(mBuffer.size());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:  resourcePtr->parsed(true);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:    Ogre::String skeletonName = meshPtr->getSkeletonName();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp://      SharedResourcePtr skeletonPtr = grm->createSkeletonResource(skeletonName);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp://      curResource->addChild(skeletonPtr);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:  //Ogre::SkeletonPtr skeletonPtr = Ogre::SkeletonManager::getSingleton().getByName(meshPtr->getSkeletonName());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:  //if ((!skeletonPtr.isNull()) && (skeletonPtr->isLoaded())) {
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:  //  meshPtr->_notifySkeleton(skeletonPtr);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:  mResource->loaded(true, mEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:  meshManager->remove(hash);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:  Ogre::ResourcePtr meshResource = meshManager->getByName(hash);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp:    resource->unloaded(true, mEpoch);
libproxyobject/plugins/ogre/resourceManager/ResourceLoadTask.cpp:: DependencyTask(mgr->getQueue()),
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:OptionValue*OPTION_VIDEO_MEMORY_RESOURCE_CACHE_SIZE = new OptionValue("video-memory-cache-size","1024",OptionValueType<int>(),"Number of megabytes to store from CDN in video memory");
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:  mTransferPool = mTransferMediator->registerClient("OgreGraphics");
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:  this->mTickListener = EventSource::getSingleton().subscribeId(
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:  mBudget = OPTION_VIDEO_MEMORY_RESOURCE_CACHE_SIZE->as<int>() * 1024 * 1024;
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:  EventSource::getSingleton().unsubscribe(this->mTickListener,false);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:  return itr->second;
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:  mIDResourceMap[curSharedPtr->getID()] = curSharedPtr;
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:  mIDResourceMap[curSharedPtr->getID()] = curSharedPtr;
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:    GraphicsResource::ParseState parseState = resource->getParseState();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:    cout<<"GRM list includes type: "<<resource->getType()<<endl;
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:      resource->parse();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:    resource->updateValue(mEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:    GraphicsResource* resource = mQueue.begin()->second;
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:    float cost = resource->cost();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:    ////////////////SILOG(resource,error,"Cost " << resource->cost() << " for "<<resource->getID()<<" is less than 0.");
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:      GraphicsResource::LoadState loadState = resource->getLoadState();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:        resource->load(mEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:      resource->removeLoadDependencies(mEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:    GraphicsResource::LoadState loadState = (*vitr)->getLoadState();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:      (*vitr)->unload(mEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:    mQueue.insert(pair<float, GraphicsResource*>(resource->value(), resource));
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:  mQueue.insert(pair<float, GraphicsResource*>(resource->value(), resource));
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:  itr = mQueue.find(pair<float, GraphicsResource*>(resource->value(), resource));
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceManager.cpp~:  mIDResourceMap.erase(mIDResourceMap.find(resource->getID()));
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp:  Ogre::ResourcePtr meshResource = Ogre::MeshManager::getSingleton().getByName(resourcePtr->getID());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp:  Ogre::Mesh::SubMeshIterator currSubMeshIter = meshPtr->getSubMeshIterator();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp:      curSubMesh->setMaterialName("BaseWhiteTexture");
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp:      const Ogre::String& curMatName = curSubMesh->getMaterialName();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp:      if (pos != -1) {
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp:        std::map<String, String>::iterator itr = resourcePtr->mMaterialNames.find(start);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp:        if (itr != resourcePtr->mMaterialNames.end())
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp:          curSubMesh->setMaterialName(itr->second + ending);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp:    for (itr = mBuffer.begin(), iend = mBuffer.end() - 7; itr != iend; ++itr) {
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp:        SharedResourcePtr hashResource = grm->getResourceAsset(URI(matDep), GraphicsResource::MATERIAL);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp:        resourcePtr->addDependency(hashResource);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp:  resourcePtr->setCost(mBuffer.size());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp:  resourcePtr->parsed(true);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp:    Ogre::String skeletonName = meshPtr->getSkeletonName();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp://      SharedResourcePtr skeletonPtr = grm->createSkeletonResource(skeletonName);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp://      curResource->addChild(skeletonPtr);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp://    mResource->loaded(true, mEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp:  meshManager->remove(hash);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp:  Ogre::ResourcePtr meshResource = meshManager->getByName(hash);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp:    resource->unloaded(true, mEpoch);
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:OptionValue*OPTION_THREADED_OGRE_COMPILER = new OptionValue("threaded-ogre-compiler","true",OptionValueType<bool>(),"Is the Ogre material compiler thread safe");
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:OptionValue*OPTION_THREADED_OGRE_GLSL_COMPILER = new OptionValue("threaded-ogre-glsl-compiler","false",OptionValueType<bool>(),"Is the Ogre material GLSL compiler thread safe");
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:    mStreamToBeLoadedInForeground->seek(0);
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:    mStreamToBeLoadedInForeground->seek(0);
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:    mStreamToBeLoadedInForeground->close();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:    bool prepare_material=mSourceStream->getName().find(".material")==String::npos||mSourceStream->getName().find("meru:///")!=0;//make sure it's a .material owned by r00t
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:                Ogre::Technique*tech=mat->createTechnique();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:                tech->setSchemeName("untextured");
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:                Ogre::Pass*pass=tech->createPass();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:                Ogre::TextureUnitState *tus=pass->createTextureUnitState("white.png",0);
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:                mat->prepare();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:            Ogre::Material::TechniqueIterator i = static_cast<Ogre::Material*>(&*resource)->getSupportedTechniqueIterator();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:                Ogre::Technique::PassIterator j = t->getPassIterator();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:                        p->getTextureUnitStateIterator();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:                        size_t nf=tus->getNumFrames();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:                            tus->_getTexturePtr(whichFrame)->prepare();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:            resource->prepare();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:            resource->prepare();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:            resource->unprepareImpl();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:            resource->unprepareImpl();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:            resource->unprepareImpl();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:                Ogre::Material::TechniqueIterator i = static_cast<Ogre::Material*>(&*resource)->getSupportedTechniqueIterator();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:                    Ogre::Technique::PassIterator j = t->getPassIterator();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:                            p->getTextureUnitStateIterator();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:                                size_t nf=tus->getNumFrames();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:                                    Ogre::TexturePtr tp=tus->_getTexturePtr(mWhichTextureFrame);
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:                                    if (tp.isNull()==false&&tp->isLoading()==false&&tp->isLoaded()==false) {
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:                                        assert(tp->isPrepared()==true);
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:                                        tus->_getTexturePtr(mWhichTextureFrame)->load();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:                    resource->load();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:                    resource->load();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:            finishMe->mTexturesInRam=true;
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:    bool threadsafe_ogre_compiler=OPTION_THREADED_OGRE_COMPILER->as<bool>();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:    bool threadsafe_ogre_glsl_compiler=OPTION_THREADED_OGRE_GLSL_COMPILER->as<bool>();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:        datastream->preprocessData(this->provides,this->depends_on);
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:    while (threadsafe_ogre_glsl_compiler==false&&hasGLSL==false&&!mStreamToBeLoadedInForeground->eof()) {
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:        len=mStreamToBeLoadedInForeground->read(search+6,1018);
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:  this->provides.clear();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:  this->depends_on.clear();
libproxyobject/plugins/ogre/resourceManager/ManualMaterialLoader.cpp:    textf->load();
libproxyobject/plugins/ogre/resourceManager/CDNArchiveFactory.cpp:    for (std::vector<Ogre::String>::iterator i=where->second.begin(),ie=where->second.end();i!=ie;++i) {
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.hpp:    PARSE_INVALID,     // current parse not valid -- needs parse
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.hpp:    cout<<"add dependency called in GR, adding "<<newResource->getType()<<" to type "<<mType<<endl<<endl;
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.hpp:    newResource->addDependent(getWeakPtr());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp~:        SharedResourcePtr hashResource = grm->getResourceAssetByHash(*hash, refType);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp~:        resource->addDependency(hashResource);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp~:        resource->parsed(true);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp~:        resource->parsed(false);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp~:      resource->parsed(false);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp~:    SharedResourcePtr resourcePtr = itr->lock();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp~:        resourcePtr->resolveName(mURI, assetPtr->getRemoteFileId());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp~:        SILOG(resource,fatal,"Fatal: Dependency of GraphicsResourceName is not a GraphicsResourceAsset" << getID() << " -> " << (*mDependencies.begin())->getID());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp~:        resourcePtr->resolveName(mURI, ResourceHash(URI((*mDependencies.begin())->getID())));
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp~:      newParent.lock()->resolveName(mURI, assetPtr->getRemoteFileId());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp~:      SILOG(resource,fatal,"Fatal: Dependency of GraphicsResourceName is not a GraphicsResourceAsset" << getID() << " -> " << (*mDependencies.begin())->getID());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceName.cpp~:      newParent.lock()->resolveName(mURI, ResourceHash(URI((*mDependencies.begin())->getID())));
libproxyobject/plugins/ogre/resourceManager/ResourceTransfer.hpp:/** Base class representing an in-progress resource transfer, either upload
libproxyobject/plugins/ogre/resourceManager/ResourceTransfer.hpp:		return (rd->id() == mID);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:OptionValue*OPTION_ENABLE_TEXTURES = new OptionValue("enable-textures","true",OptionValueType<bool>(),"Enable or disable texture rendering");
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:  Ogre::ResourcePtr meshResource = Ogre::MeshManager::getSingleton().getByName(resourcePtr->getID());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:  Ogre::Mesh::SubMeshIterator currSubMeshIter = meshPtr->getSubMeshIterator();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:    if (!OPTION_ENABLE_TEXTURES->as<bool>()) {
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:      curSubMesh->setMaterialName("BaseWhiteTexture");
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:      const Ogre::String& curMatName = curSubMesh->getMaterialName();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:      if (pos != -1) {
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:        std::map<String, String>::iterator itr = resourcePtr->mMaterialNames.find(start);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:        if (itr != resourcePtr->mMaterialNames.end())
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:          curSubMesh->setMaterialName(itr->second + ending);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:  if (OPTION_ENABLE_TEXTURES->as<bool>()) {
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:    for (itr = mBuffer.begin(), iend = mBuffer.end() - 7; itr != iend; ++itr) {
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:        SharedResourcePtr hashResource = grm->getResourceAsset(URI(matDep), GraphicsResource::MATERIAL);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:        resourcePtr->addDependency(hashResource);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:  resourcePtr->setCost(mBuffer.size());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:  resourcePtr->parsed(true);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:    Ogre::String skeletonName = meshPtr->getSkeletonName();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~://      SharedResourcePtr skeletonPtr = grm->createSkeletonResource(skeletonName);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~://      curResource->addChild(skeletonPtr);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:  //Ogre::SkeletonPtr skeletonPtr = Ogre::SkeletonManager::getSingleton().getByName(meshPtr->getSkeletonName());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:  //if ((!skeletonPtr.isNull()) && (skeletonPtr->isLoaded())) {
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:  //  meshPtr->_notifySkeleton(skeletonPtr);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:  mResource->loaded(true, mEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:  meshManager->remove(hash);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:  Ogre::ResourcePtr meshResource = meshManager->getByName(hash);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMesh.cpp~:    resource->unloaded(true, mEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:    (*(mDependencies.begin()))->addDepBenefit(mBenefit, epoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:    (*(mDependencies.begin()))->addDepBenefit(benefit, epoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:        cost += (*itr)->getDepCost(epoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:    mCurCost -= cost;
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:      SharedResourcePtr resourcePtr = itr->lock();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:        resourcePtr->updateCurCost(cost, epoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:    ParseState state = (*itr)->getParseState();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:      (*itr)->parse();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:    ParseState state = (*itr)->getParseState();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:    mDepCost += (*itr)->getDepCost(sCostPropEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:    SharedResourcePtr resource = itr->lock();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:      resource->dependencyParsed(succes);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:    (*itr)->removeDependent(weakPtr);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:        SharedResourcePtr resourcePtr = itr->lock();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:          resourcePtr->updateCurCost(mCost, sCostPropEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:      (*ditr)->removeLoadDependencies(epoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:    LoadState state = (*itr)->getLoadState();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:      (*itr)->load(mLoadEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:      LoadState state = (*itr)->getLoadState();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:    SharedResourcePtr resource = itr->lock();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:      resource->dependencyLoaded(succes);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:    SharedResourcePtr resourcePtr =  itr->lock();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:      LoadState state = resourcePtr->getLoadState();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:        resourcePtr->unload(mLoadEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:      SharedResourcePtr resourcePtr =  itr->lock();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:        LoadState state = resourcePtr->getLoadState();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp~:    (*itr)->dependentUnloaded(success);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.hpp~:    PARSE_INVALID,     // current parse not valid -- needs parse
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.hpp~:    newResource->addDependent(getWeakPtr());
libproxyobject/plugins/ogre/resourceManager/CDNArchive.cpp: *  All rights reserved. Go Bears! We beat you 34-28!
libproxyobject/plugins/ogre/resourceManager/CDNArchive.cpp:  if (filename.length() > 2 && filename[0] == '\"' && filename[filename.length()-1] == '\"') {
libproxyobject/plugins/ogre/resourceManager/CDNArchive.cpp:    filename = filename.substr(1, filename.length()-2);
libproxyobject/plugins/ogre/resourceManager/CDNArchive.cpp:  if (filename.length()>SHA256::hex_size+2&&memcmp(filename.data()+1,MERU_URI_HASH_PREFIX.c_str(),MERU_URI_HASH_PREFIX.size())==0&&filename[filename.length()-1]=='\"'&&filename[0]=='\"'){
libproxyobject/plugins/ogre/resourceManager/CDNArchive.cpp:    return filename.substr(filename.length()-SHA256::hex_size-1,SHA256::hex_size);
libproxyobject/plugins/ogre/resourceManager/CDNArchive.cpp:    return filename.substr(filename.length()-SHA256::hex_size);
libproxyobject/plugins/ogre/resourceManager/CDNArchive.cpp:  if (filename.length()>MERU_URI_HASH_PREFIX.size()+2&&memcmp(MERU_URI_HASH_PREFIX.c_str(),filename.data()+1,MERU_URI_HASH_PREFIX.size())==0&&filename[0]=='\"'&&filename[filename.length()-1]=='\"'){
libproxyobject/plugins/ogre/resourceManager/CDNArchive.cpp:      return filename.substr(endw+1,filename.length()-endw-2);
libproxyobject/plugins/ogre/resourceManager/CDNArchive.cpp:		return mIter - mData.begin();
libproxyobject/plugins/ogre/resourceManager/CDNArchive.cpp:    mNativeFileArchive=mOwner->addArchive();
libproxyobject/plugins/ogre/resourceManager/CDNArchive.cpp:        memcpy(dd->writableData(),native_files_data[i],size);
libproxyobject/plugins/ogre/resourceManager/CDNArchive.cpp:        mOwner->addArchiveDataNoLock(mNativeFileArchive, native_files[i], SparseData(rbuffer));
libproxyobject/plugins/ogre/resourceManager/CDNArchive.cpp:    mOwner->removeArchive(mNativeFileArchive);
libproxyobject/plugins/ogre/resourceManager/CDNArchive.cpp:  boost::mutex::scoped_lock lok(mOwner->CDNArchiveMutex);
libproxyobject/plugins/ogre/resourceManager/CDNArchive.cpp:      mOwner->CDNArchiveFiles.find(canonicalizeHash(filename));
libproxyobject/plugins/ogre/resourceManager/CDNArchive.cpp:  if (where != mOwner->CDNArchiveFiles.end()) {
libproxyobject/plugins/ogre/resourceManager/CDNArchive.cpp:      Ogre::DataStreamPtr inner (new CDNArchiveDataStream(mOwner, filename.substr(hintlen),where->second));
libproxyobject/plugins/ogre/resourceManager/CDNArchive.cpp:          ? filename.substr(filename.length() - SHA256::hex_size)
libproxyobject/plugins/ogre/resourceManager/CDNArchive.cpp:          : filename, where->second));
libproxyobject/plugins/ogre/resourceManager/CDNArchive.cpp:    boost::mutex::scoped_lock lok(mOwner->CDNArchiveMutex);
libproxyobject/plugins/ogre/resourceManager/CDNArchive.cpp:    if (mOwner->CDNArchiveFiles.find(canonicalizeHash(filename))!=mOwner->CDNArchiveFiles.end()) {
libproxyobject/plugins/ogre/resourceManager/CDNArchive.hpp:   * This function takes a hash-based URI or filename and extracts the salient bits---
libproxyobject/plugins/ogre/resourceManager/UploadTool.hpp:// filemap goes filename -> URI.
libproxyobject/plugins/ogre/resourceManager/UploadTool.hpp: * \param filesToUpload is vector of filesToUpload --all of these files should be uploaded
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp:    mTransferManager->upload(request,data,EventListener());
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp:    //mNameLookup->cdnLogin(username,password);
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp:    //mNameLookup->cdnLogout(username);
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp:    //return mNameLookup->cdnIsAuthenticated(username);
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp:        if (tevt->success()) {
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp:            EventSource::getSingleton().dispatch (new UploadCompleteEvent(tevt->uri()));
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp:            EventSource::getSingleton().dispatch (new UploadFailedEvent(tevt->uri()));
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp:        if (tevt->success()) {
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp:            EventSource::getSingleton().dispatch (new DownloadCompleteEvent(tevt->uri(),tevt->data()));
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp:            ResourceManagerLookup::DownloadCallbackMap::iterator where=mCallbacks->whereNotify.lower_bound(std::pair<URI,URI>(tevt->uri(),URI())),
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp:                where_end=mCallbacks->whereNotify.end(),
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp:            for (iter=where;iter!=where_end&&iter->first==tevt->uri();++iter) {
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp:                EventSource::getSingleton().dispatch (new DownloadCompleteEvent(iter->second,tevt->data()));
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp:            mCallbacks->whereNotify.erase(where,iter);
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp:            EventSource::getSingleton().dispatch (new DownloadFailedEvent(tevt->uri()));
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp:            ResourceManagerLookup::DownloadCallbackMap::iterator where=mCallbacks->whereNotify.lower_bound(std::pair<URI,URI>(tevt->uri(),URI())),where_end=mCallbacks->whereNotify.end(),iter;
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp:            for (iter=where;iter!=where_end&&iter->first==tevt->uri();++iter) {
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp:                EventSource::getSingleton().dispatch (new DownloadFailedEvent(iter->second));
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp:            mCallbacks->whereNotify.erase(where,iter);
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp:  return mTransferManager->downloadByHash(request,downloadFunctor,range);
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp:    mTransferManager->downloadName(resource_id,callback);
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp:    mTransferManager->downloadName(resource_id,callback);
libproxyobject/plugins/ogre/resourceManager/ResourceDependencyTask.cpp:: DependencyTask(mgr->getQueue()),
libproxyobject/plugins/ogre/resourceManager/ResourceUnloadTask.cpp:: DependencyTask(mgr->getQueue()),
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp~:      Location curLoc = mGraphicsEntity->getProxy().extrapolateLocation(Time::convertFrom(now,system->getLocalTimeOffset()->offset(mGraphicsEntity->getProxy())));
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp~:      std::list<CameraEntity*>::const_iterator cameraIter = system->mAttachedCameras.begin(),
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp~:        cameraEnd = system->mAttachedCameras.end();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp~:        Location avatarLoc = camera->getProxy().extrapolateLocation(Time::convertFrom(now,system->getLocalTimeOffset()->offset(camera->getProxy())));
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp~:        float dist = (curLoc.getPosition() - avatarLoc.getPosition()).length();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp~:        float radius = mGraphicsEntity->getBoundingInfo().radius();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp~:          //int64 elapsed = (CURRENT_TIME - mLoadTime).asMilliseconds();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp~:          //return (1.0f + exp(200.0f - elapsed)) *  mGraphicsEntity->getBoundingInfo().radius() / distSq;
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp~:    mGraphicsEntity->loadMesh(mMeshID.fingerprint().convertToHexString());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp~:    mGraphicsEntity->unloadMesh();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp~:    mDepCost = mCurMesh->getDepCost(sCostPropEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp~://  assert((*mDependencies.begin())->getID() == getID());
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:    (*(mDependencies.begin()))->addDepBenefit(mBenefit, epoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:    (*(mDependencies.begin()))->addDepBenefit(benefit, epoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:        cost += (*itr)->getDepCost(epoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:    mCurCost -= cost;
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:      SharedResourcePtr resourcePtr = itr->lock();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:        resourcePtr->updateCurCost(cost, epoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:    ParseState state = (*itr)->getParseState();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:      (*itr)->parse();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:    ParseState state = (*itr)->getParseState();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:    mDepCost += (*itr)->getDepCost(sCostPropEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:    SharedResourcePtr resource = itr->lock();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:      resource->dependencyParsed(succes);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:    (*itr)->removeDependent(weakPtr);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:        SharedResourcePtr resourcePtr = itr->lock();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:          resourcePtr->updateCurCost(mCost, sCostPropEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:      (*ditr)->removeLoadDependencies(epoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:    LoadState state = (*itr)->getLoadState();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:      (*itr)->load(mLoadEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:      LoadState state = (*itr)->getLoadState();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:    SharedResourcePtr resource = itr->lock();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:      resource->dependencyLoaded(succes);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:    SharedResourcePtr resourcePtr =  itr->lock();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:      LoadState state = resourcePtr->getLoadState();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:        resourcePtr->unload(mLoadEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:      SharedResourcePtr resourcePtr =  itr->lock();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:        LoadState state = resourcePtr->getLoadState();
libproxyobject/plugins/ogre/resourceManager/GraphicsResource.cpp:    (*itr)->dependentUnloaded(success);
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp:: DependencyTask(mgr->getQueue()), mHash(hash), mRange(true), mResourceRequestor(resourceRequestor)
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp:    iter->addToList<Transfer::DenseDataList>(iter.std::list<Transfer::DenseDataPtr>::const_iterator::operator*(), mMergeData);
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp:  if (transferEvent->success()) {
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp:    Transfer::SparseData finishedData = transferEvent->data();
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp:      iter->addToList<Transfer::DenseDataList>(iter.std::list<Transfer::DenseDataPtr>::const_iterator::operator*(), finishedData);
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp:    mResourceRequestor->setResourceBuffer(finishedData);
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp:  finish(transferEvent->success());
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp:    mResourceRequestor->setResourceBuffer(data);
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp:    cout<<"predicted size: "<<response->getSize()<<endl<<endl;
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp:    cout<<response->getSize()<<endl;
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp:    pool->addRequest(req);
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp:  pool->addRequest(req);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp:  if (mLoadTask && mLoadTask->isStarted())
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp:  /// FIXME: Um... yeah let's just leak the memory I guess...? -Patrick 2009-05-04
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp:  if (mUnloadTask && mUnloadTask->isStarted())
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp:    mUnloadTask->cancel();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp:  DependencyManager* depMgr = grm->getDependencyManager();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp:  depMgr->establishDependencyRelationship(mLoadTask, downloadTask);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp:  downloadTask->go();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp:    mLoadTask->cancel();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp:  DependencyManager* depMgr = grm->getDependencyManager();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp:  mUnloadTask->go();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp:  DependencyManager* depMgr = grm->getDependencyManager();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp:  depMgr->establishDependencyRelationship(mParseTask, downloadTask);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp:  downloadTask->go();
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:    if (s.length()>1&&s[0]=='\"'&&s[s.length()-1]=='\"')
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:        return s.substr(1,s.length()-2);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:-> specify mesh file. File is read into memory, and hash is computed.
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:// For material files, it is not possible to reference by hash because they can have self-referential URIs.
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:            fileinfo->mSourceFilename = name;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:            fileinfo->mReferencedByHash = false;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:            if (filename.find(".mesh")==filename.length()-strlen(".mesh")) { //&&filename.find("models")!=String::npos) {
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                fileinfo->mType = MESH;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                fileinfo->mType = MATERIAL;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                fileinfo->mType = DATA;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                fileinfo->mData = nativeDataPtr(filename, &fileinfo->mHash);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                fileinfo->mID = URI(opts.uploadHashContext,fileinfo->mHash.convertToHexString());
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                fileinfo->mID = namedURI;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                *uri = fileinfo->mID;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:    ///This is essentially an additional return value--the first level textures contained within this file (the others are provides and depends_on)
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:        this->opts=&opts;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:    Ogre::String provided=input.substr(where_lexeme_start,return_lexeme_end-where_lexeme_start);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:      Ogre::String::size_type lexeme_start=second_input-input.begin(),return_lexeme_end;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:          Ogre::String dep=input.substr(lexeme_start,return_lexeme_end-lexeme_start);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:      Ogre::String::size_type lexeme_start=second_input-input.begin(),return_lexeme_end;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:          Ogre::String dep=input.substr(lexeme_start,return_lexeme_end-lexeme_start);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:      Ogre::String depended=input.substr(where_lexeme_start,return_lexeme_end-where_lexeme_start);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:            filename=filename.substr(where+1,where_end-where-1);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:    this->provides_to_name=provides_to_name;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:    this->overarching_dependencies=overarching_dependencies;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:    this->my_dependencies=my_dependencies;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:    this->username=&username;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:      Ogre::String provided=input.substr(where_lexeme_start,return_lexeme_end-where_lexeme_start);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:      Ogre::String::size_type lexeme_start=second_input-input.begin(),return_lexeme_end;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:          Ogre::String dep=input.substr(lexeme_start,return_lexeme_end-lexeme_start);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:          retval+=input.substr(pwhere,lexeme_start-pwhere);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:      if (input.substr(last_newline, where_lexeme_start+8-last_newline-1).find("delegate")!=std::string::npos) {
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:      Ogre::String depended=input.substr(where_lexeme_start,return_lexeme_end-where_lexeme_start);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:      MaterialMap::const_iterator where=this->provides_to_name->find(depended);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:      if (where!=provides_to_name->end()) {
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:          if (where->second!=diskfilename) {
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:          DependencyPair * other_dep=getFileData(where->second,*username);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:          my_dependencies->files.insert(other_dep->files.begin(),other_dep->files.end());
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:          my_dependencies->files.insert(where->second);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:          return '\"'+getFileURI(where->second,*username)+':'+depended+'\"';
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:          my_dependencies->files.insert(other_dep->files.begin(),other_dep->files.end());
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:          my_dependencies->files.insert(wheresecond);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:  if (file->mData) {
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:  file->mHash=Fingerprint::null();
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:  String filefirst = stripslashes(file->mSourceFilename);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:  DenseDataPtr processed (getHashFileData(file->mSourceFilename));
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:  Fingerprint fileHash=Fingerprint::computeDigest(processed->data(), processed->length());
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:  file->mHash=fileHash;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:  file->mData = processed;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:    std::string data((const char *)dataptr->data(), (size_t)dataptr->length());
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                    processFileDependency(filemap.find(src)->second,filemap,materialmap,opts);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                unsigned int oldlen=(unsigned char)data[where-1];
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                oldlen+=(unsigned char)data[where-2];
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                oldlen+=(unsigned char)data[where-3];
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                oldlen+=(unsigned char)data[where-4];
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                    oldlen-=(unsigned int)strippedsrc.length();
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                    data[where-4]=oldlen%256;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                    data[where-3]=oldlen%256;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                    data[where-2]=oldlen%256;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                    data[where-1]=oldlen%256;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                /*std::string tmp=data.substr(where-(where>100?100:0),strippedsrc.length()+128);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:        if (i->second->mType != MATERIAL && i->second->mType != MESH) {
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:            if (replaceOne(data,i->first,std::string(),getFileURI(i->first, opts),filemap,materialmap,opts, true,allow_binary)) {
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                my_dependencies.files.insert(i->first);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                DependencyPair *dp=i->second;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                my_dependencies.files.insert(dp->files.begin(),dp->files.end());
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:        if (replaceOne(data,i->second,i->first,'\"'+getFileURI(i->second,opts)+":"+i->first+'\"',filemap,materialmap,opts,false,allow_binary)) {
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:            my_dependencies.files.insert(i->second);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:            DependencyPair *dp=getFileData(i->second,opts);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:            my_dependencies.files.insert(dp->files.begin(),dp->files.end());
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:    directory_iterator end_itr; // default construction yields past-the-end
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:        if ( is_directory(itr->status()) )
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:            if ( itr->leaf()!=".svn"&&itr->leaf()!="CVS"&&find_all_files( itr->path(), file_name, path_found ) ) {
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:        else if ( similarstr(itr->leaf(),file_name)&&(extension(itr->leaf())!=".xml"||dir_path.leaf()!="models") )
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:            path_found.push_back(itr->path());
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:          std::string temp=i->string();
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:              filenames.push_back(DiskFile::makediskfile(i->string()));
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:    if (deps->mType == MESH) {
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:    if (deps->mType == MATERIAL) {
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:          --i;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:          tmprds->preprocessData(provides,depends_on);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:              if ((dupe=opts.mMaterialMap.find(*iter))!=opts.mMaterialMap.end()&&getFileData(dupe->second,opts)->mData) {
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                  std::string s (getFileData(dupe->second,opts)->mID.toString());
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                          iter->c_str(),
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                  //printf ("%s provided by %s\n",iter->c_str(),filenames[i]);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:          for (size_t j=0;j<tmprds->dependsOnMaterial.size();++j) {
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:              if (opts.mMaterialMap[tmprds->dependsOnMaterial[j]]!=filenames[i]) {
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:            deps->files.insert(dep);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:    if (deps->mType == MATERIAL) {
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:                    --i;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:            DenseDataPtr data (new DenseData(rds->getAsString()));
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:            //printf ("Processing %s\n",dep->second.c_str());
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:            Fingerprint fileHash=Fingerprint::computeDigest(data->data(), data->length());
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:            mydeps->mHash = fileHash;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:            mydeps->mData = data;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:      if (!i->second->mData) {
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:          processFileDependency(i->second,opts.mFileMap,opts.mMaterialMap,opts);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:      if (iter->second->mData) {
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:          retval.push_back(*(iter->second));
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:      delete iter->second;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:        boost::unique_lock<boost::mutex> mylock (stat->mLock);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:        st = uploadev->getStatus();
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:        if (stat->mStatusMap.insert(ResourceStatusMap::value_type(current, st)).second==false) {
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:            std::cout << "Warning: Duplicate upload finished for "<<uploadev->uri()<<std::endl;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:        if (--stat->mNumberRemaining == 0) {
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:            stat->mCallback(stat->mStatusMap);
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:        std::cout <<"FINISHED UPLOAD " << current.mID << "! Number left = "<<stat->mNumberRemaining<<std::endl;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:        std::cout << "Uploading "<<stripslashes(current.mSourceFilename)<<" to URI " << current.mID<<". Hash = "<<current.mHash<<"; Size = "<<current.mData->length()<<std::endl;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:            tm->uploadByHash(Transfer::RemoteFileId(current.mHash, current.mID),
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:            tm->upload(current.mID,
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:    if (strncmp(argv[i],"-u",2)==0&&!match) {
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:    else if (strncmp(argv[i],"-d",2)==0&&!match) {
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:    }else if (strcmp(argv[i],"-1")==0&&!match) {
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:    }else if (strcmp(argv[i],"-3")==0&&!match) {
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:      for (j=i+1;j<argc;++j) argv[j-1]=argv[j];
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:      argc--;
libproxyobject/plugins/ogre/resourceManager/UploadTool.cpp:      i--;
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp~:: DependencyTask(mgr->getQueue()), mHash(hash), mRange(true), mResourceRequestor(resourceRequestor)
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp~:    iter->addToList<Transfer::DenseDataList>(iter.std::list<Transfer::DenseDataPtr>::const_iterator::operator*(), mMergeData);
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp~:  if (transferEvent->success()) {
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp~:    Transfer::SparseData finishedData = transferEvent->data();
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp~:      iter->addToList<Transfer::DenseDataList>(iter.std::list<Transfer::DenseDataPtr>::const_iterator::operator*(), finishedData);
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp~:    mResourceRequestor->setResourceBuffer(finishedData);
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp~:  finish(transferEvent->success());
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp~:    mResourceRequestor->setResourceBuffer(data);    
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp~:    cout<<"predicted size: "<<response->getSize()<<endl<<endl;
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp~:    cout<<response->getSize()<<endl;
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp~:    pool->addRequest(req);
libproxyobject/plugins/ogre/resourceManager/ResourceDownloadTask.cpp~:  pool->addRequest(req);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp~:  Ogre::ResourcePtr meshResource = Ogre::MeshManager::getSingleton().getByName(resourcePtr->getID());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp~:  Ogre::Mesh::SubMeshIterator currSubMeshIter = meshPtr->getSubMeshIterator();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp~:      curSubMesh->setMaterialName("BaseWhiteTexture");
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp~:      const Ogre::String& curMatName = curSubMesh->getMaterialName();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp~:      if (pos != -1) {
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp~:        std::map<String, String>::iterator itr = resourcePtr->mMaterialNames.find(start);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp~:        if (itr != resourcePtr->mMaterialNames.end())
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp~:          curSubMesh->setMaterialName(itr->second + ending);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp~:    for (itr = mBuffer.begin(), iend = mBuffer.end() - 7; itr != iend; ++itr) {
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp~:        SharedResourcePtr hashResource = grm->getResourceAsset(URI(matDep), GraphicsResource::MATERIAL);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp~:        resourcePtr->addDependency(hashResource);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp~:  resourcePtr->setCost(mBuffer.size());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp~:  resourcePtr->parsed(true);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp~:    Ogre::String skeletonName = meshPtr->getSkeletonName();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp~://      SharedResourcePtr skeletonPtr = grm->createSkeletonResource(skeletonName);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp~://      curResource->addChild(skeletonPtr);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp~://    mResource->loaded(true, mEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp~:  meshManager->remove(hash);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp~:  Ogre::ResourcePtr meshResource = meshManager->getByName(hash);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceModel.cpp~:    resource->unloaded(true, mEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp~:  if (mLoadTask && mLoadTask->isStarted())
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp~:  /// FIXME: Um... yeah let's just leak the memory I guess...? -Patrick 2009-05-04
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp~:  if (mUnloadTask && mUnloadTask->isStarted())
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp~:    mUnloadTask->cancel();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp~:  DependencyManager* depMgr = grm->getDependencyManager();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp~:  depMgr->establishDependencyRelationship(mLoadTask, downloadTask);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp~:  downloadTask->go();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp~:    mLoadTask->cancel();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp~:  DependencyManager* depMgr = grm->getDependencyManager();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp~:  mUnloadTask->go();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp~:  DependencyManager* depMgr = grm->getDependencyManager();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp~:  depMgr->establishDependencyRelationship(mParseTask, downloadTask);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceAsset.cpp~:  downloadTask->go();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp://       personal readability) - repeated code is not so great, maybe centralize this somewhere, later.
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:    if ((isspace(c)) || (c == '{') || ((c == '/'&&comment_immunity==false) && (return_lexeme_end + 1 < input.size()) && (*(iter+1) == '/') && ((return_lexeme_end == where_lexeme_start) || (*(iter-1) != ':')))) {
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:  if (return_lexeme_end>where_lexeme_start&&*--iter=='\"') {
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:    --return_lexeme_end;
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:    if (dat == *--end)
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:  Sirikata::Transfer::URIContext myURIContext = gfxmat->getURI().context();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:  static const char *programRefAndTextureUnitPattern = "(?:[[.newline.]](?:(?:(?:/[^/\n])|[^/\n])*(?#The left takes care of commented out lines -- newline then slashes followed by not slashes or not slashes )(?:[[:space:]]|\n))?((?:delegate|vertex_program_ref|shadow_caster_vertex_program_ref|fragment_program_ref|shadow_caster_fragment_program_ref|shadow_receiver_fragment_program_ref|shadow_receiver_vertex_program_ref)(?#To the left specifies all the types of references available in ogre...they must be preceeded by a space to be sure that we dont get vertex_program_ref counted as well as shadow_receiver_vertex_program_ref)(?:[[:space:]]|\n)+))(?# space then the goods come next)|(?:[[.newline.]](?:(?:(?:/[^/\n])|[^/\n])*(?#Make sure no comments exist in the line, same as starting exp)(?:[[:space:]]|\n)+)?((?:(?:texture)|(?:anim_texture)|(?:cubic_texture))(?#to the left is the specification of any texture references that could occur...then a space, and the goods)(?:[[:space:]]|\n)+))|(?:[[.newline.]](?:(?:(?:/[^/\n])|[^/\n])*(?#make sure source line is not commented out)(?:[[:space:]]|\n)+)?(source(?:[[:space:]]|\n)+))(?#The goods--source followed by space)|(?:^[[:space:]]*(import(?:[[:space:]]|\n)+[^[.NUL.]]+?(?:[[:space:]]|\n)+from(?#before the _from_ comes a bunch of junk but then its from and the file we care about)[[:space:]]+))";
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:      // Dependency found - set lexeme indices.
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:      lexemeBeginIndex = what[0].second - mBuffer.begin();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:        midpoint = std::find(protocol, MemoryBuffer::const_iterator(mBuffer.begin() + lexemeEndIndex), ':'); //FIXME legacy code <-- delete this line when second layer worked out
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:            SharedResourcePtr hashResource = grm->getResourceAsset(URI(myURIContext, dependencyName), GraphicsResource::MATERIAL);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:            resourcePtr->addDependency(hashResource);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:          SharedResourcePtr hashResource = grm->getResourceAsset(URI(myURIContext, dependencyName), GraphicsResource::MATERIAL);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:          resourcePtr->addDependency(hashResource);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:                SharedResourcePtr hashResource = grm->getResourceAsset(dependencyURI, GraphicsResource::TEXTURE);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:                  resourcePtr->addDependency(hashResource);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:            if (what[2].second-what[2].first>anim_texture_len
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:                    SharedResourcePtr hashResource = grm->getResourceAsset(dependencyURI, GraphicsResource::TEXTURE);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:                    resourcePtr->addDependency(hashResource);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:            }else if (what[2].second-what[2].first>cubic_texture_len
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:                      SharedResourcePtr hashResource = grm->getResourceAsset(dependencyURI, GraphicsResource::TEXTURE);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:                      resourcePtr->addDependency(hashResource);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:            SharedResourcePtr hashResource = grm->getResourceAsset(URI(myURIContext, dependencyName), GraphicsResource::SHADER);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:            resourcePtr->addDependency(hashResource);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:        SharedResourcePtr hashResource = grm->getResourceAsset(URI(myURIContext, dependencyName), GraphicsResource::MATERIAL);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:        resourcePtr->addDependency(hashResource);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:  resourcePtr->parsed(true);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:  mResource->loaded(true, mEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:  materialManager->remove(mHash.convertToHexString());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:  Ogre::ResourcePtr materialResource = materialManager->getByName(mHash.convertToHexString());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceMaterial.cpp:    resource->unloaded(true, mEpoch);
libproxyobject/plugins/ogre/resourceManager/ResourceLoadingQueue.cpp:        rm->load(req.resourceName, req.groupName, req.isManual,
libproxyobject/plugins/ogre/resourceManager/ResourceLoadingQueue.cpp:            rm->unload(req.resourceHandle);
libproxyobject/plugins/ogre/resourceManager/ResourceLoadingQueue.cpp:            rm->unload(req.resourceName);
libproxyobject/plugins/ogre/resourceManager/ResourceLoadingQueue.cpp:        req.listener->operationCompletedInThread(req.ticketID);
libproxyobject/plugins/ogre/resourceManager/ResourceLoadingQueue.cpp:        req.listener->operationCompleted(req.ticketID);
libproxyobject/plugins/ogre/resourceManager/ResourceLoadingQueue.cpp:            this->processBackgroundEvent();
libproxyobject/plugins/ogre/resourceManager/ResourceLoadingQueue.cpp:    this->processBackgroundEvents(e);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceSkeleton.cpp:  mManager->establishDependencyRelationship(*dependentIter, skeletonLoadTask);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceSkeleton.cpp:  mManager->establishDependencyRelationship(skeletonLoadTask, skeletonDownloadTask);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceSkeleton.cpp:   : DependencyTask(mgr->getQueue()), mName(name)
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceSkeleton.cpp:    if (skeletonPtr.isNull() || !skeletonPtr->isLoaded()) {
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceSkeleton.cpp:      queue->load(Ogre::SkeletonManager::getSingleton().getResourceType(), mName, Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, false, NULL, NULL, this);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp:      Location curLoc = mGraphicsEntity->getProxy().extrapolateLocation(Time::convertFrom(now,system->getLocalTimeOffset()->offset(mGraphicsEntity->getProxy())));
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp:      std::list<CameraEntity*>::const_iterator cameraIter = system->mAttachedCameras.begin(),
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp:        cameraEnd = system->mAttachedCameras.end();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp:        Location avatarLoc = camera->getProxy().extrapolateLocation(Time::convertFrom(now,system->getLocalTimeOffset()->offset(camera->getProxy())));
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp:        float dist = (curLoc.getPosition() - avatarLoc.getPosition()).length();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp:        float radius = mGraphicsEntity->getBoundingInfo().radius();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp:          //int64 elapsed = (CURRENT_TIME - mLoadTime).asMilliseconds();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp:          //return (1.0f + exp(200.0f - elapsed)) *  mGraphicsEntity->getBoundingInfo().radius() / distSq;
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp:    mGraphicsEntity->loadMesh(mMeshID.fingerprint().convertToHexString());
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp:    mGraphicsEntity->unloadMesh();
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp:    mDepCost = mCurMesh->getDepCost(sCostPropEpoch);
libproxyobject/plugins/ogre/resourceManager/GraphicsResourceEntity.cpp://  assert((*mDependencies.begin())->getID() == getID());
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp~:    mTransferManager->upload(request,data,EventListener());
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp~:    //mNameLookup->cdnLogin(username,password);
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp~:    //mNameLookup->cdnLogout(username);
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp~:    //return mNameLookup->cdnIsAuthenticated(username);
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp~:        if (tevt->success()) {
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp~:            EventSource::getSingleton().dispatch (new UploadCompleteEvent(tevt->uri()));
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp~:            EventSource::getSingleton().dispatch (new UploadFailedEvent(tevt->uri()));
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp~:        if (tevt->success()) {
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp~:            EventSource::getSingleton().dispatch (new DownloadCompleteEvent(tevt->uri(),tevt->data()));
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp~:            ResourceManagerLookup::DownloadCallbackMap::iterator where=mCallbacks->whereNotify.lower_bound(std::pair<URI,URI>(tevt->uri(),URI())),
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp~:                where_end=mCallbacks->whereNotify.end(),
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp~:            for (iter=where;iter!=where_end&&iter->first==tevt->uri();++iter) {
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp~:                EventSource::getSingleton().dispatch (new DownloadCompleteEvent(iter->second,tevt->data()));
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp~:            mCallbacks->whereNotify.erase(where,iter);
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp~:            EventSource::getSingleton().dispatch (new DownloadFailedEvent(tevt->uri()));
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp~:            ResourceManagerLookup::DownloadCallbackMap::iterator where=mCallbacks->whereNotify.lower_bound(std::pair<URI,URI>(tevt->uri(),URI())),where_end=mCallbacks->whereNotify.end(),iter;
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp~:            for (iter=where;iter!=where_end&&iter->first==tevt->uri();++iter) {
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp~:                EventSource::getSingleton().dispatch (new DownloadFailedEvent(iter->second));
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp~:            mCallbacks->whereNotify.erase(where,iter);
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp~:  return mTransferManager->downloadByHash(request,downloadFunctor,range);
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp~:    mTransferManager->downloadName(resource_id,callback);
libproxyobject/plugins/ogre/resourceManager/ResourceManager.cpp~:    mTransferManager->downloadName(resource_id,callback);
libproxyobject/plugins/ogre/CameraEntity.cpp:             ogreName.length()?ogreName:ogreName=ogreCameraName(pco->getObjectReference()),
libproxyobject/plugins/ogre/CameraEntity.cpp:    mAttachedIter=scene->mAttachedCameras.end();
libproxyobject/plugins/ogre/CameraEntity.cpp:    if (scene->getSceneManager()->hasCamera(cameraName)) {
libproxyobject/plugins/ogre/CameraEntity.cpp:        init(scene->getSceneManager()->getCamera(cameraName));
libproxyobject/plugins/ogre/CameraEntity.cpp:        init(scene->getSceneManager()->createCamera(cameraName));
libproxyobject/plugins/ogre/CameraEntity.cpp:    getOgreCamera()->setNearClipDistance(scene->getOptions()->referenceOption("nearplane")->as<float32>());
libproxyobject/plugins/ogre/CameraEntity.cpp:    getOgreCamera()->setFarClipDistance(scene->getOptions()->referenceOption("farplane")->as<float32>());
libproxyobject/plugins/ogre/CameraEntity.cpp:    this->detach();
libproxyobject/plugins/ogre/CameraEntity.cpp:    mRenderTarget = mScene->createRenderTarget(renderTargetName,
libproxyobject/plugins/ogre/CameraEntity.cpp:    mViewport= mRenderTarget->addViewport(getOgreCamera());
libproxyobject/plugins/ogre/CameraEntity.cpp:    mViewport->setBackgroundColour(Ogre::ColourValue(0,.125,.25,1));
libproxyobject/plugins/ogre/CameraEntity.cpp:    getOgreCamera()->setAspectRatio((float32)mViewport->getActualWidth()/(float32)mViewport->getActualHeight());
libproxyobject/plugins/ogre/CameraEntity.cpp:    mAttachedIter = mScene->attachCamera(renderTargetName,this);
libproxyobject/plugins/ogre/CameraEntity.cpp:        mRenderTarget->removeViewport(mViewport->getZOrder());
libproxyobject/plugins/ogre/CameraEntity.cpp:  unsigned int numViewports=sm->getNumViewports();
libproxyobject/plugins/ogre/CameraEntity.cpp:  if (sm->getViewport(i)==mViewport) {
libproxyobject/plugins/ogre/CameraEntity.cpp:  sm->removeViewport(i);
libproxyobject/plugins/ogre/CameraEntity.cpp:        mScene->destroyRenderTarget(mRenderTarget->getName());
libproxyobject/plugins/ogre/CameraEntity.cpp:    mAttachedIter=mScene->detachCamera(mAttachedIter);
libproxyobject/plugins/ogre/CameraEntity.cpp:    if (mAttachedIter != mScene->mAttachedCameras.end()) {
libproxyobject/plugins/ogre/CameraEntity.cpp:        mScene->mAttachedCameras.erase(mAttachedIter);
libproxyobject/plugins/ogre/CameraEntity.cpp:    mScene->getSceneManager()->destroyCamera(toDestroy);
libproxyobject/plugins/ogre/CameraPath.hpp: *  Copyright (c) 2009, Ewen Cheslack-Postava
libproxyobject/plugins/ogre/CubeMap.cpp:/*  Sirikata libproxyobject -- Ogre Graphics Plugin
libproxyobject/plugins/ogre/CubeMap.cpp:    cam->setOrientation(Ogre::Quaternion::IDENTITY);
libproxyobject/plugins/ogre/CubeMap.cpp:        cam->yaw(-Ogre::Radian(Ogre::Math::PI/2));
libproxyobject/plugins/ogre/CubeMap.cpp:        cam->yaw(Ogre::Radian(Ogre::Math::PI/2));
libproxyobject/plugins/ogre/CubeMap.cpp:        cam->pitch(Ogre::Radian(Ogre::Math::PI/2));
libproxyobject/plugins/ogre/CubeMap.cpp:        cam->pitch(-Ogre::Radian(Ogre::Math::PI/2));
libproxyobject/plugins/ogre/CubeMap.cpp:         cam->yaw( Ogre::Radian( Ogre::Math::PI ) );
libproxyobject/plugins/ogre/CubeMap.cpp:                    mParent->getSceneManager()->destroyCamera(mState[j].mCamera);
libproxyobject/plugins/ogre/CubeMap.cpp:                    Ogre::TextureManager::getSingleton().remove(mState[j].mCubeMapTexture->getName());
libproxyobject/plugins/ogre/CubeMap.cpp:        mState.back().mCamera=mParent->getSceneManager()->createCamera(UUID::random().toString()+"CubeMapCamera");
libproxyobject/plugins/ogre/CubeMap.cpp:        //mParent->getSceneManager()->getRootSceneNode()->attachObject( mCamera);
libproxyobject/plugins/ogre/CubeMap.cpp:        mState.back().mCamera->setNearClipDistance(cameraNearPlanes[i]);
libproxyobject/plugins/ogre/CubeMap.cpp:        mState.back().mCamera->setAspectRatio(1);
libproxyobject/plugins/ogre/CubeMap.cpp:        mState.back().mCamera->setFOVy(Ogre::Radian(Ogre::Math::PI/2));
libproxyobject/plugins/ogre/CubeMap.cpp:                (j==0?mBackbuffer:mState[j-1].mFrontbuffer)[i] = Ogre::TextureManager::getSingleton()
libproxyobject/plugins/ogre/CubeMap.cpp:                mParent->getSceneManager()->destroyCamera(mState[j].mCamera);
libproxyobject/plugins/ogre/CubeMap.cpp:                Ogre::TextureManager::getSingleton().remove(mState[j].mCubeMapTexture->getName());
libproxyobject/plugins/ogre/CubeMap.cpp:        mCubeMapSceneCamera[i]=mCubeMapScene->createCamera(mBackbuffer[i]->getName());
libproxyobject/plugins/ogre/CubeMap.cpp:        mCubeMapSceneCamera[i]->setPosition(0,0,0);
libproxyobject/plugins/ogre/CubeMap.cpp:        mCubeMapScene->getRootSceneNode()->attachObject( mCubeMapSceneCamera[i]);
libproxyobject/plugins/ogre/CubeMap.cpp:        mCubeMapSceneCamera[i]->setNearClipDistance(0.1f);
libproxyobject/plugins/ogre/CubeMap.cpp:        mCubeMapSceneCamera[i]->setAspectRatio(1);
libproxyobject/plugins/ogre/CubeMap.cpp:        mCubeMapSceneCamera[i]->setFOVy(Ogre::Radian(Ogre::Math::PI/2));
libproxyobject/plugins/ogre/CubeMap.cpp:            offset=Ogre::Vector3(-1,0,0);
libproxyobject/plugins/ogre/CubeMap.cpp:            offset=Ogre::Vector3(0,-1,0);
libproxyobject/plugins/ogre/CubeMap.cpp:            offset=Ogre::Vector3(0,0,reverse?-1:1);
libproxyobject/plugins/ogre/CubeMap.cpp:            offset=Ogre::Vector3(0,0,reverse?1:-1);
libproxyobject/plugins/ogre/CubeMap.cpp:            .create(mBackbuffer[i]->getName()+"Mat",
libproxyobject/plugins/ogre/CubeMap.cpp:        mat->setCullingMode(Ogre::CULL_NONE);
libproxyobject/plugins/ogre/CubeMap.cpp:        Ogre::Technique* tech=mat->getTechnique(0);
libproxyobject/plugins/ogre/CubeMap.cpp:        Ogre::Pass*pass=tech->getPass(0);
libproxyobject/plugins/ogre/CubeMap.cpp:        Ogre::TextureUnitState*tus=pass->createTextureUnitState();
libproxyobject/plugins/ogre/CubeMap.cpp:        tus->setTextureName(mBackbuffer[i]->getName());
libproxyobject/plugins/ogre/CubeMap.cpp:        tus->setTextureCoordSet(0);
libproxyobject/plugins/ogre/CubeMap.cpp:        tus=pass->createTextureUnitState();
libproxyobject/plugins/ogre/CubeMap.cpp:        tus->setTextureName(mState[0].mFrontbuffer[i]->getName());
libproxyobject/plugins/ogre/CubeMap.cpp:        tus->setTextureCoordSet(0);
libproxyobject/plugins/ogre/CubeMap.cpp:        tus->setColourOperationEx(Ogre::LBX_BLEND_MANUAL,
libproxyobject/plugins/ogre/CubeMap.cpp:        tus->setColourOpMultipassFallback(Ogre::SBF_SOURCE_ALPHA,Ogre::SBF_ONE_MINUS_SOURCE_ALPHA);
libproxyobject/plugins/ogre/CubeMap.cpp:        Ogre::MeshPtr msh=Ogre::MeshManager::getSingleton().createPlane(mBackbuffer[i]->getName()+"Plane",
libproxyobject/plugins/ogre/CubeMap.cpp:                                                                        Ogre::Plane((reverse&&(i==1||i==0||i==4||i==5))?-offset:offset,0),
libproxyobject/plugins/ogre/CubeMap.cpp:                                                                        sizeScale,sizeScale,1,1,false,1,1.0,((reverse&&(i==3||i==2))?-1.0:1.0),up);
libproxyobject/plugins/ogre/CubeMap.cpp:        Ogre::Entity* ent=mCubeMapScene->createEntity(mBackbuffer[i]->getName()+"Entity",
libproxyobject/plugins/ogre/CubeMap.cpp:                                                      mBackbuffer[i]->getName()+"Plane");
libproxyobject/plugins/ogre/CubeMap.cpp:        ent->setMaterialName(mBackbuffer[i]->getName()+"Mat");
libproxyobject/plugins/ogre/CubeMap.cpp:        mCubeMapScene->getRootSceneNode()->createChildSceneNode(-offset*0.5f*sizeScale)->attachObject(ent);
libproxyobject/plugins/ogre/CubeMap.cpp:        Ogre::RenderTarget *renderTarget =mBackbuffer[i]->getBuffer(0)->getRenderTarget();
libproxyobject/plugins/ogre/CubeMap.cpp:        renderTarget->addListener(&mFaces[i]);
libproxyobject/plugins/ogre/CubeMap.cpp:            renderTarget =mState[j].mFrontbuffer[i]->getBuffer(0)->getRenderTarget();
libproxyobject/plugins/ogre/CubeMap.cpp:            renderTarget->addListener(&mFaces[i]);
libproxyobject/plugins/ogre/CubeMap.cpp:        mAlpha-=.03125;
libproxyobject/plugins/ogre/CubeMap.cpp:        mMaterials[i]->getTechnique(0)->getPass(0)->getTextureUnitState(0)->setTextureName(mBackbuffer[i]->getName());
libproxyobject/plugins/ogre/CubeMap.cpp:        mMaterials[i]->getTechnique(0)->getPass(0)->getTextureUnitState(1)->setTextureName(mState[mMapCounter].mFrontbuffer[i]->getName());
libproxyobject/plugins/ogre/CubeMap.cpp:        mMaterials[i]->getTechnique(0)->getPass(0)->getTextureUnitState(1)->
libproxyobject/plugins/ogre/CubeMap.cpp:                                 clamp01(mFrontbufferCloser?1.0-mAlpha:mAlpha));
libproxyobject/plugins/ogre/CubeMap.cpp:    if (delta.x<0) delta.x=-delta.x;
libproxyobject/plugins/ogre/CubeMap.cpp:    if (delta.y<0) delta.y=-delta.y;
libproxyobject/plugins/ogre/CubeMap.cpp:    if (delta.z<0) delta.z=-delta.z;
libproxyobject/plugins/ogre/CubeMap.cpp:        Ogre::Vector3 curCamera=toOgre(mParent->getPrimaryCamera()->getOgrePosition(),mParent->getOffset());
libproxyobject/plugins/ogre/CubeMap.cpp:        Ogre::Vector3 delta=curCamera-mState[mMapCounter].mLastActualPosition;
libproxyobject/plugins/ogre/CubeMap.cpp:        if (tooSmall(curCamera-mState[mMapCounter].mLastRenderedPosition)&&!(curCamera==mState[mMapCounter].mFirstCameraPosition)) {
libproxyobject/plugins/ogre/CubeMap.cpp:        mState[mMapCounter].mCamera->setPosition(toOgre(mParent->getPrimaryCamera()->getOgrePosition()+Vector3d(mState[mMapCounter].mCameraDelta),mParent->getOffset()));
libproxyobject/plugins/ogre/CubeMap.cpp:        mBackbuffer[mFaceCounter-1]->getBuffer(0)->getRenderTarget()->removeAllViewports();
libproxyobject/plugins/ogre/CubeMap.cpp:        Ogre::Viewport *viewport = mBackbuffer[mFaceCounter]->getBuffer(0)->getRenderTarget()->addViewport( mState[mMapCounter].mCamera );
libproxyobject/plugins/ogre/CubeMap.cpp:        viewport->setOverlaysEnabled(false);
libproxyobject/plugins/ogre/CubeMap.cpp:        viewport->setClearEveryFrame( true );
libproxyobject/plugins/ogre/CubeMap.cpp:        viewport->setBackgroundColour( Ogre::ColourValue(0,0,0,0) );
libproxyobject/plugins/ogre/CubeMap.cpp:            Ogre::Viewport *viewport = mState[mMapCounter].mCubeMapTexture->getBuffer(i)->getRenderTarget()->addViewport( mCubeMapSceneCamera[i] );
libproxyobject/plugins/ogre/CubeMap.cpp:            viewport->setOverlaysEnabled(false);
libproxyobject/plugins/ogre/CubeMap.cpp:            viewport->setClearEveryFrame( true );
libproxyobject/plugins/ogre/CubeMap.cpp:            viewport->setBackgroundColour( Ogre::ColourValue(1,0,0,1) );
libproxyobject/plugins/ogre/CubeMap.cpp:            mState[mMapCounter].mCubeMapTexture->getBuffer(i)->getRenderTarget()->removeAllViewports();
libproxyobject/plugins/ogre/CubeMap.cpp:    mParent->preRenderTargetUpdate(NULL,this-&mParent->mFaces[0],evt);
libproxyobject/plugins/ogre/CubeMap.cpp:        mParent->getSceneManager()->destroyCamera(mState[j].mCamera);
libproxyobject/plugins/ogre/CubeMap.cpp:        Ogre::RenderTarget *renderTarget = mBackbuffer[i]->getBuffer(0)->getRenderTarget();
libproxyobject/plugins/ogre/CubeMap.cpp:        renderTarget->removeListener(&mFaces[i]);
libproxyobject/plugins/ogre/CubeMap.cpp:        renderTarget->removeAllViewports();
libproxyobject/plugins/ogre/CubeMap.cpp:        Ogre::MaterialManager::getSingleton().remove(mBackbuffer[i]->getName()+"Mat");
libproxyobject/plugins/ogre/CubeMap.cpp:        mCubeMapScene->destroyCamera(mCubeMapSceneCamera[i]);
libproxyobject/plugins/ogre/CubeMap.cpp:        Ogre::TextureManager::getSingleton().remove(mBackbuffer[i]->getName());
libproxyobject/plugins/collada/ColladaPlugin.hpp:/*  Sirikata libproxyobject -- Object Host Plugin for COLLADA
libproxyobject/plugins/collada/ColladaDocument.cpp:/*  Sirikata libproxyobject -- COLLADA Models Document
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:/*  Sirikata libproxyobject -- COLLADA Document Importer
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    if (meshstore.find(mDocument->getURI().toString()) != meshstore.end())
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    meshstore[mDocument->getURI().toString()] = new Meshdata();
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    meshstore[mDocument->getURI().toString()]->uri = mDocument->getURI().toString();
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    return mDocument->getURI().toString();
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:// We need this to be a non-local definition, so hide it in a namespace
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    NodeState(const COLLADAFW::Node* _node, COLLADABU::Math::Matrix4 _matrix, int _child = -1, Modes _mode = Geo)
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:        geometry_indices[geo_it->first] = idx;
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:        meshstore[documentURI()]->geometry.push_back( geo_it->second );
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    const COLLADAFW::VisualScene* vis_scene = vis_scene_it->second;
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    for(int i = 0; i < vis_scene->getRootNodes().getCount(); i++) {
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:        const COLLADAFW::Node* rn = vis_scene->getRootNodes()[i];
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:                COLLADABU::Math::Matrix4 additional_xform = curnode.node->getTransformationMatrix();
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:                for(int geo_idx = 0; geo_idx < curnode.node->getInstanceGeometries().getCount(); geo_idx++) {
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:                    const COLLADAFW::InstanceGeometry* geo_inst = curnode.node->getInstanceGeometries()[geo_idx];
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:                    IndicesMap::const_iterator geo_it = geometry_indices.find(geo_inst->getInstanciatedObjectId());
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:                    new_geo_inst.geometryIndex = geo_it->second;
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:                    meshstore[documentURI()]->instances.push_back(new_geo_inst);
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:                if (curnode.child >= curnode.node->getInstanceNodes().getCount()) {
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:                    COLLADAFW::UniqueId node_uniq_id = curnode.node->getInstanceNodes()[curnode.child]->getInstanciatedObjectId();
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:                    const COLLADAFW::Node* instanced_node = node_it->second;
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:                if (curnode.child < curnode.node->getChildNodes().getCount()) {
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:                    node_stack.push( NodeState(curnode.node->getChildNodes()[curnode.child], curnode.matrix) );
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    if (meshstore[mDocument->getURI().toString()]->instances.size() > 0) {
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    //    std::tr1::shared_ptr<ProxyMeshObject>(mProxyPtr).get()->meshParsed( mDocument->getURI().toString(),
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    //                                          meshstore[mDocument->getURI().toString()] );
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:        spp->meshParsed( mDocument->getURI().toString(), meshstore[mDocument->getURI().toString()] );
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    bool ok = mDocument->import ( *this, *asset );
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    meshstore[mDocument->getURI().toString()]->up_axis=asset->getUpAxisType();
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    const COLLADAFW::InstanceVisualScene* inst_vis_scene = scene->getInstanceVisualScene();
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    mVisualSceneId = inst_vis_scene->getInstanciatedObjectId();
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    mVisualScenes[visualScene->getUniqueId()] = visualScene;
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    for(int idx = 0; idx < libraryNodes->getNodes().getCount(); idx++) {
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:        const COLLADAFW::Node* node = libraryNodes->getNodes()[idx];
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:        mLibraryNodes[node->getUniqueId()] = node;
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    String uri = mDocument->getURI().toString();
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    submesh->name = mesh->getName();
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    //COLLADAFW::MeshVertexData const v(mesh->getPositions());            // private data error!
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    COLLADAFW::MeshVertexData const* verts(&(mesh->getPositions()));      // but this works?
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    COLLADAFW::MeshVertexData const* norms(&(mesh->getNormals()));
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    COLLADAFW::MeshVertexData const* UVs(&(mesh->getUVCoords()));
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    COLLADAFW::MeshPrimitiveArray const* primitives(&(mesh->getMeshPrimitives()));
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    if (!(*primitives)[0]->getPrimitiveType()==COLLADAFW::MeshPrimitive::TRIANGLES) {
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    COLLADAFW::UIntValuesArray const* pi(&((*primitives)[0]->getPositionIndices()));
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    COLLADAFW::UIntValuesArray const* ni(&((*primitives)[0]->getNormalIndices()));
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    if ( ((*primitives)[0]->getUVCoordIndicesArray()).getCount() > 0 ) {
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:        COLLADAFW::IndexList const* uv_ilist = ((*primitives)[0]->getUVCoordIndices(0)); // FIXME 0
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:        assert(uv_ilist->getStride() == 2);
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:        uvi = (&(uv_ilist->getIndices()));
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    int vcnt = verts->getValuesCount();
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    int ncnt = norms->getValuesCount();
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    unsigned int icnt = pi->getCount();
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    int uvcnt = UVs->getValuesCount();
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    if (icnt != ni->getCount()) {
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    if (uvi != NULL && icnt != uvi->getCount()) {
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    COLLADAFW::FloatArray const* vdata = verts->getFloatValues();
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    COLLADAFW::FloatArray const* ndata = norms->getFloatValues();
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    COLLADAFW::FloatArray const* uvdata = UVs->getFloatValues();
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:        float const* raw = vdata->getData();
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:            submesh->positions.push_back(Vector3f(raw[i],raw[i+1],raw[i+2]));
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:        raw = ndata->getData();
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:            submesh->normals.push_back(Vector3f(raw[i],raw[i+1],raw[i+2]));
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:            raw = uvdata->getData();
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:                submesh->texUVs.push_back(Vector2f(raw[i],raw[i+1]));
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:        unsigned int const* praw = pi->getData();
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:        unsigned int const* nraw = ni->getData();
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:        unsigned int const* uvraw = uvi != NULL ? uvi->getData() : NULL;
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:            submesh->position_indices.push_back(praw[i]);
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:            submesh->normal_indices.push_back(nraw[i]);
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:                submesh->texUV_indices.push_back(uvraw[i]);
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    mGeometries[geometry->getUniqueId()] = submesh;
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    bool ok = mDocument->import ( *this, *geometry );
libproxyobject/plugins/collada/ColladaDocumentImporter.cpp:    meshstore[mDocument->getURI().toString()]->textures.push_back(image->getImageURI().getURIString());  /// not really -- among other sins, lowercase!
libproxyobject/plugins/collada/ColladaSystem.hpp:/*  Sirikata libproxyobject -- Collada Models System
libproxyobject/plugins/collada/ColladaErrorHandler.cpp:/*  Sirikata libproxyobject -- COLLADA Error Handler
libproxyobject/plugins/collada/ColladaErrorHandler.cpp:	return  error->getSeverity () == COLLADASaxFWL::IError::SEVERITY_CRITICAL;
libproxyobject/plugins/collada/ColladaDocumentLoader.cpp:/*  Sirikata libproxyobject -- COLLADA Models Document Loader
libproxyobject/plugins/collada/ColladaDocumentLoader.cpp:    bool ok = mFramework->loadDocument ( getDocument()->getURI().toString(), buffer, bufferLength );
libproxyobject/plugins/collada/ColladaDocumentLoader.cpp:    return mDocumentImporter->getDocument ();
libproxyobject/plugins/collada/ColladaDocument.hpp:/*  Sirikata libproxyobject -- COLLADA Models Document
libproxyobject/plugins/collada/ColladaDocumentLoader.hpp:/*  Sirikata libproxyobject -- Collada Models Document Loader
libproxyobject/plugins/collada/ColladaDocumentLoader.hpp: * A class designed to (one-shot) load a single COLLADA document using OpenCOLLADA.
libproxyobject/plugins/collada/ColladaDocumentImporter.hpp:/*  Sirikata libproxyobject -- COLLADA Document Importer
libproxyobject/plugins/collada/ColladaDocumentImporter.hpp: *  COLLADA documents and re-Writing (i.e. converting) the data to suit the application.
libproxyobject/plugins/collada/ColladaDocumentImporter.hpp:        enum State { CANCELLED = -1, IDLE, STARTED, FINISHED };
libproxyobject/plugins/collada/ColladaAsset.cpp:/*  Sirikata libproxyobject -- COLLADA Models Asset
libproxyobject/plugins/collada/ColladaPlugin.cpp:/*  Sirikata libproxyboject -- Object Host Plugin for COLLADA
libproxyobject/plugins/collada/ColladaPlugin.cpp:    return --core_plugin_refcount;
libproxyobject/plugins/collada/ColladaPlugin.cpp:        --core_plugin_refcount;
libproxyobject/plugins/collada/ColladaMeshObject.hpp:/*  Sirikata libproxyobject -- Collada Models Mesh Object
libproxyobject/plugins/collada/ColladaSystem.cpp:/*  Sirikata libproxyobject -- COLLADA Models System
libproxyobject/plugins/collada/ColladaSystem.cpp:    Transfer::TransferManager* transferManager = static_cast< Transfer::TransferManager* > ( mTransferManager->as< void* > () );
libproxyobject/plugins/collada/ColladaSystem.cpp:        transferManager->download ( what, listener, Transfer::Range ( true ) );
libproxyobject/plugins/collada/ColladaSystem.cpp:            << " status: " <<  (int)(ev->getStatus ())
libproxyobject/plugins/collada/ColladaSystem.cpp:            << " length: " <<  ev->data ().length ()
libproxyobject/plugins/collada/ColladaSystem.cpp:    if ( ev->getStatus () == Transfer::TransferManager::SUCCESS )
libproxyobject/plugins/collada/ColladaSystem.cpp:        Transfer::DenseDataPtr flatData = ev->data ().flatten ();
libproxyobject/plugins/collada/ColladaSystem.cpp:        char const* buffer = reinterpret_cast< char const* > ( flatData->begin () );
libproxyobject/plugins/collada/ColladaSystem.cpp:        if ( loader.load ( buffer , flatData->length () ) )
libproxyobject/plugins/collada/ColladaSystem.cpp:    if ( system->initialize ( proxyManager, options ) )
libproxyobject/plugins/collada/ColladaSystem.cpp:    OptionSet::getOptions ( "colladamodels", this )->parse ( options );
libproxyobject/plugins/collada/ColladaSystem.cpp:    proxyManager->addListener ( this );
libproxyobject/plugins/collada/ColladaSystem.cpp:    assert((std::cout << "MCB: onCreateProxy (" << proxy << ") entered for ID: " << proxy->getObjectReference () << std::endl,true));
libproxyobject/plugins/collada/ColladaSystem.cpp:        assert((std::cout << "MCB: onCreateProxy (" << asMesh << ") entered for mesh ID: " << asMesh->getObjectReference () << std::endl,true));
libproxyobject/plugins/collada/ColladaSystem.cpp:        if ( ! proxy->hasModelObject () )
libproxyobject/plugins/collada/ColladaSystem.cpp:            asMesh->setModelObject ( mesh );  // MCB: hoist to a common base class? with overloads??
libproxyobject/plugins/collada/ColladaSystem.cpp://            asMesh->MeshProvider::addListener ( mesh );
libproxyobject/plugins/collada/ColladaSystem.cpp:        std::cout << "MCB: onDestroyProxy (" << asMesh << ") entered for mesh URI: " << asMesh->getMesh () << std::endl;
libproxyobject/plugins/collada/ColladaErrorHandler.hpp:/*  Sirikata libproxyobject -- COLLADA Error Handler
libproxyobject/plugins/collada/ColladaAsset.hpp:/*  Sirikata libproxyobject -- COLLADA Models Asset
libproxyobject/plugins/collada/ColladaMeshObject.cpp:/*  Sirikata libproxyobject -- Collada Models Mesh Object
libproxyobject/plugins/bullet/BulletSystem.hpp:/*  Sirikata libproxyobject -- Bullet Graphics Plugin
libproxyobject/plugins/bullet/BulletSystem.hpp:#define GRAVITY (-9.8f)
libproxyobject/plugins/bullet/BulletSystem.hpp:                 dead simple, brute-force parsing of ogre.mesh to get the precious vertex data for physics
libproxyobject/plugins/bullet/BulletSystem.hpp:            e = -e;
libproxyobject/plugins/bullet/BulletSystem.hpp:        /// the format is IEEE single-precision float; I don't trust casting to work everywhere
libproxyobject/plugins/bullet/BulletSystem.hpp:        sign = u>>31?-1:1;
libproxyobject/plugins/bullet/BulletSystem.hpp:        v = (sign * power(2.0, (exp-127)) ) * man;
libproxyobject/plugins/bullet/BulletSystem.hpp:                    indices->push_back(indexes32Bit?read_u32():read_u16());
libproxyobject/plugins/bullet/BulletSystem.hpp:                read_chunks((count-10));
libproxyobject/plugins/bullet/BulletSystem.hpp:                read_chunks((count-6));
libproxyobject/plugins/bullet/BulletSystem.hpp:                skip = (floatsPerVertex-3);
libproxyobject/plugins/bullet/BulletSystem.hpp:                        vertices->push_back(read_float());
libproxyobject/plugins/bullet/BulletSystem.hpp:                    bounds->push_back(read_float());
libproxyobject/plugins/bullet/BulletSystem.hpp:                ix = (ix+(count-6));
libproxyobject/plugins/bullet/BulletSystem.hpp:        this->vertices = &vertices;
libproxyobject/plugins/bullet/BulletSystem.hpp:        this->indices = &indices;
libproxyobject/plugins/bullet/BulletSystem.hpp:        this->bounds = &bounds;
libproxyobject/plugins/bullet/BulletSystem.hpp:        this->vertices = &vertices;
libproxyobject/plugins/bullet/BulletSystem.hpp:        this->indices = &indices;
libproxyobject/plugins/bullet/BulletSystem.hpp:        this->bounds = &bounds;
libproxyobject/plugins/bullet/BulletSystem.hpp:        this->p = p;
libproxyobject/plugins/bullet/BulletSystem.hpp:        this->o = o;
libproxyobject/plugins/bullet/BulletSystem.hpp:        this->p = Vector3d(p.getX(), p.getY(), p.getZ());
libproxyobject/plugins/bullet/BulletSystem.hpp:        this->o = Quaternion(o.getX(), o.getY(), o.getZ(), o.getW(), Quaternion::XYZW());
libproxyobject/plugins/bullet/BulletSystem.hpp:    btScalar* mBtVertices;//<-- this dude must be aligned on 16 byte boundaries
libproxyobject/plugins/bullet/BulletSystem.hpp:    /// public members -- yes, I use 'em.  No, I don't always thicken my code with gettr/settr's
libproxyobject/plugins/bullet/BulletSystem.hpp:        this->bt2siri=bt2siri;
libproxyobject/plugins/bullet/BulletSystem.hpp:        if (os->initialize(proxyManager,offset,options))
libproxyobject/plugins/bullet/BulletSystem.hpp:            if (objects[i]->mMeshptr==meshptr) {
libproxyobject/plugins/bullet/BulletSystem.cpp:/*  Sirikata libproxyobject -- Bullet Graphics Plugin
libproxyobject/plugins/bullet/BulletSystem.cpp:    return --core_plugin_refcount;
libproxyobject/plugins/bullet/BulletSystem.cpp:        core_plugin_refcount--;
libproxyobject/plugins/bullet/BulletSystem.cpp:    return mMeshptr->getObjectReference().object();
libproxyobject/plugins/bullet/BulletSystem.cpp:    return mMeshptr->getObjectReference().space();
libproxyobject/plugins/bullet/BulletSystem.cpp:    buildBulletShape(NULL, 0, mass, mMeshdata!=0);        /// null, 0 means re-use original vertices
libproxyobject/plugins/bullet/BulletSystem.cpp:            mColShape->calculateLocalInertia(mass,localInertia);
libproxyobject/plugins/bullet/BulletSystem.cpp:    mBulletBodyPtr->setCollisionShape(mColShape);
libproxyobject/plugins/bullet/BulletSystem.cpp:    mBulletBodyPtr->setMassProps(mass, localInertia);
libproxyobject/plugins/bullet/BulletSystem.cpp:    mBulletBodyPtr->setGravity(btVector3(mGravity.x, mGravity.y, mGravity.z));  /// otherwise gravity assumes old inertia!
libproxyobject/plugins/bullet/BulletSystem.cpp:    mBulletBodyPtr->activate(true);
libproxyobject/plugins/bullet/BulletSystem.cpp:    mGravity = system->getGravity() * pp.gravity;
libproxyobject/plugins/bullet/BulletSystem.cpp:        mMeshptr->setLocationAuthority(0);
libproxyobject/plugins/bullet/BulletSystem.cpp:        if (mDynamic && (!mMeshptr->isLocal()) ) {      /// for now, physics ignores dynamic objects on other hosts
libproxyobject/plugins/bullet/BulletSystem.cpp:            DEBUG_OUTPUT(cout << "  dbm: debug onSetPhysical: disabling dynamic&non-local" << endl);
libproxyobject/plugins/bullet/BulletSystem.cpp:            mMeshptr->setLocationAuthority(0);
libproxyobject/plugins/bullet/BulletSystem.cpp:        po.p = mMeshptr->getPosition();
libproxyobject/plugins/bullet/BulletSystem.cpp:        po.o = mMeshptr->getOrientation();
libproxyobject/plugins/bullet/BulletSystem.cpp:        Vector3f size = mMeshptr->getScale();
libproxyobject/plugins/bullet/BulletSystem.cpp:        system->addPhysicalObject(this, po, pp.density, pp.friction, pp.bounce, pp.hull, size.x, size.y, size.z);
libproxyobject/plugins/bullet/BulletSystem.cpp:        mMeshptr->setLocationAuthority(this);
libproxyobject/plugins/bullet/BulletSystem.cpp:    this->mBulletBodyPtr->getMotionState()->getWorldTransform(trans);
libproxyobject/plugins/bullet/BulletSystem.cpp:    mBulletBodyPtr->getMotionState()->getWorldTransform(trans);
libproxyobject/plugins/bullet/BulletSystem.cpp:        mBulletBodyPtr->proceedToTransform(trans);           /// how to move dynamic objects
libproxyobject/plugins/bullet/BulletSystem.cpp:        mBulletBodyPtr->getMotionState()->setWorldTransform(trans);   /// how to move 'kinematic' objects (animated)
libproxyobject/plugins/bullet/BulletSystem.cpp:    mBulletBodyPtr->activate(true);      /// wake up, you lazy slob!
libproxyobject/plugins/bullet/BulletSystem.cpp:        /// create a mesh-based static (not dynamic ie forces, though kinematic, ie movable) object
libproxyobject/plugins/bullet/BulletSystem.cpp:            if (is_collada && mMeshdata->geometry.size() > 0) {
libproxyobject/plugins/bullet/BulletSystem.cpp:                const SubMeshGeometry& subm = *(mMeshdata->geometry[0]);
libproxyobject/plugins/bullet/BulletSystem.cpp:        btVector3 aabbMin(-10000,-10000,-10000),aabbMax(10000,10000,10000);
libproxyobject/plugins/bullet/BulletSystem.cpp:        mColShape->calculateLocalInertia(mass,localInertia);
libproxyobject/plugins/bullet/BulletSystem.cpp:    body->setFriction(mFriction);
libproxyobject/plugins/bullet/BulletSystem.cpp:    body->setRestitution(mBounce);
libproxyobject/plugins/bullet/BulletSystem.cpp:        body->setCollisionFlags( body->getCollisionFlags() | btCollisionObject::CF_KINEMATIC_OBJECT);
libproxyobject/plugins/bullet/BulletSystem.cpp:        body->setActivationState(DISABLE_DEACTIVATION);
libproxyobject/plugins/bullet/BulletSystem.cpp:            body->setAngularFactor(0);  /// for now, all we do with characters is avoid external angular effects
libproxyobject/plugins/bullet/BulletSystem.cpp:    system->dynamicsWorld->addRigidBody(body);
libproxyobject/plugins/bullet/BulletSystem.cpp:    body->setGravity(btVector3(mGravity.x, mGravity.y, mGravity.z));
libproxyobject/plugins/bullet/BulletSystem.cpp:    system->bt2siri[body]=this;
libproxyobject/plugins/bullet/BulletSystem.cpp://        mBulletBodyPtr->setLinearVelocity(btvel);
libproxyobject/plugins/bullet/BulletSystem.cpp:            cout << "ERROR -- please don't specify an angular speed without an axis" << endl;
libproxyobject/plugins/bullet/BulletSystem.cpp:        axis = mMeshptr->getOrientation() * axis;
libproxyobject/plugins/bullet/BulletSystem.cpp://        mBulletBodyPtr->setAngularVelocity(btangvel);
libproxyobject/plugins/bullet/BulletSystem.cpp:    DEBUG_OUTPUT (cout << "dbm: downloadFinished: status:" << (int)ev->getStatus()
libproxyobject/plugins/bullet/BulletSystem.cpp:                  << " length = " << (int)ev->data().length() << endl);
libproxyobject/plugins/bullet/BulletSystem.cpp:    if (!ev->getStatus()==Transfer::TransferManager::SUCCESS) {
libproxyobject/plugins/bullet/BulletSystem.cpp:        Transfer::DenseDataPtr flatData = ev->data().flatten();
libproxyobject/plugins/bullet/BulletSystem.cpp:        const unsigned char* realData = flatData->data();
libproxyobject/plugins/bullet/BulletSystem.cpp:        bullobj->buildBulletBody(realData, ev->data().length(), false);
libproxyobject/plugins/bullet/BulletSystem.cpp:    /// a bit annoying -- we have to keep all these around in case our mesh isn't available
libproxyobject/plugins/bullet/BulletSystem.cpp:    obj->mDensity = density;
libproxyobject/plugins/bullet/BulletSystem.cpp:    obj->mFriction = friction;
libproxyobject/plugins/bullet/BulletSystem.cpp:    obj->mBounce = bounce;
libproxyobject/plugins/bullet/BulletSystem.cpp:    obj->mSizeX = mSizeX;
libproxyobject/plugins/bullet/BulletSystem.cpp:    obj->mSizeY = mSizeY;
libproxyobject/plugins/bullet/BulletSystem.cpp:    obj->mSizeZ = mSizeZ;
libproxyobject/plugins/bullet/BulletSystem.cpp:    obj->mInitialPo = po;
libproxyobject/plugins/bullet/BulletSystem.cpp:    obj->mHull = hull;
libproxyobject/plugins/bullet/BulletSystem.cpp:    DEBUG_OUTPUT(cout << "dbm: adding active object: " << obj << " shape: " << (int)obj->mShape << endl);
libproxyobject/plugins/bullet/BulletSystem.cpp:    String fn = obj->mMeshptr->getMesh().toString();
libproxyobject/plugins/bullet/BulletSystem.cpp:    if (fn.rfind(".dae")==fn.size()-4) is_collada=true;
libproxyobject/plugins/bullet/BulletSystem.cpp:    if (obj->mDynamic) {
libproxyobject/plugins/bullet/BulletSystem.cpp:        obj->buildBulletBody(NULL, 0, is_collada);                /// no mesh data
libproxyobject/plugins/bullet/BulletSystem.cpp:            /// FIXME: not threadsafe -- need a lock.  This can race with onMeshParsed and no one calls buildBulletBody
libproxyobject/plugins/bullet/BulletSystem.cpp:            /// but -- DH says it's OK, we're always called from a single thread, so whatever
libproxyobject/plugins/bullet/BulletSystem.cpp:            if (obj->mMeshdata) {
libproxyobject/plugins/bullet/BulletSystem.cpp:                obj->buildBulletBody(0, 0, true);
libproxyobject/plugins/bullet/BulletSystem.cpp:            transferManager->download(obj->mMeshptr->getMesh(), std::tr1::bind(&Sirikata::BulletSystem::downloadFinished,
libproxyobject/plugins/bullet/BulletSystem.cpp:            if (objects[i]->mActive) {
libproxyobject/plugins/bullet/BulletSystem.cpp:                dynamicsWorld->removeRigidBody(obj->mBulletBodyPtr);
libproxyobject/plugins/bullet/BulletSystem.cpp:    DEBUG_OUTPUT(cout << "dbm: BulletSystem::tick time: " << (now-mStartTime).toSeconds() << endl;)
libproxyobject/plugins/bullet/BulletSystem.cpp:        delta = now-lasttime;
libproxyobject/plugins/bullet/BulletSystem.cpp:        if ((now-mStartTime) > Duration::seconds(20.0)) {
libproxyobject/plugins/bullet/BulletSystem.cpp:                if (objects[i]->mActive) {
libproxyobject/plugins/bullet/BulletSystem.cpp:                    if (objects[i]->mMeshptr->getPosition() != objects[i]->getBulletState().p ||
libproxyobject/plugins/bullet/BulletSystem.cpp:                            objects[i]->mMeshptr->getOrientation() != objects[i]->getBulletState().o) {
libproxyobject/plugins/bullet/BulletSystem.cpp:                        DEBUG_OUTPUT(cout << "    dbm: object, " << objects[i]->mName << " moved by user!"
libproxyobject/plugins/bullet/BulletSystem.cpp:                                     << " meshpos: " << objects[i]->mMeshptr->getPosition()
libproxyobject/plugins/bullet/BulletSystem.cpp:                                     << " bulletpos before reset: " << objects[i]->getBulletState().p;)
libproxyobject/plugins/bullet/BulletSystem.cpp:                        objects[i]->setBulletState(
libproxyobject/plugins/bullet/BulletSystem.cpp:                                objects[i]->mMeshptr->getPosition(),
libproxyobject/plugins/bullet/BulletSystem.cpp:                                objects[i]->mMeshptr->getOrientation()
libproxyobject/plugins/bullet/BulletSystem.cpp:                        DEBUG_OUTPUT(cout << "bulletpos after reset: " << objects[i]->getBulletState().p << endl;)
libproxyobject/plugins/bullet/BulletSystem.cpp:                    if (objects[i]->mPIDControlEnabled) {
libproxyobject/plugins/bullet/BulletSystem.cpp:                        objects[i]->mBulletBodyPtr->setLinearVelocity(objects[i]->mDesiredLinearVelocity);
libproxyobject/plugins/bullet/BulletSystem.cpp:                        objects[i]->mBulletBodyPtr->setAngularVelocity(objects[i]->mDesiredAngularVelocity);
libproxyobject/plugins/bullet/BulletSystem.cpp:                        if ( (btMagSq(objects[i]->mDesiredLinearVelocity) < 0.001f) &&
libproxyobject/plugins/bullet/BulletSystem.cpp:                                (btMagSq(objects[i]->mDesiredAngularVelocity) < 0.001f) ) {
libproxyobject/plugins/bullet/BulletSystem.cpp:                            objects[i]->mPIDControlEnabled=false;
libproxyobject/plugins/bullet/BulletSystem.cpp:            dynamicsWorld->stepSimulation(delta.toSeconds(),Duration::seconds(10).toSeconds());
libproxyobject/plugins/bullet/BulletSystem.cpp:                if (objects[i]->mActive) {
libproxyobject/plugins/bullet/BulletSystem.cpp:                    po = objects[i]->getBulletState();
libproxyobject/plugins/bullet/BulletSystem.cpp:                    DEBUG_OUTPUT(cout << "    dbm: object, " << objects[i]->mName << ", delta, "
libproxyobject/plugins/bullet/BulletSystem.cpp:                    Time remoteNow=Time::convertFrom(now,mLocalTimeOffset->offset(*objects[i]->mMeshptr));
libproxyobject/plugins/bullet/BulletSystem.cpp:                    Location loc (objects[i]->mMeshptr->globalLocation(remoteNow));
libproxyobject/plugins/bullet/BulletSystem.cpp:                    objects[i]->mMeshptr->setLocation(remoteNow, loc);
libproxyobject/plugins/bullet/BulletSystem.cpp:                if (objects[i]->mName == "queryRay") bugObj = objects[i]->mMeshptr;
libproxyobject/plugins/bullet/BulletSystem.cpp:            //queryRay(Vector3d(48.81, 4618.08, 23.31), Vector3f(0,-1,0), 100.0, dist, norm, sor);  /// BORNHOLM SCENE
libproxyobject/plugins/bullet/BulletSystem.cpp:            queryRay(Vector3d(0, 10, 0), Vector3f(0,-1,0), 20.0, bugObj, dist, norm, sor);
libproxyobject/plugins/bullet/BulletSystem.cpp:            for (customDispatch::CollisionPairMap::iterator i=dispatcher->collisionPairs.begin();
libproxyobject/plugins/bullet/BulletSystem.cpp:                    i != dispatcher->collisionPairs.end(); /*increment in if*/) {
libproxyobject/plugins/bullet/BulletSystem.cpp:                BulletObj* b0=anExampleCollidingMesh=i->first.getLower();
libproxyobject/plugins/bullet/BulletSystem.cpp:                BulletObj* b1=i->first.getHigher();
libproxyobject/plugins/bullet/BulletSystem.cpp:                ObjectReference b0id=b0->getObjectReference();
libproxyobject/plugins/bullet/BulletSystem.cpp:                ObjectReference b1id=b1->getObjectReference();
libproxyobject/plugins/bullet/BulletSystem.cpp:                Time spaceNow=Time::convertFrom(now,mLocalTimeOffset->offset(*b0->mMeshptr));
libproxyobject/plugins/bullet/BulletSystem.cpp:                if (i->second.collidedThisFrame()) {             /// recently colliding; send msg & change mode
libproxyobject/plugins/bullet/BulletSystem.cpp:                    if (!i->second.collidedLastFrame()) {
libproxyobject/plugins/bullet/BulletSystem.cpp:                        if (b1->colMsg & b0->colMask) {
libproxyobject/plugins/bullet/BulletSystem.cpp:                            for (std::vector<customDispatch::ActiveCollisionState::PointCollision>::iterator iter=i->second.mPointCollisions.begin(),iterend=i->second.mPointCollisions.end();iter!=iterend;++iter) {
libproxyobject/plugins/bullet/BulletSystem.cpp:                                collide.add_this_position(iter->mWorldOnHigher);
libproxyobject/plugins/bullet/BulletSystem.cpp:                                collide.add_other_position(iter->mWorldOnLower);
libproxyobject/plugins/bullet/BulletSystem.cpp:                                collide.add_this_normal(iter->mNormalWorldOnHigher);
libproxyobject/plugins/bullet/BulletSystem.cpp:                                collide.add_impulse(iter->mAppliedImpulse);
libproxyobject/plugins/bullet/BulletSystem.cpp:                            collide.SerializeToString(body->add_message("BegCol"));
libproxyobject/plugins/bullet/BulletSystem.cpp:                            cout << "   begin collision msg: " << b0->mName << " --> " << b1->mName
libproxyobject/plugins/bullet/BulletSystem.cpp:                            << " time: " << (Task::LocalTime::now()-mStartTime).toSeconds() << endl;
libproxyobject/plugins/bullet/BulletSystem.cpp:                        if (b0->colMsg & b1->colMask) {
libproxyobject/plugins/bullet/BulletSystem.cpp:                            for (std::vector<customDispatch::ActiveCollisionState::PointCollision>::iterator iter=i->second.mPointCollisions.begin(),iterend=i->second.mPointCollisions.end();iter!=iterend;++iter) {
libproxyobject/plugins/bullet/BulletSystem.cpp:                                collide.add_other_position(iter->mWorldOnHigher);
libproxyobject/plugins/bullet/BulletSystem.cpp:                                collide.add_this_position(iter->mWorldOnLower);
libproxyobject/plugins/bullet/BulletSystem.cpp:                                collide.add_this_normal(-iter->mNormalWorldOnHigher);
libproxyobject/plugins/bullet/BulletSystem.cpp:                                collide.add_impulse(iter->mAppliedImpulse);
libproxyobject/plugins/bullet/BulletSystem.cpp:                            collide.SerializeToString(body->add_message("BegCol"));
libproxyobject/plugins/bullet/BulletSystem.cpp:                            cout << "   begin collision msg: " << b1->mName << " --> " << b0->mName
libproxyobject/plugins/bullet/BulletSystem.cpp:                            << " time: " << (Task::LocalTime::now()-mStartTime).toSeconds() << endl;
libproxyobject/plugins/bullet/BulletSystem.cpp:                    i->second.resetCollisionFlag();
libproxyobject/plugins/bullet/BulletSystem.cpp:                    assert(i->second.collidedLastFrame());
libproxyobject/plugins/bullet/BulletSystem.cpp:                    if (b1->colMsg & b0->colMask) {
libproxyobject/plugins/bullet/BulletSystem.cpp:                        collide.SerializeToString(body->add_message("EndCol"));
libproxyobject/plugins/bullet/BulletSystem.cpp:                        cout << "     end collision msg: " << b0->mName << " --> " << b1->mName
libproxyobject/plugins/bullet/BulletSystem.cpp:                        << " time: " << (Task::LocalTime::now()-mStartTime).toSeconds() << endl;
libproxyobject/plugins/bullet/BulletSystem.cpp:                    if (b0->colMsg & b1->colMask) {
libproxyobject/plugins/bullet/BulletSystem.cpp:                        collide.SerializeToString(body->add_message("EndCol"));
libproxyobject/plugins/bullet/BulletSystem.cpp:                        cout << "     end collision msg: " << b1->mName << " --> " << b0->mName
libproxyobject/plugins/bullet/BulletSystem.cpp:                        << " time: " << (Task::LocalTime::now()-mStartTime).toSeconds() << endl;
libproxyobject/plugins/bullet/BulletSystem.cpp:                    dispatcher->collisionPairs.erase(i++);
libproxyobject/plugins/bullet/BulletSystem.cpp:                    for (std::map<ObjectReference,RoutableMessageBody>::iterator iter=whichMessages->begin(),iterend=whichMessages->end();iter!=iterend;++iter) {
libproxyobject/plugins/bullet/BulletSystem.cpp:                        hdr.set_destination_object(iter->first);
libproxyobject/plugins/bullet/BulletSystem.cpp:                        hdr.set_destination_space(anExampleCollidingMesh->getSpaceID());
libproxyobject/plugins/bullet/BulletSystem.cpp:                        iter->second.SerializeToString(&body);
libproxyobject/plugins/bullet/BulletSystem.cpp:    int size=currentCollisionManifold->getNumContacts();
libproxyobject/plugins/bullet/BulletSystem.cpp:        Vector3d posA=positionFromBullet(first->getBulletSystem(),currentCollisionManifold->getContactPoint(i).getPositionWorldOnA());
libproxyobject/plugins/bullet/BulletSystem.cpp:        Vector3d posB=positionFromBullet(first->getBulletSystem(),currentCollisionManifold->getContactPoint(i).getPositionWorldOnB());
libproxyobject/plugins/bullet/BulletSystem.cpp:        Vector3f nrmB=normalFromBullet(currentCollisionManifold->getContactPoint(i).m_normalWorldOnB);
libproxyobject/plugins/bullet/BulletSystem.cpp:            mPointCollisions[i].mNormalWorldOnHigher=-nrmB;
libproxyobject/plugins/bullet/BulletSystem.cpp:        mPointCollisions[i].mAppliedImpulse=currentCollisionManifold->getContactPoint(i).getAppliedImpulse();
libproxyobject/plugins/bullet/BulletSystem.cpp:    btCollisionObject* colObj0 = (btCollisionObject*)collisionPair.m_pProxy0->m_clientObject;
libproxyobject/plugins/bullet/BulletSystem.cpp:    btCollisionObject* colObj1 = (btCollisionObject*)collisionPair.m_pProxy1->m_clientObject;
libproxyobject/plugins/bullet/BulletSystem.cpp:                collisionPair.m_algorithm->processCollision(colObj0,colObj1,dispatchInfo,&contactPointResult);
libproxyobject/plugins/bullet/BulletSystem.cpp:                btScalar toi = collisionPair.m_algorithm->calculateTimeOfImpact(colObj0,colObj1,dispatchInfo,&contactPointResult);
libproxyobject/plugins/bullet/BulletSystem.cpp:            int contacts = persistentManifold->getNumContacts();
libproxyobject/plugins/bullet/BulletSystem.cpp:                BulletObj* siri0 = ((customDispatch*)(&dispatcher))->bt2siri[0][colObj0];
libproxyobject/plugins/bullet/BulletSystem.cpp:                BulletObj* siri1 = ((customDispatch*)(&dispatcher))->bt2siri[0][colObj1];
libproxyobject/plugins/bullet/BulletSystem.cpp:                    if (siri0->colMask & siri1->colMask) {
libproxyobject/plugins/bullet/BulletSystem.cpp:                        ((customDispatch*)(&dispatcher))->collisionPairs[customDispatch::OrderedCollisionPair(siri0,siri1)].collide(siri0,siri1,persistentManifold);
libproxyobject/plugins/bullet/BulletSystem.cpp:    OptionSet::getOptions("bulletphysics",this)->parse(options);
libproxyobject/plugins/bullet/BulletSystem.cpp:    Transfer::TransferManager* tm = (Transfer::TransferManager*)mTempTferManager->as<void*>();
libproxyobject/plugins/bullet/BulletSystem.cpp:    this->transferManager = tm;
libproxyobject/plugins/bullet/BulletSystem.cpp:    btVector3 worldAabbMin(-10000,-10000,-10000);
libproxyobject/plugins/bullet/BulletSystem.cpp:    dispatcher->setNearCallback(customNearCallback);
libproxyobject/plugins/bullet/BulletSystem.cpp:    dynamicsWorld->setGravity(btVector3(mGravity.x, mGravity.y, mGravity.z));
libproxyobject/plugins/bullet/BulletSystem.cpp:    groundTransform.setOrigin(btVector3(0,groundlevel-1,0));
libproxyobject/plugins/bullet/BulletSystem.cpp:    groundShape->calculateLocalInertia(0.0f,localInertia);
libproxyobject/plugins/bullet/BulletSystem.cpp:    groundBody->setRestitution(0.5);                 /// bouncy for fun & profit
libproxyobject/plugins/bullet/BulletSystem.cpp:    dynamicsWorld->addRigidBody(groundBody);
libproxyobject/plugins/bullet/BulletSystem.cpp:    proxyManager->addListener(this);
libproxyobject/plugins/bullet/BulletSystem.cpp:    /// we don't delete these, the ProxyManager does (I think -- someone does anyway)
libproxyobject/plugins/bullet/BulletSystem.cpp:        DEBUG_OUTPUT(cout << "dbm: onCreateProxy ptr:" << meshptr << " mesh: " << meshptr->getMesh() << endl;)
libproxyobject/plugins/bullet/BulletSystem.cpp:        objects.back()->mMeshptr = meshptr;
libproxyobject/plugins/bullet/BulletSystem.cpp:        meshptr->MeshProvider::addListener(objects.back());
libproxyobject/plugins/bullet/BulletSystem.cpp:        if (objects[i]->mMeshptr==meshptr) {
libproxyobject/plugins/bullet/BulletSystem.cpp:            meshptr->MeshProvider::removeListener(objects[i]);
libproxyobject/plugins/bullet/BulletSystem.cpp:            m_hitNormalWorld = m_collisionObject->getWorldTransform().getBasis()*rayResult.m_hitNormalLocal;
libproxyobject/plugins/bullet/BulletSystem.cpp:    of them).  One-off unreliable messages probably don't even make
libproxyobject/plugins/bullet/BulletSystem.cpp:        (*i)->processMessage(mh,message_body);
libproxyobject/plugins/bullet/BulletSystem.cpp:        btIgnore = mesh2bullet(ignore)->mBulletBodyPtr;         /// right now this is a slow walk in the park
libproxyobject/plugins/bullet/BulletSystem.cpp:    dynamicsWorld->rayTest (start, end, cb);
libproxyobject/plugins/bullet/BulletSystem.cpp:            returnName = obj->mMeshptr->getObjectReference();
libproxyobject/src/ProxyMeshObject.cpp:        mModelObject->setMesh ( mesh );
libproxyobject/src/ProxyMeshObject.cpp:    return mModelObject->getMesh ();
libproxyobject/src/ProxyMeshObject.cpp:        mModelObject->setScale ( scale );
libproxyobject/src/ProxyMeshObject.cpp:    return mModelObject->getScale ();
libproxyobject/src/ProxyMeshObject.cpp:        mModelObject->setPhysical ( pp );
libproxyobject/src/ProxyMeshObject.cpp:    return mModelObject->getPhysical ();
libproxyobject/src/models/MeshObject.cpp:/*  Sirikata liboh -- MeshObject Model Interface (Bridge Pattern)
libproxyobject/src/ProxyObject.cpp:    mDefaultPort = mODPService->bindODPPort(id.space());
libproxyobject/src/ProxyObject.cpp:    //FIXME mManager->notify(&ProxyCreationListener::onDestroyProxy);
libproxyobject/src/ProxyObject.cpp:    return (updatedValue.getPosition()-predictedValue.getPosition()).lengthSquared()>1.0 ||
libproxyobject/src/ProxyObject.cpp:    return mManager->getQueryTracker(getObjectReference());
libproxyobject/src/ProxyObject.cpp:    return mDefaultPort->send(dest, message);
libproxyobject/src/ProxyObject.cpp:        mLocationAuthority->requestLocation(timeStamp, reqLoc);
libproxyobject/src/ProxyObject.cpp:    Location globalParent (parent->globalLocation(timeStamp));
libproxyobject/src/ProxyObject.cpp:        oldParent->ProxyObjectProvider::removeListener(this);
libproxyobject/src/ProxyObject.cpp:    parent->ProxyObjectProvider::addListener(this);
libproxyobject/src/ProxyObject.cpp:    mParentId = parent->getObjectReference();
libproxyobject/src/ProxyObject.cpp:    Location newparentLastGlobal(parent->globalLocation(timeStamp));
libproxyobject/src/ProxyObject.cpp:        oldParent->ProxyObjectProvider::removeListener(this);
libproxyobject/src/ProxyObject.cpp:    ProxyObjectPtr parentProxy(getProxyManager()->getProxyObject(getParent()));
libproxyobject/src/ProxyWebViewObject.cpp:/*  Sirikata Object Host -- Proxy WebView Object
libproxyobject/src/VWObject.cpp:        Persistence::SentReadWriteSet *request = new Persistence::SentReadWriteSet(realThis->getTracker(space));
libproxyobject/src/VWObject.cpp:        request->header().set_destination_space(sentMessage->getSpace());
libproxyobject/src/VWObject.cpp:        request->header().set_destination_object(sentMessage->getRecipient());
libproxyobject/src/VWObject.cpp:        request->header().set_destination_port(Services::PERSISTENCE);
libproxyobject/src/VWObject.cpp:        request->body().add_reads().set_field_name("MeshURI");
libproxyobject/src/VWObject.cpp:        request->body().add_reads().set_field_name("WebViewURL");
libproxyobject/src/VWObject.cpp:        request->body().add_reads().set_field_name("MeshScale");
libproxyobject/src/VWObject.cpp:        request->body().add_reads().set_field_name("Name");
libproxyobject/src/VWObject.cpp:        request->body().add_reads().set_field_name("PhysicalParameters");
libproxyobject/src/VWObject.cpp:        request->body().add_reads().set_field_name("LightInfo");
libproxyobject/src/VWObject.cpp:        request->body().add_reads().set_field_name("_Passwd");
libproxyobject/src/VWObject.cpp:        request->body().add_reads().set_field_name("IsCamera");
libproxyobject/src/VWObject.cpp:        request->body().add_reads().set_field_name("Parent");
libproxyobject/src/VWObject.cpp:        request->setPersistenceCallback(std::tr1::bind(&VWObject::receivedProxObjectProperties,
libproxyobject/src/VWObject.cpp:        request->setTimeout(Duration::seconds(5.0));
libproxyobject/src/VWObject.cpp:        request->serializeSend();
libproxyobject/src/VWObject.cpp:    ProxyManager *proxyMgr = realThis->getProxyManager(sentMessage->getSpace());
libproxyobject/src/VWObject.cpp:    SpaceObjectReference proximateObjectId(sentMessage->getSpace(), sentMessage->getRecipient());
libproxyobject/src/VWObject.cpp:    for (int i = 0; i < sentMessage->body().reads_size(); i++) {
libproxyobject/src/VWObject.cpp:        if (!sentMessage->body().reads(i).has_data() && !sentMessage->body().reads(i).has_return_status()) {
libproxyobject/src/VWObject.cpp:    for (int i = 0; i < sentMessage->body().reads_size(); ++i) {
libproxyobject/src/VWObject.cpp:        if (sentMessage->body().reads(i).has_return_status()) {
libproxyobject/src/VWObject.cpp:        const std::string &field = sentMessage->body().reads(i).field_name();
libproxyobject/src/VWObject.cpp:    proxyObj->setLocal(false);
libproxyobject/src/VWObject.cpp:    realThis->applyPositionUpdate(proxyObj, objLoc, true);
libproxyobject/src/VWObject.cpp:    proxyMgr->createObject(proxyObj, realThis->getTracker(space));
libproxyobject/src/VWObject.cpp:    for (int i = 0; i < sentMessage->body().reads_size(); ++i) {
libproxyobject/src/VWObject.cpp:        if (sentMessage->body().reads(i).has_return_status()) {
libproxyobject/src/VWObject.cpp:            const std::string &field = sentMessage->body().reads(i).field_name();
libproxyobject/src/VWObject.cpp:            realThis->receivedPropertyUpdate(proxyObj, sentMessage->body().reads(i).field_name(), sentMessage->body().reads(i).data());
libproxyobject/src/VWObject.cpp:        RPCMessage *request = new RPCMessage(realThis->getTracker(space),std::tr1::bind(&receivedPositionUpdateResponse, weakThis, _1, _2, _3));
libproxyobject/src/VWObject.cpp:        request->header().set_destination_space(proximateObjectId.space());
libproxyobject/src/VWObject.cpp:        request->header().set_destination_object(proximateObjectId.object());
libproxyobject/src/VWObject.cpp:        loc.SerializeToString(request->body().add_message("LocRequest"));
libproxyobject/src/VWObject.cpp:        request->serializeSend();
libproxyobject/src/VWObject.cpp:        objLoc.set_timestamp(proxy->getProxyManager()->getTimeOffsetManager()->now(*proxy));
libproxyobject/src/VWObject.cpp:    Location currentLoc = proxy->globalLocation(objLoc.timestamp());
libproxyobject/src/VWObject.cpp:        proxy->resetLocation(objLoc.timestamp(), currentLoc);
libproxyobject/src/VWObject.cpp:        proxy->setLocation(objLoc.timestamp(), currentLoc);
libproxyobject/src/VWObject.cpp:                SILOG(cppoh,info, "* Received MESH property update for " << proxy->getObjectReference().object() <<" has mesh URI "<<URI(parsedProperty.value()));
libproxyobject/src/VWObject.cpp:                proxymesh->setMesh(URI(parsedProperty.value()));
libproxyobject/src/VWObject.cpp:                proxywv->loadURL(parsedProperty.value());
libproxyobject/src/VWObject.cpp:                proxymesh->setScale(parsedProperty.value());
libproxyobject/src/VWObject.cpp:            proxylight->update(LightInfo(parsedLight));
libproxyobject/src/VWObject.cpp:            params.name = proxymesh->getPhysical().name;        /// otherwise setPhysical will wipe it
libproxyobject/src/VWObject.cpp:            proxymesh->setPhysical(params);
libproxyobject/src/VWObject.cpp:            ProxyObjectPtr obj =proxy->getProxyManager()->getProxyObject(
libproxyobject/src/VWObject.cpp:                    proxy->getObjectReference().space(),
libproxyobject/src/VWObject.cpp:                proxy->setParent(obj, proxy->getProxyManager()->getTimeOffsetManager()->now(*proxy));
libproxyobject/src/VWObject.cpp:            PhysicalParameters params = proxymesh->getPhysical();
libproxyobject/src/VWObject.cpp:            proxymesh->setPhysical(params);
libproxyobject/src/VWObject.cpp:    const SpaceID &space = sentMessage->getSpace();
libproxyobject/src/VWObject.cpp:    ProxyManager *pm = thus->getProxyManager(space);
libproxyobject/src/VWObject.cpp:        ProxyObjectPtr obj(pm->getProxyObject(
libproxyobject/src/VWObject.cpp:                               SpaceObjectReference(space, sentMessage->getRecipient())));
libproxyobject/src/VWObject.cpp:            thus->applyPositionUpdate(obj,loc,false);
libproxyobject/src/VWObject.cpp:    if(thus->isLocal(SpaceObjectReference(hdr.destination_space(),hdr.source_object()))) {
libproxyobject/src/VWObject.cpp:        static_cast<RPCMessage*>(sentMessage)->serializeSend(); // Resend position update each time we get one.
libproxyobject/src/VWObject.cpp:        ProxyObjectPtr proxyObj (proxyMgr->getProxyObject(proximateObjectId));
libproxyobject/src/VWObject.cpp:            if (!proxyObj) { // FIXME: We may get one of these for each prox query. Keep track of in-progress queries in ProxyManager.
libproxyobject/src/VWObject.cpp:                    locRequest->header().set_destination_space(proximateObjectId.space());
libproxyobject/src/VWObject.cpp:                    locRequest->header().set_destination_object(proximateObjectId.object());
libproxyobject/src/VWObject.cpp:                    loc.SerializeToString(locRequest->body().add_message("LocRequest"));
libproxyobject/src/VWObject.cpp:                    locRequest->setTimeout(Duration::seconds(5.0));
libproxyobject/src/VWObject.cpp:                    locRequest->serializeSend();
libproxyobject/src/VWObject.cpp:                proxyMgr->createObject(proxyObj, this->getTracker(space));
libproxyobject/src/VWObject.cpp:            // Do not create a proxy object in this case: This message is for one-time queries
libproxyobject/src/ModelsSystemFactory.cpp:/*  Sirikata Object Host -- Models System Factory
