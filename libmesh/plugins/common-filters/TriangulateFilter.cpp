/*  Sirikata
 *  TriangulateFilter.cpp
 *
 *  Copyright (c) 2010, Ewen Cheslack-Postava
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are
 *  met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *  * Neither the name of Sirikata nor the names of its contributors may
 *    be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "TriangulateFilter.hpp"

namespace Sirikata {
namespace Mesh {

Filter* TriangulateFilter::create(const String& args) {
    bool tri_strips = false;
    bool tri_fans = false;
    if (args.size() == 0) {
        tri_strips = true;
        tri_fans = true;
    }
    else {
        if (args == "tristrip")
            tri_strips = true;
        else if (args == "trifan")
            tri_fans = true;
        else if (args == "all") {
            tri_strips = true;
            tri_fans = true;
        }
    }

    return new TriangulateFilter(tri_strips, tri_fans);
}

TriangulateFilter::TriangulateFilter(bool tristrips, bool trifans)
 : mTriStrips(tristrips), mTriFans(trifans)
{
}

FilterDataPtr TriangulateFilter::apply(FilterDataPtr input) {
    for(FilterData::const_iterator md_it = input->begin(); md_it != input->end(); md_it++) {
        MeshdataPtr md = *md_it;

        // We just run through the primitives in each SubMeshGeometry and
        // transform each one as necessary
        for(SubMeshGeometryList::iterator sm_it = md->geometry.begin(); sm_it != md->geometry.end(); sm_it++) {
            SubMeshGeometry& smg = *sm_it;
            for(std::vector<SubMeshGeometry::Primitive>::iterator prim_it = smg.primitives.begin(); prim_it != smg.primitives.end(); prim_it++) {
                if (prim_it->primitiveType == SubMeshGeometry::Primitive::TRISTRIPS && mTriStrips) {
                    SubMeshGeometry::Primitive new_prim;
                    new_prim.primitiveType = SubMeshGeometry::Primitive::TRIANGLES;
                    new_prim.materialId = prim_it->materialId;

                    // Triangle strips have n triangles generated by n+2
                    // indices. Triangle n is defined by vertices n, n+1, n+2.
                    // This is simple enough, but we need to pay careful
                    // attention to winding order. From the GL Programming
                    // Guide:
                    //
                    //   GL_TRIANGLE_STRIP Draws a series of triangles
                    //   (three-sided polygons) using vertices v0, v1, v2, then
                    //   v2, v1, v3 (note the order), then v2, v3, v4, and so
                    //   on. The ordering is to ensure that the triangles are
                    //   all drawn with the same orientation so that the strip
                    //   can correctly form part of a surface.
                    //
                    // (This is what COLLADA and pretty much everybody else does,
                    // the GL Programming Guide just has a nicer explanation.)
                    //
                    // So our basic approach is to iterate and just track a
                    // flip-flopping winding order based on index, generating
                    // the different triplet for each winding order: 0, 1, 2 or
                    // 1, 0, 2.

                    for(int tri_idx = 0; tri_idx < prim_it->indices.size()-2; tri_idx++) {
                        if (tri_idx % 2 == 0) {
                            new_prim.indices.push_back( prim_it->indices[tri_idx] );
                            new_prim.indices.push_back( prim_it->indices[tri_idx+1] );
                            new_prim.indices.push_back( prim_it->indices[tri_idx+2] );
                        }
                        else {
                            new_prim.indices.push_back( prim_it->indices[tri_idx+1] );
                            new_prim.indices.push_back( prim_it->indices[tri_idx+0] );
                            new_prim.indices.push_back( prim_it->indices[tri_idx+2] );
                        }
                    }

                    *prim_it = new_prim;
                }
                else if (prim_it->primitiveType == SubMeshGeometry::Primitive::TRIFANS && mTriFans) {
                    SubMeshGeometry::Primitive new_prim;
                    new_prim.primitiveType = SubMeshGeometry::Primitive::TRIANGLES;
                    new_prim.materialId = prim_it->materialId;

                    // Triangle fans are pretty simple. They generate n
                    // triangles for n+2 vertices. Triangle n is formed by
                    // vertices 0, n+1, n+2, in that order.
                    for(int tri_idx = 0; tri_idx < prim_it->indices.size()-2; tri_idx++) {
                        new_prim.indices.push_back( prim_it->indices[0] );
                        new_prim.indices.push_back( prim_it->indices[tri_idx+1] );
                        new_prim.indices.push_back( prim_it->indices[tri_idx+2] );
                    }

                    *prim_it = new_prim;
                }
            }
        }
    }

    return input;
}

} // namespace Mesh
} // namespace Sirikata
