#!/usr/bin/python
#
# test.py - Individual system test

import subprocess
import re

import sys
# FIXME It would be nice to have a better way of making this script able to find
# other modules in sibling packages
sys.path.insert(0, sys.path[0]+"/..")

import util.stdio
import util.invoke

class Test:
    def __init__(self, _name):
        self.name = _name

    def run(self, io):
        print >>io.stderr, "Run not implemented for test " + self.name

    """Stores the any log data generated by the test to a standard location
       (the file log).  This should be used by subclasses to store any output
       collected in the course of the test so it is stored for later analysis.
    """
    def _store_log(self, logdata):
        # FIXME we could check logdata and use writelines for lists, write for strings
        log_file = open('log', 'w')
        log_file.write(logdata)
        log_file.close()

class ShellCommandTest(Test):
    # _name: Name of the test
    # _cmd: Command to execute, as list of program and args
    # _warnings: List of keywords to match in stderr and stdout that indicate a warning condition
    # _errors: List of keywords to match in stderr and stdout that indicate an error
    def __init__(self, _name, _cmd, _warnings=['[Ww]arning'], _errors=['[Ee]rror','[Aa]ssert']):
        Test.__init__(self, _name)
        self.cmd = _cmd
        self.warnings = _warnings
        self.errors = _errors

    def run(self, io):
        io = util.stdio.MemoryIO()
        util.invoke.invoke(self.cmd, io)

        result = 'stdout:\n' + io.stdout.getvalue() + '\nstderr:\n' + io.stderr.getvalue() + '\n'
        self._store_log(result)

        # now check for warnings and errors
        has_errors = self.__check_errors(io, result)
        has_warnings = self.__check_warnings(io, result)

        if has_errors:
            print >>io.stdout, self.name, "Failed"
            return False

        if has_warnings:
            print >>io.stdout, self.name, "Succeeded with warnings"
        else:
            print >>io.stdout, self.name, "Succeeded"
        return True

    def __check_warnings(self, io, output):
        return self.__check_output(io, output, self.warnings)

    def __check_errors(self, io, output):
        return self.__check_output(io, output, self.errors)

    def __check_output(self, io, output, matchers):
        matched = False
        outputlines = output.splitlines()
        for matcher in matchers:
            for line in outputlines:
                found = re.search(matcher, line)
                if found == None:
                    continue
                print >>io.stdout, line
                matched = True
        return matched
