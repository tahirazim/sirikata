#!/usr/bin/python
#
# test.py - Individual system test

import subprocess
import re
from datetime import timedelta

import sys
# FIXME It would be nice to have a better way of making this script able to find
# other modules in sibling packages
sys.path.insert(0, sys.path[0]+"/..")

import util.stdio
import util.invoke

class Test:
    def __init__(self, name, output_flags=[('Warning',['[Ww]arning'],False), ('Error',['[Ee]rror','[Aa]ssert','Segmentation fault'],True)], time_limit=timedelta(minutes=5)):
        """
        name: Name of the test

        output_flags: List of ('ErrorType', [re,ge,xes], CausesFailureBool). ErrorType is
        something like 'Warning' or 'Error', which will be prepended in a report.
        The regex lists contains regexs to check (via re) the output for (by line).
        CausesFailureBool indicates whether a match of one of these regexes should
        cause the entire test to fail.

        """
        self.name = name
        self.output_flags = output_flags
        self.time_limit = time_limit

    def pre_run(self, io):
        """
        Executed before the test is run to allow setup
        processing. This step is not subject to timing
        constraints. The default implementation does nothing.

        Since this step can affect the final success of the test, this
        method returns a boolean indicating its sucess.
        """
        return True

    def run(self, io):
        print >>io.stderr, "Run not implemented for test " + self.name
        return False

    def post_run(self, io):
        """
        Executed after the test is run to allow cleanup and post
        processing.  This step is not subject to timing constraints.
        This is a good time to do analyses that may take a long
        (indeterminate) amount of time.  The default implementation
        does nothing.

        Since this step can affect the final success of the test, this
        method returns a boolean indicating its sucess.
        """
        return True

    def _store_log(self, logdata):
        """
        Stores the any log data generated by the test to a standard location
        (the file log).  This should be used by subclasses to store any output
        collected in the course of the test so it is stored for later analysis.
        """
        # FIXME we could check logdata and use writelines for lists, write for strings
        log_file = open('log', 'w')
        log_file.write(logdata)
        log_file.close()

    def _check_errors(self, io, output):
        """
        Checks for errors reported in the output using the output_flags specified at
        construction.
        """
        failed = False
        outputlines = output.splitlines()
        for error_type,matchers,causes_fail in self.output_flags:
            for line in outputlines:
                matched_one = False
                for matcher in matchers:
                    found = re.search(matcher, line)
                    if found == None:
                        continue
                    matched_one = True
                    if causes_fail:
                        failed = True
                if matched_one:
                    print >>io.stdout, line
        return failed

class ShellCommandTest(Test):
    def __init__(self, name, cmd, **kwargs):
        """
        name: Name of the command
        cmd: Command to execute, as list of program and args
        Others: see Test.__init__
        """

        Test.__init__(self, name, **kwargs)
        self.cmd = cmd

    def run(self, io):
        intermediate_io = util.stdio.MemoryIO()

        try:
            invoke_result = util.invoke.invoke(self.cmd, io=intermediate_io, time_limit=self.time_limit)
        except util.invoke.InvokeTimeLimitError:
            invoke_result = False
            print >>io.stderr, "(Time limit exceeded)",
            io.stderr.flush()

        result = 'stdout:\n' + intermediate_io.stdout.getvalue() + '\nstderr:\n' + intermediate_io.stderr.getvalue() + '\n'
        self._store_log(result)

        # now check for warnings and errors
        failed = self._check_errors(io, result) or not invoke_result

        return not failed
