#!/usr/bin/python
#
# test.py - Individual system test

import subprocess
import re

import sys
# FIXME It would be nice to have a better way of making this script able to find
# other modules in sibling packages
sys.path.insert(0, sys.path[0]+"/..")

import util.stdio
import util.invoke

class Test:
    def __init__(self, name, output_flags=[('Warning',['[Ww]arning'],False), ('Error',['[Ee]rror','[Aa]ssert','Segmentation fault'],True)]):
        """
        name: Name of the test

        output_flags: List of ('ErrorType', [re,ge,xes], CausesFailureBool). ErrorType is
        something like 'Warning' or 'Error', which will be prepended in a report.
        The regex lists contains regexs to check (via re) the output for (by line).
        CausesFailureBool indicates whether a match of one of these regexes should
        cause the entire test to fail.

        """
        self.name = name
        self.output_flags = output_flags

    def run(self, io):
        print >>io.stderr, "Run not implemented for test " + self.name

    """Stores the any log data generated by the test to a standard location
       (the file log).  This should be used by subclasses to store any output
       collected in the course of the test so it is stored for later analysis.
    """
    def _store_log(self, logdata):
        # FIXME we could check logdata and use writelines for lists, write for strings
        log_file = open('log', 'w')
        log_file.write(logdata)
        log_file.close()

    def _check_errors(self, io, output):
        """
        Checks for errors reported in the output using the output_flags specified at
        construction.
        """
        failed = False
        outputlines = output.splitlines()
        for error_type,matchers,causes_fail in self.output_flags:
            for line in outputlines:
                matched_one = False
                for matcher in matchers:
                    found = re.search(matcher, line)
                    if found == None:
                        continue
                    matched_one = True
                    if causes_fail:
                        failed = True
                if matched_one:
                    print >>io.stdout, line
        return failed

class ShellCommandTest(Test):
    def __init__(self, name, cmd, **kwargs):
        """
        name: Name of the command
        cmd: Command to execute, as list of program and args
        Others: see Test.__init__
        """

        Test.__init__(self, name, **kwargs)
        self.cmd = cmd

    def run(self, io):
        intermediate_io = util.stdio.MemoryIO()
        util.invoke.invoke(self.cmd, intermediate_io)

        result = 'stdout:\n' + intermediate_io.stdout.getvalue() + '\nstderr:\n' + intermediate_io.stderr.getvalue() + '\n'
        self._store_log(result)

        # now check for warnings and errors
        failed = self._check_errors(io, result)

        return not failed
