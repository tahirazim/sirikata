# Searches for an installation of Sirikata. On success, it sets the following variables:
#
#   Sirikata_FOUND                A meta indicator - true if SirikataCore_FOUND is true and
#                                 Sirikata_INCLUDE_DIR is non-empty, i.e. we found enough stuff to be useful.
#   SirikataCore_FOUND            Set to true to indicate the Sirikata core library was found.
#   SirikataOH_FOUND              Set to true to indicate the Sirikata object host library was found.
#   SirikataSpace_FOUND           Set to true to indicate the Sirikata space library was found.
#
#   Sirikata_INCLUDE_DIR          The directory containing the header file sirikata/util/Platform.hpp
#   SirikataCore_LIBRARIES        The libraries needed to use the Sirikata core library
#   SirikataOH_LIBRARIES          The libraries needed to use the Sirikata object host library, if it was found
#   SirikataSpace_LIBRARIES       The libraries needed to use the Sirikata space library, if it was found
#
#   Sirikata_PBJ                  The pbj binary generated by Sirikata.
#   Sirikata_Space                The space binary generated by Sirikata.
#   Sirikata_OH                   The oh binary generated by Sirikata.
#
# To help the script find Sirikata, you can specify either or both of SIRIKATA_CODE_ROOT and SIRIKATA_INSTALL_ROOT.
# The former specifies a location where the entire source tree, as checked out from git, can be found.  The latter
# specifies the prefix into which Sirikata was installed.
#
# When SIRIKATA_CODE_ROOT is defined, the following variables will be set if the corresponding dependency
# directory can be found for them in that directory:
#
#   Sirikata_CMAKE_MODULES     The directory containing Sirikata's custom CMake Modules
#   Sirikata_BOOST_ROOT        The directory where the boost dependency is installed.
#   Sirikata_PROTOBUFS_ROOT    The directory where the protocol buffers dependency is installed.
#   Sirikata_PBJ_ROOT          The directory where the PBJ code is checked out
#
# Copyright (C) Siddhartha Chaudhuri, 2009
#

# Look for the header, first in the user-specified location and then in the system locations
SET(Sirikata_INCLUDE_DOC "The directory containing the header file sirikata/util/Platform.hpp")
FIND_PATH(Sirikata_INCLUDE_DIR NAMES sirikata/core/util/Platform.hpp PATHS ${SIRIKATA_INSTALL_ROOT} ${SIRIKATA_INSTALL_ROOT}/include
          DOC ${Sirikata_INCLUDE_DOC} NO_DEFAULT_PATH)
IF(NOT Sirikata_INCLUDE_DIR)  # now look in system locations
  FIND_PATH(Sirikata_INCLUDE_DIR NAMES sirikata/core/util/Platform.hpp
            DOC ${Sirikata_INCLUDE_DOC})
ENDIF()

SET(Sirikata_FOUND FALSE)
SET(SirikataCore_FOUND FALSE)
SET(SirikataOH_FOUND FALSE)
SET(SirikataSpace_FOUND FALSE)


# Clear variables out
SET(Sirikata_BASE_DIR)
SET(Sirikata_BIN_DIR)
SET(Sirikata_LIB_DIR)

IF(Sirikata_INCLUDE_DIR)
  # Figure out the base directory, currently only tries to go up from the include dir
  SET(Sirikata_BASE_DIR ${Sirikata_INCLUDE_DIR})

  IF("${Sirikata_BASE_DIR}" MATCHES "/include$")
    # Strip off the trailing "/include" in the path.
    GET_FILENAME_COMPONENT(Sirikata_BASE_DIR ${Sirikata_BASE_DIR} PATH)
  ENDIF()
ENDIF()

IF(Sirikata_BASE_DIR)
  # Now try to fill in bin and lib directory vars
  IF(EXISTS "${Sirikata_BASE_DIR}/bin")
    SET(Sirikata_BIN_DIR ${Sirikata_BASE_DIR}/bin)
  ENDIF()
  IF(EXISTS "${Sirikata_BASE_DIR}/lib")
    SET(Sirikata_LIB_DIR ${Sirikata_BASE_DIR}/lib)
  ENDIF()
ENDIF()

# If we found a bin directory, try to find the binaries
IF(Sirikata_BIN_DIR)
  FIND_PROGRAM(Sirikata_PBJ
               NAMES pbj pbj_d
               PATH_SUFFIXES "" Release Debug
               PATHS ${Sirikata_BIN_DIR}
               NO_DEFAULT_PATH)

  FIND_PROGRAM(Sirikata_Space
               NAMES space space_d
               PATH_SUFFIXES "" Release Debug
               PATHS ${Sirikata_BIN_DIR}
               NO_DEFAULT_PATH)

  FIND_PROGRAM(Sirikata_OH
               NAMES cppoh cppoh_d
               PATH_SUFFIXES "" Release Debug
               PATHS ${Sirikata_BIN_DIR}
               NO_DEFAULT_PATH)
ENDIF()

IF(Sirikata_BIN_DIR AND Sirikata_INCLUDE_DIR AND Sirikata_LIB_DIR)
  # Find SirikataCore libraries
  FIND_LIBRARY(SirikataCore_DEBUG_LIBRARY
               NAMES sirikata-core_d sirikata-cored libsirikata-core_d libsirikata-cored
               PATH_SUFFIXES "" Debug
               PATHS ${Sirikata_LIB_DIR}
               NO_DEFAULT_PATH)
  FIND_LIBRARY(SirikataCore_RELEASE_LIBRARY
               NAMES sirikata-core libsirikata-core
               PATH_SUFFIXES "" Release
               PATHS ${Sirikata_LIB_DIR}
               NO_DEFAULT_PATH)

  SET(SirikataCore_LIBRARIES)
  IF(SirikataCore_DEBUG_LIBRARY AND SirikataCore_RELEASE_LIBRARY)
    SET(SirikataCore_LIBRARIES debug ${SirikataCore_DEBUG_LIBRARY} optimized ${SirikataCore_RELEASE_LIBRARY})
  ELSEIF(SirikataCore_DEBUG_LIBRARY)
    SET(SirikataCore_LIBRARIES ${SirikataCore_DEBUG_LIBRARY})
  ELSEIF(SirikataCore_RELEASE_LIBRARY)
    SET(SirikataCore_LIBRARIES ${SirikataCore_RELEASE_LIBRARY})
  ENDIF()

  IF(SirikataCore_LIBRARIES)
    SET(SirikataCore_FOUND TRUE)

    # We only check for the other libraries inside here because they are useless
    # if we don't have the core library to link to as well.

    # Find SirikataOH libraries
    FIND_LIBRARY(SirikataOH_DEBUG_LIBRARY
                 NAMES sirikata-oh_d sirikata-ohd libsirikata-oh_d libsirikata-ohd
                 PATH_SUFFIXES "" Debug
                 PATHS ${Sirikata_LIB_DIR}
                 NO_DEFAULT_PATH)
    FIND_LIBRARY(SirikataOH_RELEASE_LIBRARY
                 NAMES sirikata-oh libsirikata-oh
                 PATH_SUFFIXES "" Release
                 PATHS ${Sirikata_LIB_DIR}
                 NO_DEFAULT_PATH)

    SET(SirikataOH_LIBRARIES)
    IF(SirikataOH_DEBUG_LIBRARY AND SirikataOH_RELEASE_LIBRARY)
      SET(SirikataOH_LIBRARIES debug ${SirikataOH_DEBUG_LIBRARY} optimized ${SirikataOH_RELEASE_LIBRARY})
    ELSEIF(SirikataOH_DEBUG_LIBRARY)
      SET(SirikataOH_LIBRARIES ${SirikataOH_DEBUG_LIBRARY})
    ELSEIF(SirikataOH_RELEASE_LIBRARY)
      SET(SirikataOH_LIBRARIES ${SirikataOH_RELEASE_LIBRARY})
    ENDIF()

    IF(SirikataOH_LIBRARIES)
      SET(SirikataOH_FOUND TRUE)
    ENDIF()


    # Find SirikataSpace libraries
    FIND_LIBRARY(SirikataSpace_DEBUG_LIBRARY
                 NAMES sirikata-space_d sirikata-spaced libsirikata-space_d libsirikata-spaced
                 PATH_SUFFIXES "" Debug
                 PATHS ${Sirikata_LIB_DIR}
                 NO_DEFAULT_PATH)
    FIND_LIBRARY(SirikataSpace_RELEASE_LIBRARY
                 NAMES sirikata-space libsirikata-space
                 PATH_SUFFIXES "" Release
                 PATHS ${Sirikata_LIB_DIR}
                 NO_DEFAULT_PATH)

    SET(SirikataSpace_LIBRARIES)
    IF(SirikataSpace_DEBUG_LIBRARY AND SirikataSpace_RELEASE_LIBRARY)
      SET(SirikataSpace_LIBRARIES debug ${SirikataSpace_DEBUG_LIBRARY} optimized ${SirikataSpace_RELEASE_LIBRARY})
    ELSEIF(SirikataSpace_DEBUG_LIBRARY)
      SET(SirikataSpace_LIBRARIES ${SirikataSpace_DEBUG_LIBRARY})
    ELSEIF(SirikataSpace_RELEASE_LIBRARY)
      SET(SirikataSpace_LIBRARIES ${SirikataSpace_RELEASE_LIBRARY})
    ENDIF()

    IF(SirikataSpace_LIBRARIES)
      SET(SirikataSpace_FOUND TRUE)
    ENDIF()

  ENDIF()
ENDIF()

IF(SirikataCore_FOUND AND Sirikata_INCLUDE_DIR)
  SET(Sirikata_FOUND TRUE)
ENDIF()

# Try to find dependency directories.  This is essentially independent of all the previous work.
IF(SIRIKATA_CODE_ROOT)
  # cmake modules
  IF(EXISTS ${SIRIKATA_CODE_ROOT}/build/modules)
    SET(Sirikata_CMAKE_MODULES ${SIRIKATA_CODE_ROOT}/build/modules)
    GET_FILENAME_COMPONENT(Sirikata_CMAKE_MODULES ${Sirikata_CMAKE_MODULES} ABSOLUTE)
  ENDIF()


  # dependencies
  IF(EXISTS ${SIRIKATA_CODE_ROOT}/dependencies)
    SET(SIRIKATA_DEPENDENCIES_ROOT ${SIRIKATA_CODE_ROOT}/dependencies)
  ENDIF()

  # externals
  IF(EXISTS ${SIRIKATA_CODE_ROOT}/externals)
    SET(SIRIKATA_EXTERNALS_ROOT ${SIRIKATA_CODE_ROOT}/externals)
  ENDIF()

  IF(SIRIKATA_DEPENDENCIES_ROOT)
    GET_FILENAME_COMPONENT(SIRIKATA_DEPENDENCIES_ROOT ${SIRIKATA_DEPENDENCIES_ROOT} ABSOLUTE)

    # boost
    IF(EXISTS ${SIRIKATA_DEPENDENCIES_ROOT}/installed-boost)
      SET(Sirikata_BOOST_ROOT ${SIRIKATA_DEPENDENCIES_ROOT}/installed-boost)
    ENDIF()

    # protocol buffers
    IF(EXISTS ${SIRIKATA_DEPENDENCIES_ROOT}/installed-protobufs)
      SET(Sirikata_PROTOBUFS_ROOT ${SIRIKATA_DEPENDENCIES_ROOT}/installed-protobufs)
    ENDIF()

    # pbj
    IF(EXISTS ${SIRIKATA_EXTERNALS_ROOT}/pbj)
      SET(Sirikata_PBJ_ROOT ${SIRIKATA_EXTERNALS_ROOT}/pbj)
    ENDIF()
  ENDIF()
ENDIF()


# Reporting and final failures if components weren't found
IF(Sirikata_FOUND)
  IF(NOT Sirikata_FIND_QUIETLY)
    MESSAGE(STATUS "Found Sirikata: headers at ${Sirikata_INCLUDE_DIR}")
    IF(Sirikata_PBJ)
      MESSAGE(STATUS "Found Sirikata PBJ: ${Sirikata_PBJ}")
    ENDIF()
    IF(Sirikata_Space)
      MESSAGE(STATUS "Found Sirikata Space: ${Sirikata_Space}")
    ENDIF()
    IF(Sirikata_OH)
      MESSAGE(STATUS "Found Sirikata OH: ${Sirikata_OH}")
    ENDIF()
    IF(SirikataCore_FOUND)
      MESSAGE(STATUS "Found SirikataCore: libraries at ${SirikataCore_LIBRARIES}")
    ENDIF()
    IF(SirikataOH_FOUND)
      MESSAGE(STATUS "Found SirikataOH: libraries at ${SirikataOH_LIBRARIES}")
    ENDIF()
    IF(SirikataSpace_FOUND)
      MESSAGE(STATUS "Found SirikataSpace: libraries at ${SirikataSpace_LIBRARIES}")
    ENDIF()
  ENDIF()
ELSE()
  IF(Sirikata_FIND_REQUIRED)
    MESSAGE(FATAL_ERROR "Sirikata not found")
  ENDIF()
ENDIF()
